!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.5 (r3931) - 24 May 2011 16:27
!
MODULE SIMPLE_ADVECTION_B
  IMPLICIT NONE

CONTAINS
!  Differentiation of advection_action in reverse (adjoint) mode:
!   gradient     of useful results: ac
!   with respect to varying inputs: ac u
!   RW status of diff variables: ac:in-zero u:out
  SUBROUTINE ADVECTION_ACTION_B(x, u, ub, c, ac, acb)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x
    REAL, DIMENSION(:), INTENT(IN) :: u
    REAL, DIMENSION(:) :: ub
    REAL, DIMENSION(:), INTENT(IN) :: c
    REAL, DIMENSION(:) :: ac
    REAL, DIMENSION(:) :: acb
    INTEGER :: ele, ele_count, node_count
    INTEGER, DIMENSION(2) :: ele_nodes
    REAL, DIMENSION(2) :: ele_tmp
    INTEGER :: result1
    INTEGER :: result2
    INTRINSIC SIZE
    node_count = SIZE(x)
    result1 = SIZE(c)
    result2 = SIZE(u)
    IF (result1 .NE. node_count .OR. result2 .NE. node_count) THEN
      STOP
    ELSE
! 1D only, baby
      ele_count = node_count - 1
      ub = 0.0
      DO ele=ele_count,1,-1
        ele_nodes = (/ele, ele+1/)
        CALL ELE_ADVECTION_ACTION_B(ele, ele_nodes, x, u, ub, c, ac, acb&
&                             )
      END DO
      !acb = 0.0
    END IF
  END SUBROUTINE ADVECTION_ACTION_B
  SUBROUTINE ADVECTION_ACTION(x, u, c, ac)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: x
    REAL, DIMENSION(:), INTENT(IN) :: u
    REAL, DIMENSION(:), INTENT(IN) :: c
    REAL, DIMENSION(:), INTENT(OUT) :: ac
    INTEGER :: ele, ele_count, node_count
    INTEGER, DIMENSION(2) :: ele_nodes
    REAL, DIMENSION(2) :: ele_tmp
    INTEGER :: result1
    INTEGER :: result2
    INTRINSIC SIZE
    node_count = SIZE(x)
    result1 = SIZE(c)
    result2 = SIZE(u)
    IF (result1 .NE. node_count .OR. result2 .NE. node_count) THEN
      WRITE(0, *) 'Huh? Everything has to be consistent'
      STOP
    ELSE
! 1D only, baby
      ele_count = node_count - 1
      ac = 0.0
      DO ele=1,ele_count
        ele_nodes = (/ele, ele+1/)
        CALL ELE_ADVECTION_ACTION(ele, ele_nodes, x, u, c, ac)
      END DO
    END IF
  END SUBROUTINE ADVECTION_ACTION
!  Differentiation of ele_advection_action in reverse (adjoint) mode:
!   gradient     of useful results: ac u
!   with respect to varying inputs: ac u
  SUBROUTINE ELE_ADVECTION_ACTION_B(ele, ele_nodes, x, u, ub, c, ac, acb&
&  )
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: ele
    INTEGER, DIMENSION(2), INTENT(IN) :: ele_nodes
    REAL, DIMENSION(:), INTENT(IN) :: x, u, c
    REAL, DIMENSION(:) :: ub
    REAL, DIMENSION(:), INTENT(INOUT) :: ac
    REAL, DIMENSION(:) :: acb
    REAL, DIMENSION(2, 2) :: a
    REAL, DIMENSION(2, 2) :: ab
! loc x ngi
    REAL, DIMENSION(2, 2) :: shape_n
! log x ngi x dim
    REAL, DIMENSION(2, 2, 1) :: dshape_n
    REAL :: h
    REAL, DIMENSION(2) :: detwei
    INTEGER :: i, j
    REAL, DIMENSION(2) :: u_at_quad
    REAL, DIMENSION(2) :: u_at_quadb
    INTEGER :: result1
    REAL :: result10
    REAL :: result10b
    INTEGER :: branch
    INTRINSIC SIZE
    INTRINSIC SUM
! values of basis functions at quad points
    shape_n(1, :) = (/0.78867513459481298, 0.21132486540518702/)
    shape_n(2, :) = (/0.21132486540518702, 0.78867513459481298/)
! values of derivatives of basis functions at quad points
    dshape_n(1, :, 1) = (/-1, -1/)
    dshape_n(2, :, 1) = (/1, 1/)
! step size
    h = x(ele_nodes(2)) - x(ele_nodes(1))
! transform_to_physical
    dshape_n = 1.0/h*dshape_n
    detwei = (/0.5, 0.5/)*h
! Replacement matmul
    DO i=1,2
      u_at_quad(i) = SUM(u(ele_nodes)*shape_n(:, i))
    END DO
    DO i=1,2
      DO j=1,2
! Replacement dot_product
        a(i, j) = SUM(shape_n(i, :)*(dshape_n(j, :, 1)*u_at_quad)*detwei&
&          )
      END DO
    END DO
! Enforce dirichlet BCs
    IF (ele_nodes(1) .EQ. 1) THEN
      a(1, :) = (/1.0, 0.0/)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = SIZE(x)
    IF (ele_nodes(2) .EQ. result1) THEN
      a(2, :) = (/0.0, 1.0/)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    ab = 0.0
    DO i=2,1,-1
      result10b = acb(ele_nodes(i))
      ab(i, :) = ab(i, :) + c(ele_nodes)*result10b
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) ab(2, :) = 0.0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) ab(1, :) = 0.0
    u_at_quadb = 0.0
    DO i=2,1,-1
      DO j=2,1,-1
        u_at_quadb = u_at_quadb + detwei*shape_n(i, :)*dshape_n(j, :, 1)&
&          *ab(i, j)
        ab(i, j) = 0.0
      END DO
    END DO
    DO i=2,1,-1
      ub(ele_nodes) = ub(ele_nodes) + shape_n(:, i)*u_at_quadb(i)
      u_at_quadb(i) = 0.0
    END DO
  END SUBROUTINE ELE_ADVECTION_ACTION_B
  SUBROUTINE ELE_ADVECTION_ACTION(ele, ele_nodes, x, u, c, ac)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: ele
    INTEGER, DIMENSION(2), INTENT(IN) :: ele_nodes
    REAL, DIMENSION(:), INTENT(IN) :: x, u, c
    REAL, DIMENSION(:), INTENT(INOUT) :: ac
    REAL, DIMENSION(2, 2) :: a
! loc x ngi
    REAL, DIMENSION(2, 2) :: shape_n
! log x ngi x dim
    REAL, DIMENSION(2, 2, 1) :: dshape_n
    REAL :: h
    REAL, DIMENSION(2) :: detwei
    INTEGER :: i, j
    REAL, DIMENSION(2) :: u_at_quad
    INTEGER :: result1
    REAL :: result10
    INTRINSIC SIZE
    INTRINSIC SUM
! values of basis functions at quad points
    shape_n(1, :) = (/0.78867513459481298, 0.21132486540518702/)
    shape_n(2, :) = (/0.21132486540518702, 0.78867513459481298/)
    dshape_n(1, :, 1) = (/-1, -1/)
! values of derivatives of basis functions at quad points
    dshape_n(2, :, 1) = (/1, 1/)
! step size
    h = x(ele_nodes(2)) - x(ele_nodes(1))
! transform_to_physical
    dshape_n = 1.0/h*dshape_n
    detwei = (/0.5, 0.5/)*h
! Replacement matmul
    DO i=1,2
      u_at_quad(i) = SUM(u(ele_nodes)*shape_n(:, i))
    END DO
    DO i=1,2
      DO j=1,2
! Replacement dot_product
        a(i, j) = SUM(shape_n(i, :)*(dshape_n(j, :, 1)*u_at_quad)*detwei&
&          )
      END DO
    END DO
! Enforce dirichlet BCs
    IF (ele_nodes(1) .EQ. 1) a(1, :) = (/1.0, 0.0/)
    result1 = SIZE(x)
    IF (ele_nodes(2) .EQ. result1) a(2, :) = (/0.0, 1.0/)
! Replacement matmul
    DO i=1,2
      result10 = SUM(a(i, :)*c(ele_nodes))
      ac(ele_nodes(i)) = ac(ele_nodes(i)) + result10
    END DO
  END SUBROUTINE ELE_ADVECTION_ACTION
END MODULE SIMPLE_ADVECTION_B
