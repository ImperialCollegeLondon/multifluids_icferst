###
### BL test: no gravity 
### First part - before first *** exit *** statement
### is for scalar variables that will set up the right 
### size of the arrays
###

###
### Option for debugging: if =357, then all print statements will
### be sent to the file flog.dat, otherwise to /dev/null
option_debug   1 

# Problem type: options -2, -1, 0, and 1
problem               1

# Number of phases
nphase                2

# Number of components
ncomp                 0

# total number of elements
totele                20 

# Dimensionality
ndim                  1

# nlev --> controls u_snloc
nlev                  3

# Number of velocity nodes
u_nloc                6

# Number of spatial nodes associated w velocity 
xu_nloc               2

# number of nodes associated with CV
cv_nloc               3

# Number of spatial nodes
x_nloc                3

# Number of pressure nodes
p_nloc                3

# Number of surface nodes associated with CV
cv_snloc              1

# Number of surface nodes associated w velocity
u_snloc              -1

# Number of surface pressure nodes
p_snloc               1

# Number of surface spatial nodes
x_snloc               1

# Total number of surface elements
stotel                2

# Number of coeffs for polynomial representation for EOS
ncoef                10

# Number of coeffs for polynomial representation of permeability/absorption
nuabs_coefs           1

# Option for element type: Velocity mesh
u_ele_type 	      2

# Option for element type: Pressure mesh
p_ele_type            2

# Option for element type: Material mesh
mat_ele_type          1

# Option for element type: CV mesh
cv_ele_type           2

# Option for element type: CV surface mesh
cv_sele_type          1

# Option for element type: Velocity surface mesh
u_sele_type           1

# Total number of time dumps
ntime               160

# Frequency in which files will be output into *.d.* files
ntime_dump           20
 
# Total number of non-linear iterations
nits                  3

# Total number of non-linear iterations - internal loop
nits_internal         1

# noit_dim : dimension of the arrays to be defined in later stage 
# (e.g., Field_error, Field_relax, Field_relax_diag, Field_relax_row
# and Field_relax_number_iterations, with 
# Field = volfra, scalar, velocity, global, pressure, mass_matrix)
noit_dim 5

# Maximum number of non-linear iterations for scalar field (saturation /
# volume fraction (nits_flux_lim_volfra) and composition (nits_flux_lim_comp)
nits_flux_lim_volfra   3 
nits_flux_lim_comp     3

# Option for modified CMC color algorithm(/=0), if <0==>ndpset=cv_nonods 
ndpset                0

# Time-step size
dt                    0.3125e-2

# Reference pressure (not in use)
patmos                0.

# Initial pressure (not in use)
p_ini                 0.

# Initial temperature (or any scalar field, not in use)
t_ini                 0.

# Conservative(1.)/non-conservative(0.) flag for CV discretisation
t_beta                0.

# Conservative(1.)/non-conservative(0.) flag for Volfra discretisation
v_beta                1.

# Time-stepping discretisation parameter
t_theta               0.

# Time-stepping discretisation parameter
v_theta               1.

# Time-stepping discretisation parameter (not in use)
u_theta               1.

# Disopt: discretisation option in space and time (see cv-adv-dif.f90)
# = 8: Finite elements in space (Theta = specified;  Limiting: Downwind+)
t_disopt              1

# Disopt: discretisation option in space and time (see cv-adv-dif.f90)
# = 0: 1st order in space (Theta=specified;  Limiting: universal)
u_disopt              1

# Disopt: discretisation option in space and time (see cv-adv-dif.f90)
# = 0: 1st order in space (Theta=specified;  Limiting: universal) - in
# cv-adv-dif.F90, v_disopt --> cv_disopt
v_disopt              8

#  t_dg_vel_int_opt: interface scalar field calculation option between elements
t_dg_vel_int_opt      0

#  u_dg_vel_int_opt: interface velocity calculation option between elements
u_dg_vel_int_opt      4

#  v_dg_vel_int_opt: interface velocity calculation option between elements
v_dg_vel_int_opt      4

#  w_dg_vel_int_opt: interface velocity calculation option between elements
w_dg_vel_int_opt      0

# Lump_eqns: Lump multiphase flow equations
lump_eqns             F

# For compositional - work out theta-hat for flux
volfra_get_theta_flux        T
volfra_use_theta_flux        F

# Domain length
domain_length         4.

# Capillary pressure option (for now we just have option = 1)
capil_pres_opt        0

# Polynomial representation for the cappilary pressure - order (length of the matrix)
ncapil_pres_coef      0

###
### end of scalars variables necessary for the arrays read after
###
exit    10
 
#############################################################################################
# To assign variables via external Fortran functions: 
# If value < -1000, then a pre-defined function may be used, i.e., it is necessary
#                   to assign the corrected dimension to each array, matrix or 
#                   tensor IN the external function
# If value == -1000 then a pre-defined function for ARRAYS (thus not necessary 
#                   to assign dimension to the array as it will be taken automatically from 
#                   Multiphase_Prototype.F90)
# If value == -999 then a pre-defined function for 2x2 MATRIX (thus not necessary 
#                   to assign dimension to the array as it will be taken automatically from 
#                   Multiphase_Prototype.F90)
# If value == -998 then a pre-defined function for 3x3 MATRIX (thus not necessary 
#                   to assign dimension to the array as it will be taken automatically from 
#                   Multiphase_Prototype.F90)
# If value == -997 then a pre-defined function for 4x4 MATRIX (thus not necessary 
#                   to assign dimension to the array as it will be taken automatically from 
#                   Multiphase_Prototype.F90)
#############################################################################################
 
 
###
###  Boundary conditions parameters
###  
 
# wic_vol_bc( stotel * nphase )
wic_vol_bc   -1000 input_wic_vol_bc_BL1_fcn
 
# wic_d_bc( stotel * nphase )
wic_d_bc    -1000 input_wic_d_bc_BL1_fcn
 
# wic_u_bc( stotel * nphase )
wic_u_bc    -1000 input_wic_vol_bc_BL1_fcn
 
# wic_p_bc( stotel * nphase )
wic_p_bc    -1000 input_wic_p_bc_BL1_fcn
 
# wic_t_bc( stotel * nphase )
wic_t_bc  0   
 
# suf_vol_bc( stotel * cv_snloc * nphase )
suf_vol_bc   -1000  input_suf_vol_bc_BL1_fcn
 
# suf_d_bc( stotel * cv_snloc * nphase )
suf_d_bc    -1000  input_suf_vol_bc_BL1_fcn
 
# suf_cpd_bc( stotel * cv_snloc * nphase )
suf_cpd_bc    0.
 
# suf_t_bc( stotel * cv_snloc * nphase )
suf_t_bc   -1000 input_suf_t_bc_BL1_fcn
 
# suf_p_bc ( stotel * p_snloc * nphase )
suf_p_bc       0.
 
# suf_u_bc( stotel * u_snloc * nphase )
suf_u_bc      -1000  input_suf_vol_bc_BL1_fcn
 
# suf_v_bc( stotel * u_snloc * nphase )
suf_v_bc       0.
  
# suf_w_bc( stotel * u_snloc * nphase )
suf_w_bc       0.
  
# suf_one_bc( stotel * cv_snloc * nphase )
suf_one_bc    0.

# suf_u_bc_rob1( stotel * u_snloc * nphase )
suf_u_bc_rob1  0.
 
# suf_u_bc_rob2( stotel * u_snloc * nphase )
suf_u_bc_rob2  0.
 
# suf_v_bc_rob1( stotel * u_snloc * nphase )
suf_v_bc_rob1  0.
 
# suf_v_bc_rob2( stotel * u_snloc * nphase )
suf_v_bc_rob2  0.
 
# suf_w_bc_rob1( stotel * u_snloc * nphase )
suf_w_bc_rob1  0.
 
# suf_w_bc_rob2( stotel * u_snloc * nphase )
suf_w_bc_rob2  0.
 
# suf_t_bc_rob1( stotel * cv_snloc * nphase )
suf_t_bc_rob1  0.
  
# suf_t_bc_rob2( stotel * cv_snloc * nphase )
suf_t_bc_rob2  0.
  

###
### Some solvers options -- scalars to be allocated as real arrays 
### sat_error_relax2_noit, t_error_relax2_noit, gl_error_relax2_noit,
### u_error_relax2_noit, p_error_relax2_noit and mass_error_relax2_noit
### with length noit_dim. 
### All components of the arrays need to be defined as there is NO default
### value. Components are:
### (a) Field_error: error associated with Field interations;
### (b) Field_relax: overall relaxation coefficient associated with Field interations;
### (c) Field_relax_diag: relaxation coefficient for the diagonal matrix associated with Field interations;
### (d) Field_relax_row: relaxation coefficient for the sum of the row of the matrix associated with Field interations;
### (e) Field_relax_number_iterations: maximum number of linear iterations associated with Field interations; 
### Field: volfra, scalar, velocity, global, pressure, mass_matrix
###

# For Volfra (i.e., saturation):
volfra_error                      1.e-10
volfra_relax                      1.
volfra_relax_diag                 0.
volfra_relax_row                  1.
volfra_relax_number_iterations    200

# For Scalar (i.e., T):
scalar_error                      1.e-10
scalar_relax                      1.
scalar_relax_diag                 0.
scalar_relax_row                  1.
scalar_relax_number_iterations    400

# For Global:
global_error                      1.e-10
global_relax                      1.
global_relax_diag                 0.
global_relax_row                  1.
global_relax_number_iterations    200

# For Velocity:
velocity_error                      1.e-10
velocity_relax                      1.
velocity_relax_diag                 0.
velocity_relax_row                  1.
velocity_relax_number_iterations    200

# For Pressure:
pressure_error                      1.e-10
pressure_relax                      1.
pressure_relax_diag                 0.
pressure_relax_row                  1.
pressure_relax_number_iterations    8000

# For Mass Matrix:
mass_matrix_error                      1.e-10
mass_matrix_relax                      1.
mass_matrix_relax_diag                 0.
mass_matrix_relax_row                  1.
mass_matrix_relax_number_iterations    200

###
### Options for upwind discretisation scheme:
### in_ele_upwind: coefficient for upwind inside the element
### dg_ele_upwind: coefficient for upwind between elements
### = 1: full upwind; = 2: 80% upwind; = 3: optimal;
### = 4: central difference (more diffusive)
###
in_ele_upwind    3
dg_ele_upwind    3

###
### Spatial, grid and velocity parameters
###
# x( x_nonods )
x    0.
 
# y( x_nonods )
y    0.
 
# z( x_nonods )
z    0.
 
# xu( xu_nonods )
xu    0.
 
# yu( xu_nonods )
yu    0.
 
# zu( xu_nonods )
zu    0.
 
# nu( u_nonods * nphase )
nu    1.
 
# nv( u_nonods * nphase )
nv    0.
 
# nw( u_nonods * nphase )
nw    0.
 
# ug( u_nonods * nphase )
ug    0.
 
# vg( u_nonods * nphase )
vg    0.
 
# wg( u_nonods * nphase )
wg    0.
 
# u ( u_pha_nonods )
u    0.
 
# v ( u_pha_nonods )
v    0.
 
# w ( u_pha_nonods )
w     0.
 
###
### Absorption and Source terms (include options for 
### permeabilities)
###
 
# uabs_option( nphase )
uabs_option  3
 
# uabs_coefs( nphase, nuabs_coefs )
uabs_coefs   1.
 
# u_abs_stab ( mat_nonods, ndim * nphase, ndim * nphase )
u_abs_stab    0.
 
# u_absorb ( mat_nonods, ndim * nphase, ndim * nphase )
u_absorb   0.
 
# t_absorb ( cv_pha_nonods, nphase, nphase )
t_absorb    0.
 
# v_absorb ( cv_pha_nonods, nphase, nphase )
v_absorb  0.
 
# u_source( u_pha_nonods )
u_source  0.
#u_source  -1000 input_usource_BL1_func
 
# t_source( cv_pha_nonods )
t_source   0.
 
# v_source( cv_pha_nonods )
v_source   0.

# perm ( totele, ndim, ndim )
perm      -998   input_perm_BL1_func

# Mobility
Mobility   10.

# Viscosity ( cv_nonods * nphase )
Viscosity   1. 
###
### Diffusion terms
###
 
#  udiffusion( mat_nonods, ndim, ndim, nphase )
udiffusion   0.
 
#  tdiffusion( mat_nonods, ndim, ndim, nphase )
tdiffusion   0.
 
###
### Scalar fields and pressures
###

# satura ( cv_pha_nonods )
satura   -1000  input_satura_BL1_func
 
# volfra ( cv_pha_nonods )
volfra    0.
 
# t ( cv_pha_nonods )
t    0.
 
# cv_one( cv_pha_nonods )
cv_one    0.
 
# p ( cv_nonods )
p     0.
 
# cv_p (cv_nonods )
cv_p    0.

# Capillary pressure coefficients (for the polynomial representation)
capil_pres_coef     0
 
###
### Densities, Equations of State and Compositional parameterisations
###

# den ( cv_pha_nonods )
den    1.
 
# volfra_pore ( totele )
volfra_pore   .5

# eos_option( nphase )
eos_option   2
 
# eos_coefs( nphase, ncoef )
eos_coefs   -999  input_eos_coef_BL1_func
 
# cp_option( nphase )
cp_option   0

# cp_coefs( nphase, ncp_coefs )
cp_coefs   1.
 
# end of the input file
exit  10

 
