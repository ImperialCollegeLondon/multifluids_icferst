<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="adaptivity_preprocessing">
    <optional>
      <element name="preprocessing">
        <a:documentation>Occasionally, it is desirable to apply operations or filters
to fields before using them for the purposes of adaptivity.</a:documentation>
        <element name="helmholtz_smoother">
          <a:documentation>Invert a helmholtz operator to smooth out the field
before using it to adapt. This can help with noisy
fields.</a:documentation>
          <element name="smoothing_length_scale">
            <ref name="real_dim_symmetric_tensor"/>
          </element>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_prognostic_scalar_field">
    <optional>
      <element name="adaptivity_options">
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation 
error in the units of the field that is 
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
            <optional>
              <element name="p_norm">
                <a:documentation>By default the interpolation error controlled is the L_inf
norm. Use this option to specify an alternative L_p norm. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real"/>
            </element>
          </element>
          <element name="anisotropic_zienkiewicz_zhu">
            <a:documentation>Adapt using the anisotropic strategy of 
Formaggia, Perotto, Micheletti.
Rather than taking two derivatives
and deriving the anisotropic information,
this approach computes an anisotropic Zienkiewicz-Zhu
error estimator for each element. The approach then
optimises the element orientation and length scales
to equidistribute the estimated error.</a:documentation>
            <element name="tau">
              <a:documentation>Tau is an anisotropic estimate for the H1 seminorm of the
error. This estimator is efficient and reliable, under the
caveat that the initial mesh is sufficiently fine so as to
prevent data oscillation. (Micheletti &amp; Perotto, 2006)
Typically, tau will be ~= 6-8 * |e|_H1.</a:documentation>
              <ref name="real"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_scalar_field.adaptivity_options">
    <choice>
      <element name="absolute_measure">
        <a:documentation>When specifying absolute measure
one specifies the absolute interpolation 
error in the units of the field that is 
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>InterpolationErrorBound</value>
          </attribute>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
        </element>
        <optional>
          <element name="p_norm">
            <a:documentation>By default the interpolation error controlled is the L_inf
norm. Use this option to specify an alternative L_p norm. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
      </element>
      <element name="relative_measure">
        <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>InterpolationErrorBound</value>
          </attribute>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
        </element>
        <element name="tolerance">
          <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="anisotropic_zienkiewicz_zhu">
        <a:documentation>Adapt using the anisotropic strategy of 
Formaggia, Perotto, Micheletti.
Rather than taking two derivatives
and deriving the anisotropic information,
this approach computes an anisotropic Zienkiewicz-Zhu
error estimator for each element. The approach then
optimises the element orientation and length scales
to equidistribute the estimated error.</a:documentation>
        <element name="tau">
          <a:documentation>Tau is an anisotropic estimate for the H1 seminorm of the
error. This estimator is efficient and reliable, under the
caveat that the initial mesh is sufficiently fine so as to
prevent data oscillation. (Micheletti &amp; Perotto, 2006)
Typically, tau will be ~= 6-8 * |e|_H1.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
    </choice>
  </define>
  <define name="adaptivity_options_scalar_field">
    <optional>
      <element name="adaptivity_options">
        <ref name="adaptivity_options_scalar_field.adaptivity_options"/>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_prognostic_vector_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation 
error in the units of the field that is 
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <optional>
              <element name="p_norm">
                <a:documentation>By default the interpolation error controlled is the L_inf
norm. Use this option to specify an alternative L_p norm. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_vector_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation 
error in the units of the field that is 
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <optional>
              <element name="p_norm">
                <a:documentation>By default the interpolation error controlled is the L_inf
norm. Use this option to specify an alternative L_p norm. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_prognostic_tensor_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation 
error in the units of the field that is 
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <optional>
              <element name="p_norm">
                <a:documentation>By default the interpolation error controlled is the L_inf
norm. Use this option to specify an alternative L_p norm. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_tensor"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_tensor_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <a:documentation>When specifying absolute measure
one specifies the absolute interpolation 
error in the units of the field that is 
being adapted, e.g. you can specify
the error to be 1.3 units </a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <optional>
              <element name="p_norm">
                <a:documentation>By default the interpolation error controlled is the L_inf
norm. Use this option to specify an alternative L_p norm. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
          <element name="relative_measure">
            <a:documentation>When specifying relative measure
one specifies the interpolation error
relative to the field that is
being adapted, e.g. you can specify
the error to be 5% (i.e. 0.05)</a:documentation>
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and
psi_min is the tolerance. The tolerance prevents
division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_tensor"/>
            </element>
          </element>
        </choice>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="hr_adaptivity">
    <element name="hr_adaptivity">
      <a:documentation>Anisotropic mesh hr-adaptivity</a:documentation>
      <choice>
        <element name="period_in_timesteps">
          <a:documentation>Adapt period in timesteps.</a:documentation>
          <ref name="integer"/>
        </element>
        <element name="adapt_mesh_within_FPI">
          <a:documentation>This option enables the ability to adapt the mesh based on an accumulated shock-front Courant number.
The mesh will adapt within the non-linear solver to always ensure the optimal position of 
the mesh idependently of the Courant number. The only exception is at the end of first time-step 
that it always adapt the mesh.

To adapt the mesh always introduce a negative value.

It only works for porous media and requires adapting the mesh for PhaseVolumeFraction
but not to the last phase.</a:documentation>
          <ref name="real"/>
        </element>
      </choice>
      <optional>
        <element name="t_adapt_delay">
          <a:documentation>Delay start of adaptive algorithm until this time</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <element name="maximum_number_of_nodes">
        <a:documentation>The maximum number of nodes this simulation may use.
In parallel, by default, this is the global maximum number of nodes.

If the mesh adaptivity algorithm wants to place more
nodes than this, the desired mesh is coarsened
everywhere in space until it will fit within this limit.
In general, the error tolerances should be set so that
this is never reached; it should only be a safety catch.
A typical value is 100000.

When using vertically_structured_adaptivity this indicates the 
maximum number of nodes in the horizontal mesh, i.e. the number
of nodes in the full mesh will be much bigger and depends on the 
number of layers specified, or if using inhomogenous_vertical_resolution
on the resolution produced by the vertical adaptivity step.</a:documentation>
        <ref name="integer"/>
      </element>
      <ref name="gradation_options_full"/>
      <element name="tensor_field">
        <a:documentation>Mesh size constraints: the minimum edge length bound.</a:documentation>
        <attribute name="name">
          <value>MinimumEdgeLengths</value>
        </attribute>
        <oneOrMore>
          <choice>
            <element name="anisotropic_symmetric">
              <ref name="input_choice_real_dim_symmetric_tensor"/>
            </element>
            <element name="value">
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <optional>
                <ref name="region_ids"/>
              </optional>
              <element name="anisotropic_symmetric">
                <ref name="input_choice_real_dim_symmetric_tensor"/>
              </element>
            </element>
          </choice>
        </oneOrMore>
      </element>
      <element name="tensor_field">
        <a:documentation>Mesh size constraints: the maximum edge length bound.</a:documentation>
        <attribute name="name">
          <value>MaximumEdgeLengths</value>
        </attribute>
        <oneOrMore>
          <choice>
            <element name="anisotropic_symmetric">
              <ref name="input_choice_real_dim_symmetric_tensor"/>
            </element>
            <element name="value">
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <optional>
                <ref name="region_ids"/>
              </optional>
              <element name="anisotropic_symmetric">
                <ref name="input_choice_real_dim_symmetric_tensor"/>
              </element>
            </element>
          </choice>
        </oneOrMore>
      </element>
      <optional>
        <element name="aspect_ratio_bound">
          <a:documentation>Maximum aspect ratio in the adapted mesh.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="adapt_at_first_timestep">
          <a:documentation>Adapt at first timestep</a:documentation>
          <element name="number_of_adapts">
            <a:documentation>Number of adapts done after initialisation but
before the actual simulation starts</a:documentation>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="output_adapted_mesh">
              <a:documentation>Write out the first timestep adapted mesh.
This is useful when needing to re-run simulations
without waiting for the first timestep adapt</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </define>
  <define name="consistent_interpolation">
    <element name="consistent_interpolation">
      <a:documentation>Basis function interpolation.
The standard algorithm. It is quick
and bounded, but non-conservative and dissipative.
All other algorithms require construction of a supermesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="grandy_interpolation">
    <element name="grandy_interpolation">
      <a:documentation>Grandy interpolation. Conservative, but highly diffusive.
See doi:10.1006/jcph.1998.6125 .</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="CVgalerkin_interpolation">
    <element name="CVgalerkin_interpolation">
      <a:documentation>Galerkin interpolation for control volume fields. Conservative
and higher order. Not yet tested in parallel.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="interpolation_algorithm_disabled">
    <element name="no_interpolation">
      <a:documentation>Disable interpolation</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="interpolation_algorithm_scalar">
    <choice>
      <ref name="consistent_interpolation"/>
      <ref name="pseudo_consistent_interpolation"/>
      <ref name="CVgalerkin_interpolation"/>
      <element name="galerkin_projection">
        <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
        <ref name="galerkin_projection_scalar"/>
      </element>
      <ref name="grandy_interpolation"/>
    </choice>
  </define>
  <define name="interpolation_algorithm_scalar_full">
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <define name="interpolation_algorithm_scalar_full" combine="choice">
    <ref name="interpolation_algorithm_disabled"/>
  </define>
  <define name="interpolation_algorithm_vector_full">
    <ref name="interpolation_algorithm_vector"/>
  </define>
  <define name="interpolation_algorithm_vector_full" combine="choice">
    <ref name="interpolation_algorithm_disabled"/>
  </define>
  <define name="interpolation_algorithm_vector">
    <choice>
      <ref name="consistent_interpolation"/>
      <ref name="pseudo_consistent_interpolation"/>
      <element name="galerkin_projection">
        <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
        <ref name="galerkin_projection_vector"/>
      </element>
      <ref name="grandy_interpolation"/>
      <element name="geostrophic_interpolation">
        <a:documentation>Helmholtz decomposed projection of the Coriolis acceleration. Suitable
only for Velocity fields. This interpolation happens in three stages:

  1. Computation of Coriolis and its Helmholtz decomposition
  2. Interpolation of the Helmholtz decomposition
  3. Formation of Coriolis from the decomposition and inversion for velocity

Notes for balance preserving interpolants:

The spatial discretisation options for the conservative potential
must match those used for Pressure.

With weak boundary conditions for the conservative potential, if
no-normal-flow is satisfied on the boundary this must be preserved by
the interpolation. For 2D domains this can be achieved by using
consistent interpolation for the conservative potential or, for more
general interpolants, by performing a further decomposition of the
conservative potential (see
geostrophic_interpolation/conservative_potential/decompose).

For shallow-water modelling the interpolants for layer thickness and
the conservative potential must be identical and degree one
homogenenous (see
geostrophic_interpolation/conservative_potential/project_pressure/scale_factor).</a:documentation>
        <element name="coriolis">
          <a:documentation>Options relating to the Coriolis acceleration</a:documentation>
          <optional>
            <choice>
              <element name="mesh">
                <a:documentation>The mesh used for the Coriolis acceleration. Defaults to the
Velocity mesh if not supplied.</a:documentation>
                <attribute name="name">
                  <value>VelocityMesh</value>
                </attribute>
              </element>
              <element name="mesh">
                <a:documentation>The mesh used for the Coriolis acceleration. Defaults to the
Velocity mesh if not supplied.</a:documentation>
                <attribute name="name">
                  <value>PressureMesh</value>
                </attribute>
              </element>
              <element name="mesh">
                <a:documentation>The mesh used for the Coriolis acceleration. Defaults to the
Velocity mesh if not supplied.</a:documentation>
                <attribute name="name">
                  <value>CoordinateMesh</value>
                </attribute>
              </element>
              <element name="mesh">
                <a:documentation>The mesh used for the Coriolis acceleration. Defaults to the
Velocity mesh if not supplied.</a:documentation>
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
              </element>
            </choice>
          </optional>
          <element name="velocity_to_coriolis">
            <a:documentation>Options relating to the diagnostic solve for the Coriolis
acceleration from Velocity on the donor mesh.</a:documentation>
            <optional>
              <ref name="galerkin_projection_mass_options"/>
            </optional>
            <optional>
              <element name="lump_rhs">
                <a:documentation>Lump the RHS term. Requires Velocity and the Coriolis 
acceleration to be on the same mesh.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
          <element name="coriolis_to_velocity">
            <a:documentation>Options relating to the diagnostic solve for Velocity from
the Coriolis acceleration on the target mesh.</a:documentation>
            <optional>
              <ref name="galerkin_projection_mass_options"/>
            </optional>
            <optional>
              <element name="lump_rhs">
                <a:documentation>Lump the RHS term. Requires Velocity and the Coriolis 
acceleration to be on the same mesh.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
          <ref name="comment"/>
        </element>
        <element name="conservative_potential">
          <a:documentation>Options relating to the conservative potential component of the
Helmholtz decomposition</a:documentation>
          <choice>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <value>PressureMesh</value>
              </attribute>
            </element>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
          </choice>
          <element name="spatial_discretisation">
            <a:documentation>Spatial discretisation options</a:documentation>
            <element name="mass">
              <a:documentation>Options relating to the mass matrix</a:documentation>
              <optional>
                <element name="lump_mass">
                  <a:documentation>Lump the mass matrix. Required for continuous fields.</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
            </element>
            <element name="continuous_galerkin">
              <a:documentation>Use a continuous Galerkin discretisation</a:documentation>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
          <optional>
            <element name="reference_node">
              <a:documentation>Reference node, at which the solution value is pinned to zero</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
          <element name="solver">
            <a:documentation>Solver options for the conservative potential calculation</a:documentation>
            <ref name="linear_solver_options_sym"/>
          </element>
          <choice>
            <element name="galerkin_projection">
              <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
              <ref name="galerkin_projection_honour_strong_bcs"/>
              <ref name="continuous_projection"/>
              <optional>
                <ref name="supermesh_conservation"/>
              </optional>
              <ref name="comment"/>
            </element>
            <ref name="consistent_interpolation"/>
            <ref name="grandy_interpolation"/>
          </choice>
          <optional>
            <choice>
              <element name="project_pressure">
                <a:documentation>Supply a Pressure field. This enables better initial guesses for
the decomposition solvers, and also allows decomposed interpolants
for Pressure (see
geostrophic_interpolation/conservative_potential/decompose and
geostrophic_interpolation/conservative_potential/interpolate_boundary).</a:documentation>
                <attribute name="name">
                  <value>Pressure</value>
                </attribute>
                <optional>
                  <ref name="geostrophic_interpolation_project_pressure_scale_factor"/>
                </optional>
                <ref name="comment"/>
              </element>
              <element name="project_pressure">
                <a:documentation>Supply a Pressure field. This enables better initial guesses for
the decomposition solvers, and also allows decomposed interpolants
for Pressure (see
geostrophic_interpolation/conservative_potential/decompose and
geostrophic_interpolation/conservative_potential/interpolate_boundary).</a:documentation>
                <attribute name="name">
                  <value>LayerThickness</value>
                </attribute>
                <ref name="geostrophic_interpolation_project_pressure_scale_factor"/>
                <ref name="comment"/>
              </element>
              <element name="project_pressure">
                <a:documentation>Supply a Pressure field. This enables better initial guesses for
the decomposition solvers, and also allows decomposed interpolants
for Pressure (see
geostrophic_interpolation/conservative_potential/decompose and
geostrophic_interpolation/conservative_potential/interpolate_boundary).</a:documentation>
                <attribute name="name">
                  <data type="string"/>
                </attribute>
                <optional>
                  <ref name="geostrophic_interpolation_project_pressure_scale_factor"/>
                </optional>
                <ref name="comment"/>
              </element>
            </choice>
          </optional>
          <optional>
            <choice>
              <element name="decompose">
                <a:documentation>Decompose the conservative potential into a component constant
on the boundary, and a residual.

If interpolating Pressure, a similar decomposition is applied
to the Pressure projection.

This requires the domain to be 2D and simply connected.</a:documentation>
                <choice>
                  <element name="l2_minimised_residual">
                    <a:documentation>Choose a boundary value that minimises the l2 norm of the
residual</a:documentation>
                    <ref name="comment"/>
                  </element>
                  <element name="boundary_mean">
                    <a:documentation>Use the mean boundary value</a:documentation>
                    <ref name="comment"/>
                  </element>
                </choice>
                <element name="solver">
                  <a:documentation>Solver options for the decomposition</a:documentation>
                  <ref name="linear_solver_options_sym"/>
                </element>
                <ref name="comment"/>
              </element>
              <element name="interpolate_boundary">
                <a:documentation>Interpolate the boundary values using consistent interpolation and
use these as a strong Dirichlet boundary condition on the
conservative potential.

If interpolating Pressure, a similar boundary condition is applied
to the Pressure projection.</a:documentation>
                <ref name="comment"/>
              </element>
            </choice>
          </optional>
          <ref name="comment"/>
        </element>
        <element name="residual">
          <a:documentation>Options relating to the non-conservative residual component of the
Helmholz decomposition</a:documentation>
          <choice>
            <element name="galerkin_projection">
              <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
              <ref name="continuous_discontinuous_projection"/>
              <optional>
                <ref name="supermesh_conservation"/>
              </optional>
              <ref name="comment"/>
            </element>
            <ref name="consistent_interpolation"/>
            <ref name="pseudo_consistent_interpolation"/>
            <ref name="grandy_interpolation"/>
          </choice>
          <optional>
            <element name="enforce_solenoidal">
              <a:documentation>Enforce divergence free after the projection</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
        <optional>
          <element name="geopressure">
            <a:documentation>If enabled, preconditions the Helmholtz decomposition by solving
for the conservative potential using a geopressure solver. The
projection equation then becomes:
  M f = M f_* + C \phi + C_{gp} \phi_{gp},
where f_* is the coriolis acceleration, f is divergence free, phi is
the conservative potential, phi_gp is the geopressure conservative
potential and:
  C_{gp,ij}^q = \int_Omega N_j \partial_q M_i,
is the geopressure gradient matrix, where N_i are the velocity shape
functions and M_i the geopressure conservative potential shape
functions.</a:documentation>
            <element name="mesh">
              <a:documentation>The mesh used for the geopressure conservative potential</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
            <optional>
              <element name="reference_node">
                <a:documentation>Reference node, at which the solution value is pinned to zero</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
            <element name="solver">
              <a:documentation>Solver options for the geopressure conservative potential
calculation</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <choice>
              <element name="galerkin_projection">
                <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
                <ref name="continuous_projection"/>
                <optional>
                  <ref name="supermesh_conservation"/>
                </optional>
                <ref name="comment"/>
              </element>
              <ref name="consistent_interpolation"/>
              <ref name="pseudo_consistent_interpolation"/>
              <ref name="grandy_interpolation"/>
            </choice>
          </element>
        </optional>
        <optional>
          <element name="vertical_velocity">
            <a:documentation>Options relating to the vertical velocity. Required in 3D.</a:documentation>
            <choice>
              <element name="galerkin_projection">
                <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
                <ref name="continuous_discontinuous_projection"/>
                <optional>
                  <ref name="supermesh_conservation"/>
                </optional>
                <ref name="comment"/>
              </element>
              <ref name="consistent_interpolation"/>
              <ref name="pseudo_consistent_interpolation"/>
              <ref name="grandy_interpolation"/>
            </choice>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="debug">
            <a:documentation>Debug options</a:documentation>
            <optional>
              <element name="write_debug_vtus">
                <a:documentation>If enabled, pre and post interpolation decomposition vtus are
written</a:documentation>
                <optional>
                  <element name="max_vtu_count">
                    <a:documentation>Maximum number of debug vtus that will be written before
over-writing existing vtus</a:documentation>
                    <ref name="integer"/>
                  </element>
                </optional>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="geostrophic_interpolation_project_pressure_scale_factor">
    <element name="scale_factor">
      <a:documentation>Scale the pressure field by some factor before interpolation,
and apply the inverse after interpolation. This should be set
if the pressure field is divided by some reference value
e.g., in a shallow water with gravity magnitude g, this should
take the value g. This enables better initial guesses for the
decomposition solvers, and means that non degree one
homonogeneous interpolants can be used for the conservative
potential and pressure, while still being balance preserving.</a:documentation>
      <ref name="real"/>
    </element>
  </define>
  <define name="galerkin_projection_honour_strong_bcs">
    <element name="honour_strong_boundary_conditions">
      <a:documentation>Honour strong Dirichlet boundary conditions in the Galerkin projection</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="galerkin_projection_vector">
    <ref name="continuous_discontinuous_projection"/>
    <optional>
      <ref name="supermesh_free"/>
    </optional>
    <optional>
      <ref name="supermesh_conservation"/>
    </optional>
    <optional>
      <ref name="galerkin_projection_honour_strong_bcs"/>
    </optional>
  </define>
  <define name="galerkin_projection_scalar">
    <ref name="continuous_discontinuous_projection"/>
    <optional>
      <ref name="supermesh_free"/>
    </optional>
    <optional>
      <ref name="supermesh_conservation"/>
    </optional>
    <optional>
      <ref name="galerkin_projection_honour_strong_bcs"/>
    </optional>
  </define>
  <define name="continuous_projection">
    <element name="continuous">
      <a:documentation>Continuous field Galerkin projection.
If the field you are interpolating is continuous, then
a linear solver is required to invert the mass matrix.</a:documentation>
      <optional>
        <choice>
          <element name="bounded">
            <a:documentation>Use a bounded Galerkin projection. Conservative, bounded in the
limit, and minimally dissipative. This algorithm starts with the
Galerkin projection and dissipates it until it achieves
boundedness.
If it does not converge, it may not be exactly bounded.
Note well: this only works for linear fields.</a:documentation>
            <attribute name="name">
              <value>Diffuse</value>
            </attribute>
            <element name="boundedness_iterations">
              <a:documentation>The number of dissipation iterations attempted to bound the
Galerkin projection.</a:documentation>
              <ref name="integer"/>
              <optional>
                <element name="tolerance">
                  <a:documentation>Specify the tolerance to which boundedness is to be tested during the iterations.
Defaults to computer precision if unspecified.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <optional>
              <element name="bounds">
                <a:documentation>If the bounds on this field are known then they can be set here.
These can either further constrain the limits worked out by the
lumped version of the projection (i.e. to make sure that errors 
don't accumulate with succesive interpolations) or if apply_globally
is set they are just made to be bounded within the bounds globally
(i.e. anything between those bounds is not smoothed).</a:documentation>
                <optional>
                  <element name="upper_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="coupled">
                        <a:documentation>This field is to be considered as being coupled to another field
such that the sum of the two fields is constrained to be less than
the upper_bound specified above.

The relationships between fields are worked out according to their
priority ordering.

This method is akin to the coupled_cv advection method.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <optional>
                  <element name="lower_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="repair_deviations">
                <a:documentation>If, after performing all the boundedness_iterations, the field
is still not bounded then perform surgery to redistribute the
deviations to nodes that have less than their bounds.</a:documentation>
                <optional>
                  <element name="tolerance">
                    <a:documentation>Specify the tolerance to which boundedness is to be tested during the repair.
Defaults to computer precision if unspecified.</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
            </optional>
          </element>
          <element name="bounded">
            <a:documentation>Use a bounded Galerkin projection. Conservative, bounded in the
limit, and hopefully minimally dissipative. This algorithm starts with the
Galerkin projection and uses the optimisation library Algencan to bound
it by minimising a functional within constraints on boundedness and conservation.
Note well: this only works for linear fields.</a:documentation>
            <attribute name="name">
              <value>Algencan</value>
            </attribute>
            <choice>
              <element name="functional">
                <attribute name="name">
                  <value>L2</value>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="functional">
                <attribute name="name">
                  <value>LumpedMassL2</value>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="functional">
                <attribute name="name">
                  <value>IntegralL2</value>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="functional">
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
            </choice>
            <optional>
              <element name="bounds">
                <a:documentation>If the bounds on this field are known then they can be set here.
These can either further constrain the limits worked out by the
lumped version of the projection (i.e. to make sure that errors 
don't accumulate with succesive interpolations) or if apply_globally
is set they are just made to be bounded within the bounds globally
(i.e. anything between those bounds is not smoothed).</a:documentation>
                <optional>
                  <element name="upper_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="coupled">
                        <a:documentation>This field is to be considered as being coupled to another field
such that the sum of the two fields is constrained to be less than
the upper_bound specified above.

The relationships between fields are worked out according to their
priority ordering.

This method is akin to the coupled_cv advection method.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <optional>
                  <element name="lower_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </optional>
          </element>
        </choice>
      </optional>
      <choice>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a mass matrix. Note that
conservation properties are affected by the tolerance of the
linear solve.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
        <element name="lump_mass_matrix">
          <a:documentation>Lump the mass matrix on the left hand side of the galerkin projection.
Hence solver options aren't necessary.

This is much more diffusive than a non-lumped Galerkin projection
for only a minimal saving in computational cost.</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
  <define name="continuous_discontinuous_projection">
    <choice>
      <ref name="continuous_projection"/>
      <element name="discontinuous">
        <a:documentation>Discontinuous field Galerkin projection.
In this case, no linear solver is required to invert the mass matrix.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="supermesh_free">
    <element name="supermesh_free">
      <a:documentation>Enables a supermesh free Galerkin projection. Uses incomplete
quadrature, and hence is not conservative.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="supermesh_conservation">
    <element name="supermesh_conservation">
      <a:documentation>Options for checking the supermesh conservation properties</a:documentation>
      <optional>
        <element name="tolerance">
          <a:documentation>Specify the fraction of the original elemental area/volume
to be used to check the conservation of the supermesh.

Since all fields are supermeshed together the minimum tolerance
specified over all fields will be used.

Defaults to 0.001 if unspecified.
i.e. 0.1% of the area/volume of an element in the new mesh may
be lost without warning or attempts to fix (if compiled with cgal)
during the construction of the supermesh between the old
and new meshes.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="print_field_integral">
          <a:documentation>Compute the field integral after the interpolation and print the relative
mass loss to the logfile (level 2 verbosity).

Note this is a post interpolation step and offers no chance of
fixing the conservation error (unlike the tolerance above if compiled
with cgal)</a:documentation>
          <element name="tolerance">
            <a:documentation>Relative tolerance with which to test the conservation of the field
integral.  If the conservation fails this tolerance a warning is issued
(level 0 verbosity) and vtus containing the field are output.</a:documentation>
            <ref name="real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="mesh_adaptivity_options">
    <element name="mesh_adaptivity">
      <optional>
        <ref name="hr_adaptivity"/>
      </optional>
    </element>
  </define>
  <define name="gradation_options_full">
    <ref name="disable_gradation"/>
  </define>
  <define name="gradation_options_full" combine="choice">
    <ref name="gradation_options"/>
  </define>
  <define name="gradation_options">
    <choice>
      <element name="enable_gradation">
        <a:documentation>Gradation constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.</a:documentation>
        <optional>
          <element name="gradation_parameter">
            <a:documentation>The gradation parameter. Must be a real &gt;= 1.0.

The gradation parameter constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.
A constant of 1.0 enforces a mesh of constant
edge length everywhere. A value of 2.0 would
allow the element size to double from element
to element. The default value is 1.5.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="anisotropic_gradation">
        <a:documentation>Anisotropic gradation algorithm, allowing for
anisotropic bounds on the gradient of the sizing
function.</a:documentation>
        <element name="tensor_field">
          <a:documentation>Gamma is the tensor field that contains
the bounds on the edge length specified by the error metric.</a:documentation>
          <attribute name="name">
            <value>Gamma</value>
          </attribute>
          <element name="anisotropic_symmetric">
            <ref name="input_choice_real_dim_symmetric_tensor"/>
          </element>
        </element>
      </element>
    </choice>
  </define>
  <define name="disable_gradation">
    <element name="disable_gradation">
      <a:documentation>Gradation constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.</a:documentation>
      <empty/>
    </element>
  </define>
</grammar>
