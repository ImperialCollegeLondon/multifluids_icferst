<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options_ICFERST.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers_ICFERST.rng"/>
  <include href="stabilisation.rng"/>
  <include href="mesh_options_ICFERST.rng"/>
  <include href="physical_parameters_ICFERST.rng"/>
  <include href="prognostic_field_options_ICFERST.rng"/>
  <include href="prescribed_field_options.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <start>
    <element name="multiphase_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="is_porous_media">
        <a:documentation>Select the simulation type</a:documentation>
        <empty/>
      </element>
      <ref name="geometry"/>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <element name="dump_boundaryflux">
            <a:documentation>Surface to Integrate Over</a:documentation>
            <empty/>
            <element name="surface_ids">
              <a:documentation>Surface id:</a:documentation>
              <ref name="integer_vector"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value
required. A value of zero indicates that checkpoints
should be created at every dump. If
/io/max_dumpfile_count is exceeded then earlier
checkpoints may be overwritten.</a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_start">
                <a:documentation>Enable to checkpoint at simulation start.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="nonlinear_iterations">
            <a:documentation>maximum number of non-linear iterations.

Manual suggests 2

If using Fixed_Point_Iteration the recommendation is 25</a:documentation>
            <ref name="integer"/>
            <optional>
              <element name="Fixed_Point_Iteration">
                <a:documentation>This is the convergence criterion for the Fixed Point Iteration solver.
The functional to compare is: 

f = L2norm(S*-So)/L2norm(S1-So)

S* is the latest saturation; So is the saturation at the previous FPI
S1 is the saturation after the first FPI. Hence, the reduction of the difference
of saturation is tested

Recommended value: 5e-2</a:documentation>
                <ref name="real"/>
                <optional>
                  <element name="Backtracking_factor">
                    <a:documentation>Recommended settings: Non-linear iterations &gt;= 30
Backtracking_parameter = -10 automatically selection based on the Courant number, the shock-front Courant number and the physics of the problem

The Backtracking value introduced is used as reference, so it may have a big impact on the convergence

Recommended settings: Backtracking_parameter = -0.33 or -0.5 or -0.8; 
Note: Dynamic dumping loops over the Saturation solver up to 9 times and also uses techniques to accelerate the FPI convergence

The more complex the problem is (i.e. bigger time-steps, gravity, capillary, etc) the smaller the value should be</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
                <optional>
                  <element name="adaptive_timestep_nonlinear">
                    <a:documentation>Adaptive timestep based on the number of non-linear iterations performed by the FPI solver.

A Variable to check has to be chosen:
1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (Default)</a:documentation>
                    <ref name="integer"/>
                    <group>
                      <optional>
                        <element name="PID_controller">
                          <a:documentation>Time-step size controlled using a PID approach.
By default this method only controls the errors, and based on that increases or decreases the time-step size.
The default aim of number of FPI is the 20% of the maximum number of non-linear iterations.
The increase_factor and decrease_factor are multiplied by 1.2 to give more flexibility to the PID controller.

If this is off, a classical method based on the number of FPI performed is used instead.</a:documentation>
                          <empty/>
                          <optional>
                            <element name="Aim_num_FPI">
                              <a:documentation>Time-step size is controlled to try to always perform the specified number of FPI introduced
here, but in a soft way so if the other checks are performing correctly it can still increase the time-step size. 
By default this is the 20% of the maximum number of non-linear iterations.</a:documentation>
                              <ref name="integer"/>
                            </element>
                          </optional>
                        </element>
                      </optional>
                      <optional>
                        <element name="ensure_solvers_convergence">
                          <a:documentation>If any of the solvers failt to achieve convergence the time-step size is 
reduced and the time-level repeated without waiting to reach the maximum number of FPI.
Note: For the saturation for porous media it allows to diverge inside the saturation FPI.</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="increase_threshold">
                          <a:documentation>Number of FPI below which the time-step size is increased
by default it is the 25% of the maximum allowed FPIs</a:documentation>
                          <ref name="integer"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="increase_factor">
                          <a:documentation>Multiply present timestep by this factor when increasing it.
By default 1.1</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="decrease_factor">
                          <a:documentation>Multiply present timestep by this factor when decreasing it.
By default 2.0</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="max_timestep">
                          <a:documentation>Maximum timestep. Beyond this value the timestep will not be increased.
By default unlimmited.</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="min_timestep">
                          <a:documentation>Minimum timestep. Beyond this value the timestep will not be decreased.
By default dt*1e-3.</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                    </group>
                  </element>
                </optional>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="adaptive_timestep">
            <a:documentation>Vary the timestep according to the courant number.</a:documentation>
            <element name="requested_cfl">
              <a:documentation>The timestep will be adjusted (within the tolerance
and bounds specified) to target this courant
number. Timestep adapts occur at the end of each
timestep and after a mesh adapt.</a:documentation>
              <ref name="real"/>
            </element>
            <ref name="timestep_cfl_number_options"/>
            <optional>
              <element name="minimum_timestep">
                <a:documentation>Minimum time step size.
Manual suggests 0.0</a:documentation>
                <optional>
                  <element name="terminate_if_reached">
                    <a:documentation>If enabled, signals model termination if a timestep less
than or equal to the minimum_timestep is requested. The
model will stop at the end of the timestep in order to
allow for the latest output to be written. </a:documentation>
                    <ref name="comment"/>
                  </element>
                </optional>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="maximum_timestep">
                <a:documentation>Maximum time step size.
Manual suggests 1.E+10</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="increase_tolerance">
                <a:documentation>The maximum ratio by which the timestep is allowed
to increase in a timestep adapt. e.g., a value of
1.1 indicates that the timestep may be increased by
at most 10%.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="at_first_timestep">
                <a:documentation>Specify whether you want to calculate a new timestep
at the first timestep or not.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <optional>
        <ref name="physical_parameter_options"/>
      </optional>
      <oneOrMore>
        <element name="material_phase">
          <a:documentation>The material or phase options</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <ref name="phase_density">
              <a:documentation>Phase density</a:documentation>
            </ref>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>## Equation of State
equation_of_state?,</a:documentation>
              <a:documentation>Pressure</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_pressure_field"/>
                </element>
                <element name="prescribed">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="diagnostic">
                  <a:documentation>Compute pressure from Density and InternalEnergy
via a compressible equation of state.</a:documentation>
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="internal_algorithm"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Pressure</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_velocity_field"/>
              </element>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="diagnostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
          <optional>
            <element name="multiphase_properties">
              <a:documentation>Parameters required to model multiphase flow</a:documentation>
              <optional>
                <element name="Relperm_Corey">
                  <a:documentation>Option for relperm type in prototype code
Corey relperm:

relperm = relperm_max * ((Sat-S_immobile)/(1-Sum(Immobile_saturations)))^relperm_exponent</a:documentation>
                  <optional>
                    <element name="relperm_max">
                      <a:documentation>Relative permeability end point

Value between 0 and 1. Default value 1.0</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>End-point relative permeability</a:documentation>
                        <attribute name="name">
                          <value>relperm_max</value>
                        </attribute>
                        <element name="prescribed">
                          <ref name="material_mesh_choice"/>
                          <ref name="prescribed_scalar_field"/>
                        </element>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="relperm_exponent">
                      <a:documentation>Relative permeability exponent

Default value 2.0</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Exponent of the formula</a:documentation>
                        <attribute name="name">
                          <value>relperm_exponent</value>
                        </attribute>
                        <element name="prescribed">
                          <ref name="material_mesh_choice"/>
                          <ref name="prescribed_scalar_field"/>
                        </element>
                      </element>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="capillary_pressure">
                  <a:documentation>Option for capillary pressure				 </a:documentation>
                  <optional>
                    <element name="Diffusive_cap_only">
                      <a:documentation>Non-consistent implementation of the capillary pressure, increases the stability of the method and allows bigger time-steps, use only when capillary affects are not dominant. 
The capillary pressure term is introduced only in the saturation equation, acting as a pure diffusive term. </a:documentation>
                      <ref name="comment"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="type_Brooks_Corey">
                      <a:documentation>Brooks-Corey equation

Pc = c * ((S_w-Swir)/(1-Swirr-Sor)) ** -a
You should specify this ONLY for the wetting phase</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Entry pressure of the formula</a:documentation>
                        <attribute name="name">
                          <value>C</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                      <element name="scalar_field">
                        <a:documentation>exponent -a</a:documentation>
                        <attribute name="name">
                          <value>a</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="type_TOTALCapillary">
                      <a:documentation>Implements capillary pressure curve of Jaure et. al (http://dx.doi.org/10.2118/172989-MS)</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Overall coefficient scaling the capillary pressure</a:documentation>
                        <attribute name="name">
                          <value>C</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                      <element name="scalar_field">
                        <a:documentation>Exponent in the capillary pressure formula</a:documentation>
                        <attribute name="name">
                          <value>a</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="immobile_fraction">
                  <a:documentation>Immobile volume of fluid phase</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Immobile fraction</a:documentation>
                    <attribute name="name">
                      <value>value</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="Sat_overRelax">
                  <a:documentation>Introduce over-relaxation in the saturation equation that diminishes as the FPI converges. 
This helps to increase the convergence rate of the FPI solver.
You MUST specify this ONLY for the wetting phase.

If positive, the input value is the entry pressure.

If negative, the input value is Peclet number desired.

Recommended value =&gt; -1e1

Tip: if Diffusive_cap_only is activated Sat_overRelax is ignored.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </oneOrMore>
      <optional>
        <ref name="mesh_adaptivity_options"/>
      </optional>
      <optional>
        <element name="porous_media">
          <a:documentation>Porous Media</a:documentation>
          <element name="scalar_field">
            <a:documentation>Specify scalar field Porosity</a:documentation>
            <attribute name="name">
              <value>Porosity</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <choice>
            <a:documentation>Specify field Permeability</a:documentation>
            <element name="scalar_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="aliased">
                  <ref name="generic_aliased_field"/>
                </element>
              </choice>
            </element>
            <element name="vector_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
            </element>
            <element name="tensor_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_tensor_field"/>
              </element>
            </element>
            <element name="Permeability_from_femdem">
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <element name="background_permeability">
                <ref name="real"/>
              </element>
            </element>
          </choice>
          <optional>
            <element name="well_options">
              <a:documentation>Specify well-related options</a:documentation>
              <optional>
                <element name="calculate_sigma_pipe">
                  <a:documentation>Calculate the well \sigma field internally
using a non-linear friction factor.
This will over-write the field specified in Sigma1.</a:documentation>
                  <optional>
                    <!-- Defaults to 1.0e-6. -->
                    <element name="pipe_roughness">
                      <ref name="real"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="dt_pipe_factor">
                  <a:documentation>Factor by which to reduce the pipe eqns time step size e.g. 10^{-3}</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="switch_wells_on_and_off">
                  <a:documentation>Switches wells on and off to optimise production</a:documentation>
                  <element name="phase_exclude">
                    <ref name="integer"/>
                  </element>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </start>
  <define name="geometry">
    <element name="geometry">
      <a:documentation>Options dealing with the specification of geometry</a:documentation>
      <element name="dimension">
        <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
        <element name="integer_value">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <value>3</value>
            <value>2</value>
            <value>1</value>
          </choice>
        </element>
      </element>
      <element name="mesh">
        <a:documentation>The position mesh</a:documentation>
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <element name="simulation_quality">
        <a:documentation>Selects the quality configuration of the experiment

Fast =&gt; Element pair = P0DGP1CV. Upwinding and implicit Euler; 

Medium (recommended) =&gt; Element pair = P0DGP1CV. Local decision whether upwinding or high order advection scheme and adaptive theta; 

Quality =&gt; Element pair = P1DGP2CV. High order advection scheme and adaptive theta

discontinuous_pressure =&gt; P2DGP1DG. High order advection scheme and adaptive theta</a:documentation>
        <element name="string_value">
          <choice>
            <value>fast</value>
            <value>medium</value>
            <value>quality</value>
            <value>discontinuous_pressure</value>
          </choice>
        </element>
      </element>
    </element>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_tensor_stat_options"/>
    <ref name="adaptivity_options_tensor_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <define name="diagnostic_cv_gradient_vector_field">
    <optional>
      <element name="lump_mass_matrix">
        <a:documentation>Choose whether the mass matrix is lumped or not</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="solver">
        <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Normalise the gradient by its magnitude</a:documentation>
        <empty/>
      </element>
    </optional>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_gradient_vector_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_cv_divergence_scalar_field">
    <!-- No solver options because it can be solved directly! -->
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_fe_divergence_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the normal direction
of the rotation matrix.
If off then fluidity computes the normal
If on the tangents vectors must also be specified.</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>specify first unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>specify second (if exists, i.e. if 3d) unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <choice>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
        <optional>
          <element name="debugging_mode">
            <a:documentation>this will calculate the determinant of the
rotation matrix for every boundary node
and dump a vtu with the node 
normals and tangenials 1/2</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>NOT USED - choose "dirichlet" instead for the cty bcs

This applies a Dirichlet condition through the continuity equation
and thus will only apply a normal component of this specified
velocity as the boundary condition.</a:documentation>
        <attribute name="name">
          <value>dirichlet_continuity</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>This applies a Dirichlet condition through the viscous terms in the
momentum equation. It will be applied to each of the components specified.</a:documentation>
        <attribute name="name">
          <value>dirichlet_viscosity</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>This applies a Dirichlet condition for the advection velocity
of the momentum equation.</a:documentation>
        <attribute name="name">
          <value>dirichlet_advection</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Add a bulk formulae boundary condition. Only makes sense
on the Velocity field.</a:documentation>
        <attribute name="name">
          <value>bulk_formulae</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
        <optional>
          <element name="surface_stabilisation">
            <a:documentation>This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far. 
Note: Once activated, the stabilisation term will occur in all free surface areas in the domain. 
IN DEVELOPMENT</a:documentation>
            <element name="scale_factor">
              <a:documentation>Scale factor for the surface stabilisation.</a:documentation>
              <ref name="real"/>
            </element>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <optional>
              <element name="manning-strickler">
                <a:documentation>Use the Manning-Strickler formulation:
n^2*g*|u|*u/H^(1/3)
where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.

The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density 
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air. 

&lt;b&gt;Note that you have to specify
this density in the same units as the 
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the 
recommended (non-dimensional) value of 1.0 for 
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a penalty function for the near wall region.
Using this option coarse meshes can
be used in the near wall region.

Should be used in combination with a no_normal_flow condition. 

See Bazilevs et al. 2007</a:documentation>
        <attribute name="name">
          <value>near_wall_treatment</value>
        </attribute>
        <element name="tolerance">
          <ref name="real"/>
        </element>
        <optional>
          <element name="Cb">
            <a:documentation>if not set then Cb=2*h, where h is the element size</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Log law of the wall

Should be used in combination with a no_normal_flow condition. </a:documentation>
        <attribute name="name">
          <value>log_law_of_wall</value>
        </attribute>
        <element name="surface_roughness">
          <ref name="real"/>
        </element>
      </element>
      <element name="type">
        <a:documentation>Dummy BC

Should be used in combination with the near_wall_treatment condition.
When activated wall treatment is not applied on the wall-outflow edge.</a:documentation>
        <attribute name="name">
          <value>outflow</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Momentun BC
</a:documentation>
        <attribute name="name">
          <value>momentum</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Momentun BC
</a:documentation>
        <attribute name="name">
          <value>momentuminout</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
    </choice>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_velocity_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_velocity_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Diagnostic statistics for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_velocity_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_velocity_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <optional>
          <element name="output_terms">
            <a:documentation>Enable to output the pressure and viscous terms separately (as well
as the total force)</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="divergence_stats">
        <a:documentation>Compute the divergence of this field at the Gauss points
and return its stats.  This is a direct measure of the
divergence at the gauss points rather than a discrete measure
at the nodes (provided by several other diagnostic fields).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="calculate_momentum_conservation_error">
        <a:documentation>Calculate the error in the conservation of momentum
IN PROGRESS - Does not include all terms!</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Combining of stat elements for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat">
    <ref name="tensor_field_stat_options_enabled_default"/>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field 
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="pressure_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction
Required in porous_media and multiphase problem types</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase1
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase1</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="phase_density">
              <a:documentation>equation_of_state,</a:documentation>
            </ref>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase2
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase2</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="phase_density">
              <a:documentation>equation_of_state,</a:documentation>
            </ref>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase3
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase3</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="phase_density">
              <a:documentation>equation_of_state,</a:documentation>
            </ref>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase4
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase4</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="phase_density">
              <a:documentation>equation_of_state,</a:documentation>
            </ref>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the PhaseVolumeFraction (which could be saturation).</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFractionFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the Density of this phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DensityFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the Temperature of this phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TemperatureFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase1</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase2</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase3</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase4</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component sum concentration.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentSumConcentrationFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>FiniteElementDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_fe_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grid Reynolds number</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridReynoldsNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>GridPecletNumber

Peclet Number Pe = U*dx/2*diffusivity

Also see the test case 'grid_peclet_number'
if you wish to see the effect of changing the 
diffusivity on a 1D, cg-discretised tracer-field

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridPecletNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice">
              <a:documentation>Mesh on which to calculate dx</a:documentation>
            </ref>
            <element name="field_name">
              <a:documentation>This is the name of the scalar field
to calculate the Peclet number for
Note this field needs to have a diffusivity</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vorticity for a 2D field:

 du   dv
 -- - --
 dy   dx</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity2D</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="vorticity_2d_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Gravitational potential energy density:

-rho*(g dot (r - r_0))

where rho is the Density scalar field
r_0 is the potential energy zero point
and g is the gravity vector

BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD

Limitations:
 - Requires a constant gravity direction.
 - The Density and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GravitationalPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Local average mesh edge lengths</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshEdgeLengths</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="scalar_edge_lengths_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the horizontal stream function psi where:
  \partial_x \psi = -v
  \partial_y \psi = u
where u and v are perpendicular to the gravity direction. Applies a
strong Dirichlet boundary condition of 0 on all boundaries.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <element name="solver">
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>An estimate of the edge wieghts whilst adapting using Zoltan
Note: you *must* turn on inteprolation otherwise this field
will be emptied by an adapt.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxEdgeWeightOnNodes</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumVelocityDivergence

Diagnostic field used in multiphase simulations.
Sums up the divergence of each phase's bulk velocity, i.e. \sum{ div(vfrac*u) }</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumVelocityDivergence</value>
        </attribute>
        <element name="diagnostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="internal_algorithm"/>
          <optional>
            <element name="integrate_divergence_by_parts">
              <empty/>
            </element>
          </optional>
          <ref name="diagnostic_scalar_field_no_adapt"/>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Dummy</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TotalFlux</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DummyT</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Projection of the Velocity vector field of this material_phase 
that uses an overlapping formulation to a conventional DG function space. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VelocityOverlappingProjectedToDG</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_gradient_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>LinearMomentum field.
 p = \rho*u 
(where p is the linear momentum, \rho the density and u the velocity)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the control volume auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DGAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>delta_U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>solid_U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Darcy_Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>f_x</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <attribute name="name">
          <value>Dummy</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="name">
          <value>a_xx</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <a:documentation>This is the gradient of the velocity field - calculated in the dynamic core.</a:documentation>
        <attribute name="name">
          <value>grad_U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="name">
          <value>Viscosity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="cap_option">
    <element name="cap_values">
      <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
      <optional>
        <element name="upper_cap">
          <a:documentation>Set the upper bound on the field.
Defaults to huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Set the lower bound on the field.
Defaults to -huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="limiter_options">
    <choice>
      <element name="limit_face_value">
        <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
        <choice>
          <ref name="sweby_limiter"/>
          <ref name="ultimate_limiter"/>
          <ref name="extrema_limiter"/>
          <ref name="compressive_advection_limiter"/>
          <ref name="ENO_advection"/>
        </choice>
      </element>
      <element name="do_not_limit_face_value">
        <a:documentation>Do not limit the face value</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="ultimate_limiter">
    <element name="limiter">
      <a:documentation>See "The Ultimate Conservative Difference Scheme Applied
to Unsteady One-Dimensional Advection", B. P. Leonard,
1991, Computer Methods in Applied Mechanics and
Engineering, 88, 17-74</a:documentation>
      <attribute name="name">
        <value>Ultimate</value>
      </attribute>
      <ref name="field_based_cfl_number_options"/>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="extrema_limiter">
    <element name="limiter">
      <attribute name="name">
        <value>Extrema</value>
      </attribute>
    </element>
  </define>
  <define name="compressive_advection_limiter">
    <element name="limiter">
      <attribute name="name">
        <value>CompressiveAdvection</value>
      </attribute>
    </element>
  </define>
  <define name="ENO_advection">
    <element name="limiter">
      <attribute name="name">
        <value>ENO</value>
      </attribute>
    </element>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as 
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes except periodic domains.</a:documentation>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
and the fraction of the field in each bin with,
-1.5&lt;=field&lt;0.0, 0.0&lt;=field&lt;1.5, 1.5&lt;=field&lt;2.0, 2.0&lt;=field, 
will be calculated.  </a:documentation>
        <choice>
          <element name="constant">
            <a:documentation>list of bin bounds</a:documentation>
            <ref name="real_vector"/>
          </element>
          <element name="python">
            <a:documentation>Python function prescribing bin bounds. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value that should be an array of reals

</a:documentation>
            <ref name="python_code"/>
          </element>
        </choice>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="phase_density">
    <optional>
      <element name="Density">
        <a:documentation>Specify the density of the current material phase (can also specify density for each component)</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
  </define>
  <define name="equation_of_state">
    <element name="equation_of_state">
      <a:documentation>Use this option to specify the density of fluids</a:documentation>
      <element name="incompressible">
        <a:documentation>Equations of state</a:documentation>
        <element name="linear">
          <element name="all_equal">
            <a:documentation>All eos_coefficients equal as in most of
the test cases (=1)</a:documentation>
            <ref name="real"/>
          </element>
        </element>
      </element>
    </element>
  </define>
</grammar>
