<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="mesh_options.rng"/>
  <include href="physical_parameters.rng"/>
  <include href="prescribed_field_options.rng"/>
  <include href="prognostic_field_options.rng"/>
  <include href="solvers.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="stabilisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <start>
    <element name="shallow_water_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="model">
        <a:documentation>The model type</a:documentation>
        <element name="string_value">
          <value>simple_shallow_water</value>
        </element>
        <ref name="comment"/>
      </element>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="problem_type">
        <a:documentation>Option problem_type does not change the tree.  It is just used for options checking.</a:documentation>
        <element name="string_value">
          <value>fluids</value>
        </element>
        <ref name="comment"/>
      </element>
      <ref name="geometry"/>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value
required. A value of zero indicates that checkpoints
should be created at every dump. If
/io/max_dumpfile_count is exceeded then earlier
checkpoints may be overwritten.</a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="detectors">
            <a:documentation>Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled.</a:documentation>
            <zeroOrMore>
              <choice>
                <element name="static_detector">
                  <a:documentation>A single static detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="lagrangian_detector">
                  <a:documentation>A single lagrangian detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <a:documentation>This is the initial location of a detector that moves with the fluid velocity.</a:documentation>
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="detector_array">
                  <a:documentation>Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <element name="number_of_detectors">
                    <a:documentation>The number of detectors prescribed by the python function.</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <choice>
                    <element name="static">
                      <a:documentation>Create fixed detectors.</a:documentation>
                      <empty/>
                    </element>
                    <element name="lagrangian">
                      <a:documentation>Create detectors which move with the fluid velocity.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                  <choice>
                    <element name="python">
                      <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                      <ref name="python_code"/>
                    </element>
                    <element name="from_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
              </choice>
            </zeroOrMore>
            <optional>
              <element name="binary_output">
                <a:documentation>Enable to write detector output in binary format</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="log_output">
            <a:documentation>Options to create even more output in the logs:

Note that the main option to control the log output is given on the command line:

-v0  only output error and warnings

-v1  also give "navigational information", to indicate where in the code we currently are

-v2  also give any additional information (mins and maxes of fields, etc.)
</a:documentation>
            <optional>
              <element name="memory_diagnostics">
                <a:documentation>Log all allocates and deallocates done for meshes, fields, sparsities and matrices.

NOTE: Requires -v2</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (in seconds) before the simulation terminates</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.

This is usually disabled.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <element name="nonlinear_iterations">
          <a:documentation>maximum number of non-linear iterations.

Manual suggests 2</a:documentation>
          <ref name="integer"/>
        </element>
      </element>
      <ref name="simple_physical_parameter_options"/>
      <element name="material_phase">
        <a:documentation>The material or phase options</a:documentation>
        <attribute name="name">
          <value>Fluid</value>
        </attribute>
        <group>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <group>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="simple_prognostic_velocity_field"/>
              </element>
            </group>
          </element>
          <element name="scalar_field">
            <a:documentation>Free surface elevation</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>LayerThickness</value>
            </attribute>
            <element name="prognostic">
              <ref name="pressure_mesh_choice"/>
              <ref name="prognostic_layerthickness_field"/>
            </element>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
        </group>
      </element>
      <optional>
        <element name="mesh_adaptivity">
          <ref name="prescribed_adaptivity"/>
        </element>
      </optional>
    </element>
  </start>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
  </define>
  <define name="velocity_components_choice">
    <choice>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
        <optional>
          <element name="debugging_mode">
            <a:documentation>this will calculate the determinant of the
rotation matrix for every boundary node
and dump a vtu with the node 
normals and tangenials 1/2</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <!-- and again for robin b.c.s -->
  <define name="robin_velocity_components_choice">
    <!--
              element align_bc_with_surface {
                 element normal_component {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_1 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_2 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="velocity_boundary_conditions">
    <element name="type">
      <a:documentation>A weak no normal flow boundary condition.</a:documentation>
      <attribute name="name">
        <value>no_normal_flow</value>
      </attribute>
      <empty/>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Field output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="field_output_options_disabled">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <choice>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_vtu">
          <a:documentation>Include this field in dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <optional>
        <ref name="exclude_stat"/>
      </optional>
      <optional>
        <ref name="cv_stats"/>
      </optional>
      <zeroOrMore>
        <ref name="surface_integral_stats_scalar"/>
      </zeroOrMore>
      <zeroOrMore>
        <ref name="mixing_stats"/>
      </zeroOrMore>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_options"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_velocity_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_velocity_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="vector_field_stat_options_enabled_default"/>
      <zeroOrMore>
        <ref name="surface_integral_stats_vector"/>
      </zeroOrMore>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_velocity_stat_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <optional>
          <element name="output_terms">
            <a:documentation>Enable to output the pressure and viscous terms separately (as well
as the total force)</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="divergence_stats">
        <a:documentation>Compute the divergence of this field at the Gauss points
and return its stats.  This is a direct measure of the
divergence at the gauss points rather than a discrete measure
at the nodes (provided by several other diagnostic fields).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="calculate_momentum_conservation_error">
        <a:documentation>Calculate the error in the conservation of momentum
IN PROGRESS - Does not include all terms!</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <empty/>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <empty/>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <empty/>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <empty/>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <!-- Most common mesh choices -->
  <define name="mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Same choices, but with VelocityMesh offered first -->
  <define name="velocity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Same choices, but with PressureMesh offered first -->
  <define name="pressure_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Same choices, but with CoordinateMesh offered first -->
  <define name="coordinate_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed..
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note 
that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_cv_divergence_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Vorticity for a 2D field:

 du   dv
 -- - --
 dy   dx</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity2D</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic energy density:

 1/2 rho_0*|u|^2

where rho_0 is the (reference) density 

Limitations:
 - The Density, PerturbationDensity, KineticEnergyDensity and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergyDensity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Local average mesh edge lengths</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshEdgeLengths</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <element name="mesh">
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name_a">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <attribute name="field_name_b">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
          <optional>
            <element name="relative_to_average">
              <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="ignore_boundaries">
              <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name_a">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <attribute name="field_name_b">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
          <optional>
            <element name="relative_to_average">
              <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="ignore_boundaries">
              <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="mesh_choice"/>
          <optional>
            <element name="integrate_gradient_by_parts">
              <empty/>
            </element>
          </optional>
          <ref name="diagnostic_gradient_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Relative vorticity field - curl of the velocity field</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="vorticity_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Planetary vorticity

Limitations:
 - Requires geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PlanetaryVorticity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute vorticity:

  f + curl u

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_cv_gradient_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the control volume auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeAuxiliaryGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <attribute name="gradient_of_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DGAuxiliaryGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <attribute name="gradient_of_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name_a">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <attribute name="field_name_b">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
          <optional>
            <element name="relative_to_average">
              <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name_a">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <attribute name="field_name_b">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
          <optional>
            <element name="relative_to_average">
              <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Displacement</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Displacement</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Projects the Coriolis term onto the mesh of this diagnostic field.
Note that multiple projection methods are available (under the
algorithm option).</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Coriolis</value>
        </attribute>
        <element name="diagnostic">
          <ref name="coriolis_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }
                 )
             }
    -->
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
and the fraction of the field in each bin with,
-1.5&lt;=field&lt;0.0, 0.0&lt;=field&lt;1.5, 1.5&lt;=field&lt;2.0, 2.0&lt;=field, 
will be calculated.  </a:documentation>
        <choice>
          <element name="constant">
            <a:documentation>list of bin bounds</a:documentation>
            <ref name="real_vector"/>
          </element>
          <element name="python">
            <a:documentation>Python function prescribing bin bounds. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value that should be an array of reals

</a:documentation>
            <ref name="python_code"/>
          </element>
        </choice>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <empty/>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <empty/>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="geometry">
    <element name="geometry">
      <a:documentation>Options dealing with the specification of geometry</a:documentation>
      <element name="dimension">
        <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
        <element name="integer_value">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <value>2</value>
        </element>
      </element>
      <element name="mesh">
        <a:documentation>The position mesh</a:documentation>
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <optional>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
      </optional>
      <optional>
        <element name="mesh">
          <a:documentation>The pressure mesh</a:documentation>
          <attribute name="name">
            <value>PressureMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
      </optional>
      <zeroOrMore>
        <element name="mesh">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="mesh_info"/>
          <optional>
            <element name="exclude_from_mesh_adaptivity">
              <empty/>
            </element>
          </optional>
        </element>
      </zeroOrMore>
      <element name="quadrature">
        <a:documentation>Quadrature</a:documentation>
        <element name="degree">
          <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
          <ref name="integer"/>
        </element>
        <optional>
          <element name="surface_degree">
            <a:documentation>Surface quadrature degree

note: this specifies the degree of surface
quadrature not the number of surface gauss points</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="quadrature_family">
            <a:documentation>Select which family of quadrature rules to use.
The default is family_cools.
family_wandzura allows for degree up to 30
on triangular meshes.
family_grundmann_moeller allows for degree up to
29 on simplicial meshes in arbitrary dimension.</a:documentation>
            <element name="string_value">
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </element>
        </optional>
      </element>
      <optional>
        <element name="disable_geometric_data_cache">
          <a:documentation>This causes the change of variables associated with each element in 
the mesh to be stored rather than calculated every time it is used. 
This should speed up computations at a cost of some memory. 

The cache is automatically regenerated after mesh movement or 
adaptivity and is automatically disabled for non-linear positions fields.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="simple_physical_parameter_options">
    <element name="physical_parameters">
      <ref name="simple_gravity_options"/>
      <ref name="coriolis_options"/>
    </element>
  </define>
  <define name="simple_gravity_options">
    <element name="gravity">
      <a:documentation>Set a gravity to be included in the buoyancy term.</a:documentation>
      <element name="magnitude">
        <a:documentation>Acceleration due to gravity. 9.8 m/s^2 on earth.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
  </define>
  <define name="simple_prognostic_velocity_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation</a:documentation>
          <optional>
            <element name="mass_terms">
              <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
              <optional>
                <element name="lump_mass_matrix">
                  <a:documentation>Lump the mass matrix</a:documentation>
                  <optional>
                    <element name="use_submesh">
                      <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="coriolis_terms">
              <a:documentation>Discretisation options for the Coriolis terms in the velocity equation.</a:documentation>
              <optional>
                <!-- Lump the mass matrix. -->
                <element name="lump_mass_matrix">
                  <ref name="comment"/>
                </element>
              </optional>
            </element>
          </optional>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms.</a:documentation>
            <element name="exclude_advection_terms">
              <a:documentation>Remove the advection terms from the equation.</a:documentation>
              <ref name="comment"/>
            </element>
          </element>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation</a:documentation>
          <optional>
            <element name="mass_terms">
              <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
              <optional>
                <element name="lump_mass_matrix">
                  <a:documentation>Lump the mass matrix</a:documentation>
                  <optional>
                    <element name="use_submesh">
                      <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="coriolis_terms">
              <a:documentation>Discretisation options for the Coriolis terms in the velocity equation.</a:documentation>
              <optional>
                <!-- Lump the mass matrix. -->
                <element name="lump_mass_matrix">
                  <ref name="comment"/>
                </element>
              </optional>
            </element>
          </optional>
          <element name="advection_scheme">
            <choice>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity.</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </element>
      </choice>
      <optional>
        <element name="conservative_advection">
          <a:documentation>Conservative discretisation of momentum equations
 BETA=1. -- conservative (divergence form)
 BETA=0. -- non-conservative
 0. &lt; BETA &lt; 1.

Defaults to 1.0 if not supplied.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <optional>
        <element name="relaxation">
          <a:documentation>Non-linear relaxation term
 =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
 =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0. &lt; ITHETA &lt; 1.

Defaults to 0.5 if not supplied.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="simple_input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="simple_input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <element name="boundary_conditions">
      <a:documentation>Boundary conditions</a:documentation>
      <attribute name="name">
        <value>FreeSlip</value>
      </attribute>
      <element name="surface_ids">
        <a:documentation>Enter all external surface IDs here</a:documentation>
        <ref name="integer_vector"/>
      </element>
      <ref name="velocity_boundary_conditions"/>
    </element>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_velocity_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="interpolation_algorithm_vector"/>
  </define>
  <define name="prognostic_layerthickness_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="continuous_galerkin">
        <a:documentation>Continuous Galerkin formulation</a:documentation>
        <optional>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass term in the layer thickness equation.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix</a:documentation>
                <optional>
                  <element name="use_submesh">
                    <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <element name="advection_terms">
          <a:documentation>Discretisation options for the advection terms.</a:documentation>
          <element name="exclude_advection_terms">
            <a:documentation>Remove the advection terms from the equation.</a:documentation>
            <ref name="comment"/>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="theta">
        <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="relaxation">
          <a:documentation>Non-linear relaxation term
 =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
 =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0. &lt; ITHETA &lt; 1.

Defaults to 0.5 if not supplied.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <choice>
      <element name="initial_condition">
        <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
    </choice>
    <element name="mean_layer_thickness">
      <a:documentation>Mean value of thickness to use in wave equation solver
Will be replaced by a field in due course</a:documentation>
      <ref name="real"/>
    </element>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="simple_input_choice_initial_condition_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
      <element name="NEMO_data">
        <a:documentation>Initialize the field from NEMO data. Note that a file path
under '/ocean_forcing/external_data_boundary_conditions' must
be set to use this option.</a:documentation>
        <element name="format">
          <a:documentation>Currently, only the velocity vector field may be initialised in this manner.</a:documentation>
          <element name="string_value">
            <value>Velocity</value>
          </element>
        </element>
      </element>
      <element name="balanced">
        <a:documentation>Set balanced velocity from height field</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
</grammar>
