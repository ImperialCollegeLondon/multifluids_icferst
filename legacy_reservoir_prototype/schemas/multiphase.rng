<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers.rng"/>
  <include href="stabilisation.rng"/>
  <include href="mesh_options.rng"/>
  <include href="physical_parameters.rng"/>
  <include href="prognostic_field_options.rng"/>
  <include href="prescribed_field_options.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <start>
    <element name="multiphase_options">
      <a:documentation>The root node of the options dictionary.
S.I. units are RECOMMENDED to obtain consistent results.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="simulation_type">
        <a:documentation>Select the simulation type</a:documentation>
        <choice>
          <element name="inertia_dominated">
            <a:documentation>Navier-stokes simulator</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="porous_media">
            <a:documentation>Darcy flow simulator</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="magma">
            <a:documentation>Magma flow simulator</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="flooding">
            <a:documentation>Flooding simulator</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="femdem_fracture">
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="boiling">
            <ref name="comment"/>
          </element>
        </optional>
      </element>
      <ref name="geometry"/>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk. 
If using adaptive time-step this periods will be EXACTLY matched.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <element name="PropertiesFromFile">
            <a:documentation>Path (without the extension) to the .csv file containing the fluid and porous media properties.
NOTE: Properties in the .csv file will overwrite the input from diamond.

The information is stored as:

Property, phase, region_ids(0= if all), value (values separated by _ for region ids and tensors)

You can find an example in the Proous_media_general test case

If using this, all the modifiable fields need to have the option to read from a csv file</a:documentation>
            <data type="string"/>
          </element>
        </optional>
        <optional>
          <element name="disable_dump_at_start">
            <a:documentation>Disable dump at simulation start</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="disable_dump_at_end">
            <a:documentation>Disable dump at simulation end</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="max_dump_file_count">
            <a:documentation>Number of dumps before we overwrite previous dumps.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
        <optional>
          <element name="output_scalars_fem">
            <a:documentation>Output FE representation of scalar fields instead of the CV one.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="output_darcy_vel">
            <a:documentation>Calculates the Darcy velocity and is outputed in the vtu files.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="dump_boundaryflux">
            <a:documentation>This option is used to calculate the amount of mass flux across a boundary id.
The output is a .csv file containing this information. use this if you want to 
calculate the production.</a:documentation>
            <empty/>
            <element name="surface_ids">
              <a:documentation>Surface id:</a:documentation>
              <ref name="integer_vector"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="initial_condition_overwrites_boundary">
            <a:documentation>Do not overwrite initial condition with boundary condition.
Important for checkpointed runs! </a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value
required. A value of zero indicates that checkpoints
should be created at every dump. If
/io/max_dumpfile_count is exceeded then earlier
checkpoints may be overwritten.</a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_start">
                <a:documentation>Enable to checkpoint at simulation start.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <element name="stat">
          <a:documentation>Diagnostic output (.stat file) options</a:documentation>
          <optional>
            <element name="output_at_start">
              <a:documentation>Enable to write diagnostic output at simulation start</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="output_before_adapts">
              <a:documentation>Enable to write diagnostic output immediately before mesh adapts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="output_after_adapts">
              <a:documentation>Enable to write diagnostic output immediately after mesh adapts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
        <optional>
          <element name="detectors">
            <a:documentation>Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled. When running in serial, although the output is in principle still generated in ascii format if binary_output is not enabled, it is not certain that it is working well. Hence, it is recommended to enable binary_output and work with binary files. </a:documentation>
            <zeroOrMore>
              <choice>
                <element name="static_detector">
                  <a:documentation>A single static detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="lagrangian_detector">
                  <a:documentation>A single lagrangian detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <a:documentation>This is the initial location of a detector that moves with the fluid velocity.</a:documentation>
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="detector_array">
                  <a:documentation>Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <element name="number_of_detectors">
                    <a:documentation>The number of detectors prescribed by the python function.</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <choice>
                    <element name="static">
                      <a:documentation>Create fixed detectors.</a:documentation>
                      <empty/>
                    </element>
                    <element name="lagrangian">
                      <a:documentation>Create detectors which move with the fluid velocity.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                  <choice>
                    <element name="python">
                      <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                      <ref name="python_code"/>
                    </element>
                    <element name="from_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
              </choice>
            </zeroOrMore>
            <optional>
              <element name="binary_output">
                <a:documentation>Enable to write detector output in binary format</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="lagrangian_timestepping">
                <choice>
                  <element name="explicit_runge_kutta_guided_search">
                    <a:documentation>Use explicit runge kutta method with
binary search</a:documentation>
                    <element name="subcycles">
                      <a:documentation>Number of subdivisions of the timestep
increase this if you are not happy with your 
detector trajectory accuracy, or if particles
are jumping out of the domain a lot</a:documentation>
                      <ref name="integer"/>
                    </element>
                    <element name="search_tolerance">
                      <a:documentation>Tolerance for deciding if detector is in a given
element. Recommended value 1.0e-10.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="n_stages">
                      <a:documentation>Number of RK stages
For the RK4 method, it should be 4.</a:documentation>
                      <ref name="integer"/>
                    </element>
                    <element name="stage_weights">
                      <a:documentation>ERK stage array. This is an array
containing the lower-triangular
part of the Butcher weight matrix
A that explains how to compute the
RK stages.  See
http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
for notation.  The array is stored
in the following order:
[a_{21},a_{31},a_{32},...,a_{s1},a_{s2},a_{s(s-1)}]
and so the array has size s(s-1)/2
where s is the number of stages.
For the RK4 method, it should be
[0.5,0,0.5,0,0,1]</a:documentation>
                      <ref name="real_vector"/>
                    </element>
                    <element name="timestep_weights">
                      <a:documentation>ERK timestep weights. This is the
b vector that explains how to
compute the timestep from the RK
stages.  See
http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
for notation.  It should have size
s where s is the number of stages.
For the RK4 method, it should be
[1/6,1/3,1/3,1/6]</a:documentation>
                      <ref name="real_vector"/>
                    </element>
                  </element>
                  <element name="binary_search">
                    <a:documentation>Use binary search algorithm</a:documentation>
                    <empty/>
                  </element>
                </choice>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="log_output">
            <a:documentation>Options to create even more output in the logs:

Note that the main option to control the log output is given on the command line:

-v0  only output error and warnings

-v1  also give "navigational information", to indicate where in the code we currently are

-v2  also give any additional information (mins and maxes of fields, etc.)
</a:documentation>
            <optional>
              <element name="memory_diagnostics">
                <a:documentation>Log all allocates and deallocates done for meshes, fields, sparsities and matrices.

NOTE: Requires -v2</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="Courant_number">
            <a:documentation>If porous_media, printout the Courant number every time-step</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="Mesh_Diagnostics_Angles">
            <a:documentation>Printout the number of elements and percentage that contain an angle
equal or bigger than the ones specified here
Note: This may slow down your simulation should be used as a diagnostic tool </a:documentation>
            <ref name="real_vector"/>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <!--
                       ## Maximum CPU time (in seconds) before the simulation terminates
                       element cpu_time_limit {
                          real
                       }?,
                       ## Maximum wall time (secs) taken up before
                       ## simulation terminates writing results to disc.
                       ## 
                       ## This is usually disabled.
                       element wall_time_limit {
                          real
                       }?,
          -->
          <element name="nonlinear_iterations">
            <a:documentation>Maximum number of non-linear iterations for the Fixed-Point iteration solver.

Manual suggests 2 for problems that are not very non-linear

If using Fixed_Point_Iteration for multiphase porous media flow the recommendation is ~ 20

If using Fixed_Point_Iteration/Infinite_norm_tol/adaptive_non_linear_iterations to dynamically control the number of 
non-linear iterations or Fixed_Point_Iteration/adaptive_timestep_nonlinear then ~ 15 is recommended.</a:documentation>
            <ref name="integer"/>
            <optional>
              <element name="Fixed_Point_Iteration">
                <a:documentation>NOTE: For multiphase porous media only. Otherwise this value is ignored.  

This is the convergence criterion for the Fixed Point Iteration solver.
The functional to compare is: 

f = L2norm(S*-So)/L2norm(S1-So)

S* is the latest saturation; So is the saturation at the previous FPI
S1 is the saturation after the first FPI. Hence, the reduction of the difference
of saturation is tested

Recommended value: 5e-2</a:documentation>
                <ref name="real"/>
                <optional>
                  <element name="Infinite_norm_tol">
                    <a:documentation>Tolerance for the infinite norm of the variation of the normalized selected field
between two consecutive non-linear iterations.

This can be used to control the number of non-linear interations dynamically.

By default 0.03; Recommended between 0.05 and 0.005</a:documentation>
                    <ref name="real"/>
                    <group>
                      <optional>
                        <element name="adaptive_non_linear_iterations">
                          <a:documentation>Use the infinity norm of the selected field to control the number of non-linear interations dynamically.

A Variable to check has to be chosen:
1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature 

The field selected in "adaptive_timestep_nonlinear" has preference over this</a:documentation>
                          <ref name="integer"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="Temperature_solver_tol">
                          <a:documentation>Sets the infinite tolerance for the internal loop of the temperature transport equation.
This is an internal solver, so a higher tolerance should be used.
                   
Default = 0.05</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                    </group>
                  </element>
                </optional>
                <optional>
                  <element name="Backtracking_factor">
                    <a:documentation>
Recommended settings: Non-linear iterations ~ 20
Backtracking_parameter = -10 automatically selection based on the Courant number, the shock-front Courant number and the physics of the problem

The Backtracking value introduced is used as reference, so it may have a big impact on the convergence

Recommended settings: Backtracking_parameter = -0.33 or -0.5 or -0.8; 
Note: Dynamic dumping loops over the Saturation solver up to 9 times and also uses techniques to accelerate the FPI convergence

The more complex the problem is (i.e. bigger time-steps, gravity, capillary, etc) the smaller the value should be</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
                <optional>
                  <element name="Vanishing_relaxation">
                    <a:documentation>Introduce over-relaxation in the saturation equation. 
This severely HELPS to reduce the number of FPI.

If positive, the input value is the entry pressure.

If negative, the input value is Peclet number desired.

Recommended value for Saturation =&gt; -1e2

Tip: If running with temperature and single phase disable this setting it to 0.</a:documentation>
                    <ref name="real"/>
                    <optional>
                      <element name="Vanishing_for_transport">
                        <a:documentation>This method can also be applied for a transport equation.

Recommended value for Temperature =&gt; -1e0</a:documentation>
                        <ref name="real"/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <!--
                                   (
                                     ## THIS ONLY WORKS with automatics dumpings factor, i.e. Backtracking_factor < 0
                                     ##
                                     ## This parameter change the weight ratio used between the old Saturation and the older Saturation to calculate the new Saturation inside an SFPI
                                     ## 
                                     ## 100 => Only the previous saturation is used (more conservative); 
                                     ## 0.4 => Recommended (default); 
                                     ## 0.3 => Older saturation is at some points as important as the old saturation;
                                     ## 0 => Older saturation is more important than old saturation
                                     ## 
                                     ## If having problems converging the recomendation is to try different parameters from 0.2 to 1.0 or disabling totally the acceleration (100)
                                     element Acceleration_exp{
                                     real
                                     }?
                                   ),
                -->
                <optional>
                  <element name="Impose_min_max">
                    <a:documentation>For TEMPERATURE ONLY, if there are no sources nor sinks
the non-linear solver can be accelerated by imposing physical constraints. Recommended to use.

This imposes that the temperature has to be between bounds.</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="Test_mass_consv">
                    <a:documentation>Convergence criterion based on the 
conservation of mass for the Fixed Point Iteration solver

By default the tolerance is 5e-3</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
                <optional>
                  <element name="Show_Convergence">
                    <a:documentation>Prints the number of iterations and
the final convergence achieved by the FPI solver</a:documentation>
                    <ref name="comment"/>
                  </element>
                </optional>
                <optional>
                  <element name="adaptive_timestep_nonlinear">
                    <a:documentation>Adaptive timestep based on the number of non-linear iterations performed by the FPI solver.

A Variable to check has to be chosen:
1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature </a:documentation>
                    <ref name="integer"/>
                    <group>
                      <optional>
                        <element name="PID_controller">
                          <a:documentation>Time-step size controlled using a PID approach.
By default this method only controls the errors, and based on that increases or decreases the time-step size.
The default aim of number of FPI is the 20% of the maximum number of non-linear iterations.
The increase_factor and decrease_factor are multiplied by 1.2 to give more flexibility to the PID controller.

If this is off, a classical method based on the number of FPI performed is used instead.</a:documentation>
                          <empty/>
                          <optional>
                            <element name="Aim_num_FPI">
                              <a:documentation>Time-step size is controlled to try to always perform the specified number of FPI introduced
here, but in a soft way so if the other checks are performing correctly it can still increase the time-step size. 
By default this is the 20% of the maximum number of non-linear iterations.</a:documentation>
                              <ref name="integer"/>
                            </element>
                          </optional>
                        </element>
                      </optional>
                      <optional>
                        <element name="ensure_solvers_convergence">
                          <a:documentation>If any of the solvers failt to achieve convergence the time-step size is 
reduced and the time-level repeated without waiting to reach the maximum number of FPI.
Note: For the saturation for porous media it allows to diverge inside the saturation FPI.</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="increase_threshold">
                          <a:documentation>Number of FPI below which the time-step size is increased
by default it is the 25% of the maximum allowed FPIs</a:documentation>
                          <ref name="integer"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="increase_factor">
                          <a:documentation>Multiply present timestep by this factor when increasing it.
By default 1.1</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="decrease_factor">
                          <a:documentation>Multiply present timestep by this factor when decreasing it.
By default 2.0</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="max_timestep">
                          <a:documentation>Maximum timestep. Beyond this value the timestep will not be increased.
By default unlimmited.</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                      <optional>
                        <element name="min_timestep">
                          <a:documentation>Minimum timestep. Beyond this value the timestep will not be decreased.
By default dt*1e-3.</a:documentation>
                          <ref name="real"/>
                        </element>
                      </optional>
                    </group>
                  </element>
                </optional>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="adaptive_timestep">
            <a:documentation>Vary the timestep according to the courant number.</a:documentation>
            <element name="requested_cfl">
              <a:documentation>The timestep will be adjusted (within the tolerance
and bounds specified) to target this courant
number. Timestep adapts occur at the end of each
timestep and after a mesh adapt.</a:documentation>
              <ref name="real"/>
            </element>
            <ref name="timestep_cfl_number_options"/>
            <optional>
              <element name="minimum_timestep">
                <a:documentation>Minimum time step size.
Manual suggests 0.0</a:documentation>
                <optional>
                  <element name="terminate_if_reached">
                    <a:documentation>If enabled, signals model termination if a timestep less
than or equal to the minimum_timestep is requested. The
model will stop at the end of the timestep in order to
allow for the latest output to be written. </a:documentation>
                    <ref name="comment"/>
                  </element>
                </optional>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="maximum_timestep">
                <a:documentation>Maximum time step size.
Manual suggests 1.E+10</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="increase_tolerance">
                <a:documentation>The maximum ratio by which the timestep is allowed
to increase in a timestep adapt. e.g., a value of
1.1 indicates that the timestep may be increased by
at most 10%.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="at_first_timestep">
                <a:documentation>Specify whether you want to calculate a new timestep
at the first timestep or not.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <optional>
        <element name="projections">
          <optional>
            <element name="control_volume_projections">
              <a:documentation>Options applicable to the projections used in
the multiphase prototype code</a:documentation>
              <optional>
                <element name="do_not_project">
                  <empty/>
                </element>
              </optional>
              <choice>
                <element name="test_function_space">
                  <attribute name="name">
                    <value>FiniteElement</value>
                  </attribute>
                </element>
                <element name="test_function_space">
                  <attribute name="name">
                    <value>ControlVolume</value>
                  </attribute>
                </element>
              </choice>
              <optional>
                <element name="solver">
                  <ref name="linear_solver_options_asym"/>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <ref name="physical_parameter_options"/>
      </optional>
      <oneOrMore>
        <element name="material_phase">
          <a:documentation>The material or phase options</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <element name="is_multiphase_component">
              <a:documentation>Flag to identify components in multiphase modelling

Pressure and velocity fields must be aliased</a:documentation>
              <element name="alpha_beta">
                <a:documentation>Specify the weighting for the component equation
between 0 and 1. Test cases have 1.</a:documentation>
                <ref name="real"/>
              </element>
              <optional>
                <element name="KComp_Sigmoid">
                  <a:documentation>Enable this option to use sigmoid method for finding equilibrium</a:documentation>
                  <element name="K_Comp">
                    <a:documentation>KComp value for this component</a:documentation>
                    <ref name="real"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="Comp_Sum2One">
                  <a:documentation>Enable this option to force component mass fractions
to sum to 1 by adding constraint into compositional source term.</a:documentation>
                  <element name="Relaxation_Coefficient">
                    <a:documentation>Relaxation coefficient to summation constraint [0,1]. 
--&gt; 0: under-relaxation ; --&gt; 1: over-relaxation</a:documentation>
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="Ensure_Positive">
                      <a:documentation>Ensure that this constraint acts only as a positive absorption term</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="Enforce_Comp_Sum2One">
                      <a:documentation>Explicitly enforce components to sum to one</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="surface_tension">
                  <a:documentation>Surface tension</a:documentation>
                  <element name="coefficient">
                    <a:documentation>Surface tension coefficient. </a:documentation>
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="angle">
                      <a:documentation>Contact angle. </a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="smooth">
                      <a:documentation> Smoothing.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="scale_momentum_by_volume_fraction">
              <a:documentation>Scale the momentum equation by the volume fraction for when some problems are not well poised.</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="linearise_density">
              <a:documentation>linearise density</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="linearise_viscosity">
              <a:documentation>linearise viscosity</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="linearise_component">
              <a:documentation>linearise component for the bulk density calculation used in the momentum equation</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <ref name="equation_of_state">
              <a:documentation>The equation of state</a:documentation>
            </ref>
          </optional>
          <optional>
            <element name="subgridscale_parameterisations">
              <a:documentation>Subgridscale parameterisations</a:documentation>
              <optional>
                <element name="LANS">
                  <a:documentation>Lagrangian-averaged Navier-Stokes equations </a:documentation>
                  <choice>
                    <element name="alpha_isotropic_homogeneous">
                      <a:documentation>smoothing length specified as isotropic homogeneous</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="alpha_anisotropic_homogeneous_cartesian">
                      <ref name="real_dim_symmetric_tensor"/>
                    </element>
                  </choice>
                  <!--
                                  (
                                     element leray {
                                        empty
                                     }|
                                     element LANS_momentum_form {
                                        empty
                                     }|
                                     element LANS_stress_form {
                                        empty
                                     }
                                  )
                  -->
                </element>
              </optional>
              <optional>
                <element name="GLS">
                  <a:documentation>This is the generic length scale (vertical turbulence mixed layer) model, 
based here on Warner et al 2005, Ocean Modelling 8:81-113,
which is itself based on the works of Umlauf and Burchard 2003.

The GLS model encodes four individual turbulence closure models which can be chosen via 'option' below.

You will need to make sure that DistanceToTop and DistanceToBottom fields (under geometry/ocean_boundaries) 
are switched on, as well as PerturbationDensity.</a:documentation>
                  <element name="option">
                    <a:documentation>The base GLS option:
1. k-kl which is a variant of Mellor-Yamada 2.5
2. k-epsilon
3. k-omega
4. 'gen' from Warner et al 2005

k-epsilon is recommended.</a:documentation>
                    <element name="string_value">
                      <choice>
                        <value>k-kl</value>
                        <value>k-epsilon</value>
                        <value>k-omega</value>
                        <value>gen</value>
                      </choice>
                    </element>
                  </element>
                  <element name="stability_function">
                    <a:documentation>The stability function choice:
1. KanthaClayson-94 which corresponds to Kantha and Clayson 1994
2. Galperin-88 which corresponds to Galperin et al 1988
3. Canuto-01-A which corresponds to choice A from Canuto et al 2001
4. Canuto-01-B which corresponds to choice B from Canuto et al 2001

Canuto A or B are recommended.</a:documentation>
                    <element name="string_value">
                      <choice>
                        <value>KanthaClayson-94</value>
                        <value>GibsonLaunder-78</value>
                        <value>Canuto-01-A</value>
                        <value>Canuto-01-B</value>
                      </choice>
                    </element>
                  </element>
                  <optional>
                    <element name="wall_function">
                      <a:documentation>The wall function choice:
1. None - pick this unless you're using k-kl
2. Mellor and Yamada (1980) - parabolic shape
3. Burchard (1998) - symmetric linear shape
4. Burchard (2001) - Used for infinitely deep basins
5. Blumberg et al (1992) - open channel flow

See manual for equations.</a:documentation>
                      <element name="string_value">
                        <choice>
                          <value>none</value>
                          <value>MellorYamda</value>
                          <value>Burchard98</value>
                          <value>Burchard01</value>
                          <value>Blumberg</value>
                        </choice>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="smooth_buoyancy">
                      <a:documentation>Smooth buoyancy frequency before using it?</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="smooth_shear">
                      <a:documentation>Smooth velocity shear before using it?</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="calculate_boundaries">
                      <a:documentation>Do you want the boundary conditions to be set automatically?
Make sure the ocean geometry settings are enabled for this option</a:documentation>
                      <element name="string_value">
                        <choice>
                          <value>neumann</value>
                          <value>dirichlet</value>
                        </choice>
                      </element>
                      <element name="top_surface_ids">
                        <ref name="integer_vector"/>
                      </element>
                      <element name="bottom_surface_ids">
                        <ref name="integer_vector"/>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="relax_diffusivity">
                      <a:documentation>Perform relaxation of the diffusivity and viscosity in the GLS model.
Value should be &gt;=0 and &lt; 1. 0 is no relaxation (i.e. always use the
most up-to-date value) and 0.9 would represent making the current value
be 0.9*old_value + 0.1*new_value. Default is 0.0
If being used with adaptivity, ensure you switch on interpolation of the 
GLSVerticalDiffusivity and GLSVerticalViscosity fields. You will seg fault
otherwise.</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="ocean_parameterisation">
                      <a:documentation>Add extra parameterisation for internal wave breaking at base of MLD. This
is based on the same parameterisation in NEMO and smooths the TKE down 
the water column based on an exponential function
Set the two parameters: % of TKE to smooth down and length scale to do this over</a:documentation>
                      <element name="lengthscale">
                        <ref name="real"/>
                      </element>
                      <element name="percentage">
                        <ref name="real"/>
                      </element>
                    </element>
                  </optional>
                  <element name="scalar_field">
                    <a:documentation>Turbulent kinetic energy. Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSTurbulentKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                        <element name="minimum_value">
                          <a:documentation>Minimum value of TKE in m2s2. A typical value will be around 1e-6</a:documentation>
                          <ref name="real"/>
                        </element>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Generic second equation used in GLS. 
Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSGenericSecondQuantity</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Background viscosity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSBackgroundViscosity</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="mesh_choice"/>
                        <ref name="prescribed_tensor_field"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="mesh_choice"/>
                        <ref name="sediment_concentration_dependent_viscosity_algorithm"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Background diffusivity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSBackgroundDiffusivity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field"/>
                    </element>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy viscosity K_M</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSEddyViscosityKM</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy diffusivity K_H</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSEddyDiffusivityKH</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Length scale (a diagnostic with GLS)</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSLengthScale</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Unedited TKE. The TKE filed has the upper and lower surfaces
altered with Dirichlet conditions for ouput. This is the
unedited surface.</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSTurbulentKineticEnergyOriginal</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Buoyancy frequency</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSBuoyancyFrequency</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Velocity shear</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVelocityShear</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Shear production P</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSShearProduction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Buoyancy production B</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSBuoyancyProduction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Dissipation epsilon</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSDissipationEpsilon</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Stability function S_M</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSStabilityFunctionSM</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Stability function S_H</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSStabilityFunctionSH</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Source1 - TKE source term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSSource1</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Source2 - Second Quantity source term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSSource2</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Absorption1 - TKE absorption term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSAbsorption1</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Absorption2 - Second Quantity absorption term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSAbsorption2</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>GLS Wall function</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSWallFunction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical eddy viscosity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVerticalViscosity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical eddy diffusivity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVerticalDiffusivity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="Mellor_Yamada">
                  <element name="scalar_field">
                    <a:documentation>Kinetic Energy</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>KineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Turbulent Length Scale x Kinetic Energy</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentLengthScalexKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical Viscosity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VerticalViscosity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical Diffusivity of Temperature</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VerticalDiffusivity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="prescribed_diffusivity">
                  <a:documentation>Trivial case in which the user supplies the diffusivity.</a:documentation>
                  <element name="tensor_field">
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>PrescribedDiffusivity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field_no_adapt"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="k-epsilon">
                  <a:documentation>Standard k-epsilon turbulence model (see e.g. Ferziger and Peric(2002) p.295).
Solves 2 additional equations for TurbulentDissipation (epsilon) and TurbulentKineticEnergy (k),
in order to close momentum equations.
Generates an isotropic 'eddy viscosity', added to molecular viscosity field, that
carries the influence of turbulence onto the velocity field. See the manual for details.</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Turbulent kinetic energy (k).
1. 'k_esilon'-type boundary conditions are recommended for this field.
2. Turn on diffusivity, source and absorption diagnostic fields.
3. Use the same mesh as Velocity.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>TurbulentDissipation (epsilon).
1. 'k_epsilon'-type boundary conditions are recommended for this field.
2. Turn on diffusivity, source and absorption diagnostic fields.
3. Use the same mesh as Velocity.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentDissipation</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Set the value of the background (laminar) viscosity field here.
Make it small to see the influence of the eddy viscosity.
IMPORTANT: make velocity/viscosity diagnostic.</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>BackgroundViscosity</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_tensor_field"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="sediment_concentration_dependent_viscosity_algorithm"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="tensor_field">
                      <a:documentation>Set the value of the background (laminar) diffusivity field here.
This is used to calculate scalar field diffusivities.</a:documentation>
                      <attribute name="rank">
                        <value>2</value>
                      </attribute>
                      <attribute name="name">
                        <value>BackgroundDiffusivity</value>
                      </attribute>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_tensor_field"/>
                      </element>
                    </element>
                  </optional>
                  <element name="tensor_field">
                    <a:documentation>Eddy viscosity (turbulent diffusion of velocity).
This is a fictitious isotropic viscosity, added to normal viscosity field, that
carries the influence of turbulence onto the velocity field.</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>EddyViscosity</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_tensor_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Scalar component of the eddy viscosity tensor.
This will appear in the stat file.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>ScalarEddyViscosity</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Integral length scale of the turbulence (diagnostic).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>LengthScale</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>f_1 damping coefficient for low_Re k-epsilon model
Required for low_Re boundaries. If no low_Re boundaries are present
this will be set to 1.0 throughout the domain and will not
affect the result</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>f_1</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>f_2 damping coefficient for low_Re k-epsilon model
Required for low_Re boundaries. If no low_Re boundaries are present
this will be set to 1.0 throughout the domain and will not
affect the result</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>f_2</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>f_mu damping coefficient for low_Re k-epsilon model
Required for low_Re boundaries. If no low_Re boundaries are present
this will be set to 1.0 throughout the domain and will not
affect the result</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>f_mu</value>
                    </attribute>
                    <element name="diagnostic">
                      <ref name="internal_algorithm"/>
                      <ref name="velocity_mesh_choice"/>
                      <ref name="diagnostic_scalar_field"/>
                    </element>
                  </element>
                  <element name="max_damping_value">
                    <a:documentation>Limit the maximum value of damping function values. This helps stability when using low_Re number
boundary conditions. If not using low_Re boundaries this will have no effect. 
Recommended value (default): 10.0</a:documentation>
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Describes distance to nearest solid wall.
Required for low_Re boundaries.
For simple geometries the simplest method of providing this information is to use a python function.
For complex geometries where this is not possible precursive Eikonal equation or Poisson equation
simulations must be run using Fluidity to determine the values for this field.
Details of how this is done can be found in:
Tucker, P 2011: "Hybrid Hamilton/Jacobi/Poisson wall distance function model"
Elias et al 2007: "Simple finite element-based computation of distance functions in unstructured grids"</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>DistanceToWall</value>
                      </attribute>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>VLES Filter function (diagnostic).
Run a VLES by switching this option on.
If so then filtering is applied to the eddy viscosity.</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VLESFilter</value>
                      </attribute>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                    </element>
                  </optional>
                  <element name="C_mu">
                    <a:documentation>Eddy-viscosity coefficient: nu_T = density * C_mu * k**2 / epsilon.
Recommended value (default): 0.09.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="C_eps_1">
                    <a:documentation>TurbulentDissipation production coefficient.
Recommended value (default): 1.44.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="C_eps_2">
                    <a:documentation>TurbulentDissipation destruction coefficient.
Recommended value (default): 1.92.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_k">
                    <a:documentation>Turbulent Schmidt number (eddy viscosity coefficient from k equation).
This is also the ratio of eddy viscosity to eddy diffusivity for use in other scalar fields.
Recommended value (default): 1.0.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_eps">
                    <a:documentation>Turbulent Schmidt number (eddy-viscosity coefficient from epsilon equation).
Recommended value (default): 1.3.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_p">
                    <a:documentation>The Schmidt number (ratio of viscous diffusion rate to momentum diffusion rate) for 
massive scalar fields, or Prandtl number (ratio of viscous diffusion rate to thermal diffusion rate) 
for thermal fields. This is used to calculate the turbulent buoyancy term.
Recommended value (default): 1.0.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="time_discretisation">
                    <a:documentation>Time discretisation of the source terms in the k and epsilon equations and also
of the eddy viscosity</a:documentation>
                    <element name="theta">
                      <a:documentation>Implicit/explicit control (THETA) of source terms and eddy viscosity in
the k-epsilon model
 = 0.  -- explicit
 = 0.5 -- Crank-Nicolson
 = 1.  -- implicit</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="source_term_implementation">
                      <a:documentation>Each term in the k and epsilon equations can be implemented as either a 
source or as an absorbtion term. See the manual under 
'Parameterisations/Turbulent flow modelling and simulation/Reynolds Averaged Navier Stokes (RANS) Modelling/Standard k − ε Turbulence Model/Time Discretisation and Coupling' 
for more information.</a:documentation>
                      <element name="production_term">
                        <choice>
                          <value>source</value>
                          <value>absorbtion</value>
                        </choice>
                      </element>
                      <element name="destruction_term">
                        <choice>
                          <value>source</value>
                          <value>absorbtion</value>
                        </choice>
                      </element>
                      <element name="buoyancy_term">
                        <choice>
                          <value>source</value>
                          <value>absorbtion</value>
                        </choice>
                      </element>
                    </element>
                  </element>
                  <element name="mass_terms">
                    <a:documentation>The source terms in the k-epsilon model are calculated before the field is 
solved. The process requires inversion of a mass matrix. This element contains
options for defining how this is done. For P1 meshes mass lumping can be used,
for other discretisations the mass matrix can not be easily inverted and so a 
solve must be carried out, with solver options specified.</a:documentation>
                    <choice>
                      <element name="lump_mass">
                        <empty/>
                      </element>
                      <element name="use_consistent_mass_matrix">
                        <element name="solver">
                          <ref name="linear_solver_options_asym"/>
                        </element>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="debugging_options">
                      <a:documentation>produce vtu output of individual kk and eps source terms and set prescribed 
source terms for k and epsilon fields (for mms tests)</a:documentation>
                      <element name="source_term_output_fields">
                        <a:documentation>output fields for each of the source terms in the k-epsilon model</a:documentation>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergy_production_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergy_destruction_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergy_buoyancy_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipation_production_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipation_destruction_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipation_buoyancy_term</value>
                            </attribute>
                            <element name="diagnostic">
                              <ref name="internal_algorithm"/>
                              <ref name="velocity_mesh_choice"/>
                              <ref name="diagnostic_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                      </element>
                      <element name="prescribed_source_terms">
                        <a:documentation>Enable to apply prescribed source terms into the k and epsilon equations.
This is useful for MMS tests</a:documentation>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentKineticEnergyPrescribedSource</value>
                            </attribute>
                            <element name="prescribed">
                              <ref name="velocity_mesh_choice"/>
                              <ref name="prescribed_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                        <optional>
                          <element name="scalar_field">
                            <attribute name="rank">
                              <value>0</value>
                            </attribute>
                            <attribute name="name">
                              <value>TurbulentDissipationPrescribedSource</value>
                            </attribute>
                            <element name="prescribed">
                              <ref name="velocity_mesh_choice"/>
                              <ref name="prescribed_scalar_field"/>
                            </element>
                          </element>
                        </optional>
                      </element>
                      <optional>
                        <element name="disable_production_term">
                          <a:documentation>enabling this option disables the production term in the k and epsilon equations</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="disable_destruction_term">
                          <a:documentation>enabling this option disables the destruction term in the k and epsilon equation</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="disable_buoyancy_term">
                          <a:documentation>enabling this option disables the bouyancy term in the k and epsilon equation</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="enable_lowRe_damping">
                          <a:documentation>enabling this option enables the low-Re number damping functions regardless of whether there is
a low-Re boundary condition</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="zero_reynolds_stress_tensor">
                          <a:documentation>Enabling this option disables feedback from the k-epsilon model back into 
the rest of the model. Reynolds stress tensor is set to zero by zeroing 
EddyViscosity and the added source term, based on k, in the momentum equation.
Hence, Viscosity will always stay as the BackgroundViscosity,
diffusivities will remain at the relevant BackgroundDiffusivity, and the 
momentum equation will be as if there were no turbulence model present. 

ScalarEddyViscosity is still calculated as normal.</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                  </optional>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Pressure</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_pressure_field"/>
                </element>
                <element name="prescribed">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="diagnostic">
                  <a:documentation>Compute pressure from Density and InternalEnergy
via a compressible equation of state.</a:documentation>
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="internal_algorithm"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Pressure</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Density</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Density</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="prognostic">
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_density_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Density</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_velocity_field"/>
              </element>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="diagnostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
          <optional>
            <element name="multiphase_properties">
              <a:documentation>Parameters required to model multiphase flow</a:documentation>
              <optional>
                <element name="Relperm_Corey">
                  <a:documentation>Option for relperm type in prototype code
Corey relperm:

relperm = relperm_max * ((Sat-S_immobile)/(1-Sum(Immobile_saturations)))^relperm_exponent</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Relative permeability end point

Value between 0 and 1. Default value 1.0</a:documentation>
                    <attribute name="name">
                      <value>relperm_max</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Relative permeability exponent

Default value 2.0</a:documentation>
                    <attribute name="name">
                      <value>relperm_exponent</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="continuous_phase">
                  <a:documentation>Mark phase as being the continuous phase in dispersed fluid-fluid flow</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
              <optional>
                <choice>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>Linear</value>
                    </attribute>
                    <element name="diameter">
                      <ref name="real"/>
                    </element>
                    <element name="coefficient">
                      <ref name="real"/>
                    </element>
                    <ref name="comment"/>
                  </element>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>Bilinear</value>
                    </attribute>
                    <element name="diameter">
                      <ref name="real"/>
                    </element>
                    <element name="coefficient">
                      <ref name="real"/>
                    </element>
                    <ref name="comment"/>
                  </element>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>Quadratic</value>
                    </attribute>
                    <element name="diameter">
                      <ref name="real"/>
                    </element>
                    <element name="coefficient">
                      <ref name="real"/>
                    </element>
                    <ref name="comment"/>
                  </element>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>Wen&amp;Yu</value>
                    </attribute>
                    <element name="diameter">
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="specified_continuum_viscosity">
                        <ref name="real">
                          <a:documentation>Specify a value for the continuum_phase_viscosity to be used in calculating the drag term. If this is not set, the code defaaults to using the actual viscosity field specfied in the description continuum phase</a:documentation>
                        </ref>
                      </element>
                    </optional>
                    <ref name="comment"/>
                  </element>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>Gidaspow</value>
                    </attribute>
                    <element name="diameter">
                      <ref name="real"/>
                    </element>
                    <element name="coefficient">
                      <ref name="real"/>
                    </element>
                    <ref name="comment"/>
                  </element>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>SmoothedGidaspow</value>
                    </attribute>
                    <element name="diameter">
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="specified_continuum_viscosity">
                        <ref name="real">
                          <a:documentation>Specify a value for the continuum_phase_viscosity to be used in calculating the drag term. If this is not set, the code defaaults to using the actual viscosity field specfied in the description continuum phase</a:documentation>
                        </ref>
                      </element>
                    </optional>
                    <ref name="comment"/>
                  </element>
                  <element name="drag">
                    <attribute name="name">
                      <a:documentation>Options controlling form of drag terms for dispersed fluid-particle interactions</a:documentation>
                      <value>python_function</value>
                    </attribute>
                    <element name="function">
                      <ref name="python_code"/>
                    </element>
                    <oneOrMore>
                      <element name="argument">
                        <attribute name="name">
                          <data type="string"/>
                        </attribute>
                        <choice>
                          <element name="type">
                            <attribute name="name">
                              <value>scalar_field</value>
                            </attribute>
                          </element>
                          <element name="type">
                            <attribute name="name">
                              <value>vector_field</value>
                            </attribute>
                          </element>
                          <element name="type">
                            <attribute name="name">
                              <value>tensor_field</value>
                            </attribute>
                          </element>
                        </choice>
                        <optional>
                          <element name="material_phase">
                            <attribute name="name">
                              <data type="string"/>
                            </attribute>
                          </element>
                        </optional>
                      </element>
                    </oneOrMore>
                    <ref name="comment"/>
                  </element>
                </choice>
              </optional>
              <optional>
                <element name="polydispersive_drag">
                  <a:documentation>apply fluidic drag to polydispersed phase interactions</a:documentation>
                  <element name="lubrication_distace">
                    <ref name="real"/>
                  </element>
                  <ref name="comment"/>
                </element>
              </optional>
              <optional>
                <element name="solid_solid_interactions">
                  <a:documentation>Apply additional solid-solid interactions in polydispersed solid-fluid flow</a:documentation>
                  <optional>
                    <element name="closure">
                      <a:documentation>Turns on Syamlal (1987) closure 	 	  			 </a:documentation>
                      <attribute name="name">
                        <value>Syamlal</value>
                      </attribute>
                      <element name="coefficient_of_friction">
                        <ref name="real"/>
                      </element>
                      <element name="radial_distribution_function">
                        <attribute name="name">
                          <value>Lebowitz</value>
                        </attribute>
                        <ref name="comment"/>
                      </element>
                      <ref name="comment"/>
                    </element>
                  </optional>
                  <ref name="comment"/>
                </element>
              </optional>
              <optional>
                <element name="coarse_graining">
                  <ref name="integer"/>
                </element>
              </optional>
              <optional>
                <element name="capillary_pressure">
                  <a:documentation>Option for capillary pressure				 </a:documentation>
                  <optional>
                    <element name="type_Brooks_Corey">
                      <a:documentation>Brooks-Corey equation

Pc = c * ((S_w-Swir)/(1-Swirr-Sor)) ** -a; here c is the entry pressure

For imbibition swith the formula is:

## Pc = c * ( ((S_w-Swir)/(1-Swirr-Sor)) ** -a ) - B; here c - B is the entry pressure 

You should specify this ONLY for the wetting phase</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Entry pressure of the formula</a:documentation>
                        <attribute name="name">
                          <value>C</value>
                        </attribute>
                        <element name="prescribed">
                          <ref name="material_mesh_choice"/>
                          <ref name="prescribed_scalar_field"/>
                        </element>
                      </element>
                      <optional>
                        <element name="scalar_field">
                          <a:documentation>Imbibition term. if on, entry pressure = C - B;
By default this value is set to zero.</a:documentation>
                          <attribute name="name">
                            <value>B</value>
                          </attribute>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                        </element>
                      </optional>
                      <element name="scalar_field">
                        <a:documentation>exponent -a</a:documentation>
                        <attribute name="name">
                          <value>a</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="type_Power_Law">
                      <a:documentation>Power Law equation

Pc = c*(1-s_eff)**a

where s_eff = (S_w-Swir)/(1-Swir-Sor)

c = maximum pc pressure; a = pc exponent

(no entry pressure) 

ONLY specify for the wetting phase</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Maximum pressure</a:documentation>
                        <attribute name="name">
                          <value>C</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                      <element name="scalar_field">
                        <a:documentation>exponent a</a:documentation>
                        <attribute name="name">
                          <value>a</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="immobile_fraction">
                  <a:documentation>Immobile volume of fluid phase</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Immobile fraction</a:documentation>
                    <attribute name="name">
                      <value>value</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </oneOrMore>
      <optional>
        <ref name="mesh_adaptivity_options"/>
      </optional>
      <optional>
        <element name="porous_media">
          <a:documentation>Porous Media</a:documentation>
          <element name="scalar_field">
            <a:documentation>Specify scalar field Porosity</a:documentation>
            <attribute name="name">
              <value>Porosity</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <choice>
            <a:documentation>Specify field Permeability</a:documentation>
            <element name="scalar_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="aliased">
                  <ref name="generic_aliased_field"/>
                </element>
              </choice>
            </element>
            <element name="vector_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
            </element>
            <element name="tensor_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_tensor_field"/>
              </element>
            </element>
            <element name="Permeability_from_femdem">
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <element name="background_permeability">
                <ref name="real"/>
              </element>
            </element>
          </choice>
          <optional>
            <element name="thermal_porous">
              <a:documentation>Parameters for thermal porous media simulations</a:documentation>
              <element name="scalar_field">
                <a:documentation>Specify scalar field density of the porous media</a:documentation>
                <attribute name="name">
                  <value>porous_density</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="material_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="scalar_field">
                <a:documentation>Specify scalar field heat capacity of the porous media</a:documentation>
                <attribute name="name">
                  <value>porous_heat_capacity</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="material_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="tensor_field">
                <a:documentation>Specify field Thermal conductivity of the porous media</a:documentation>
                <attribute name="name">
                  <value>porous_thermal_conductivity</value>
                </attribute>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_tensor_field"/>
                </element>
              </element>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="wells_and_pipes">
          <a:documentation>Options to specify the wells/pipes</a:documentation>
          <element name="scalar_field">
            <a:documentation>Option to define laterals from diamond
if in doubt set it to 1.</a:documentation>
            <attribute name="name">
              <value>Pipe</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="diagnostic">
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <element name="scalar_field">
            <a:documentation>Specify where and how much the well/pipes are opened
It goes from 0 to 1. If completely opened, set it to 1.</a:documentation>
            <attribute name="name">
              <value>Gamma</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="pressure_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="diagnostic">
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <element name="scalar_field">
            <a:documentation>Absorption in the pipes.
If none, set it to 1.

Recommended. set to 1 and/or use the internal method based on the Moody diagram that can be selected in
/wells_and_pipes/well_options/calculate_sigma_pipe </a:documentation>
            <attribute name="name">
              <value>Sigma</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="subcv_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="diagnostic">
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <element name="scalar_field">
            <a:documentation>Specify the diameter of the pipe.
This effectively defines where and where not there is a pipe.
If the diameter is &lt;=0 no pipe, else there is pipe.</a:documentation>
            <attribute name="name">
              <value>DiameterPipe</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="pressure_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="diagnostic">
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <optional>
            <element name="thermal_well_properties">
              <a:documentation>Specify thermal well-related options</a:documentation>
              <element name="scalar_field">
                <a:documentation>Specify the conductivity of the well/pipe material.
If there are several layers this, it has to be the equivalent conductivity from inside the well/pipe to
the reservoir.
This is only required for heat transport</a:documentation>
                <attribute name="name">
                  <value>Conductivity</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="pressure_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="diagnostic">
                    <ref name="vector_python_diagnostic_algorithm"/>
                    <ref name="diagnostic_scalar_field_no_adapt"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="scalar_field">
                <a:documentation>Specify the thickness of the well/pipe.
If there are several layers this, it has to be the equivalent thiness from inside the well/pipe to
the reservoir.
This is only required for heat transport</a:documentation>
                <attribute name="name">
                  <value>well_thickness</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="pressure_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="diagnostic">
                    <ref name="vector_python_diagnostic_algorithm"/>
                    <ref name="diagnostic_scalar_field_no_adapt"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
            </element>
          </optional>
          <optional>
            <element name="well_options">
              <a:documentation>Specify well-related options</a:documentation>
              <optional>
                <element name="calculate_sigma_pipe">
                  <a:documentation>Calculate the well \sigma field internally
using a non-linear friction factor.
This will over-write the field specified in Sigma1.</a:documentation>
                  <optional>
                    <!-- Defaults to 1.0e-6. -->
                    <element name="pipe_roughness">
                      <ref name="real"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="dt_pipe_factor">
                  <a:documentation>Factor by which to reduce the pipe eqns time step size e.g. 10^{-3}</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="switch_wells_on_and_off">
                  <a:documentation>Switches wells on and off to optimise production</a:documentation>
                  <element name="phase_exclude">
                    <ref name="integer"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="wells_bdf_tolerance">
                  <a:documentation>If when using mesh adaptivity the well path is disappearing, this tolerance can probably solve the problem.
.bdf files have only 6 digits precision, therefore for coordinates bigger than 1000 this values might need to be reduced and
the other way round for values below 100.
The default value is 1e-2.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="well_volume_ids">
              <a:documentation>When using mesh adaptivity, introduce here the ids of the prisms of the wells to ensure
that the well trajectories are preserved.</a:documentation>
              <ref name="integer_vector"/>
              <optional>
                <element name="Show_well_volumes_ids">
                  <a:documentation>Output the ids of the wells</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
            </element>
          </optional>
          <zeroOrMore>
            <element name="well_from_file">
              <a:documentation>Introduce here the relative path to the file defining a 1D well

Note that the only accepted file format is NASTRAN, i.e. .bdf.
Each file has to describe a continuous well touching an external boundary.</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <attribute name="file_path">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
          </zeroOrMore>
        </element>
      </optional>
      <optional>
        <element name="femdem_fracture">
          <a:documentation>Fracking options</a:documentation>
          <optional>
            <element name="femdem_file">
              <a:documentation>Specify FEMDEM input file</a:documentation>
              <attribute name="name">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
          <optional>
            <element name="oneway_coupling_only">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <choice>
                <value>1way</value>
                <value>p2way</value>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="include_pore_pressure">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="blasting">
          <a:documentation>Blasting options</a:documentation>
          <element name="femdem_input_file">
            <a:documentation>Specify FEMDEM input file</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
          <element name="Gidaspow_model">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <choice>
              <value>A</value>
              <value>B</value>
            </choice>
          </element>
          <optional>
            <element name="theta_cty_solid">
              <a:documentation>=1 treats the solid-fluid coupling implicitly in continuity.
=0 assumes the continuity for the solid is already satified.
Recommended value: [0.5,1.0]. Default =1.</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="include_viscous_drag_force">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="flooding">
          <a:documentation>Flooding parameters</a:documentation>
          <element name="scalar_field">
            <a:documentation>This is the term Nm of the manning formula:
b = Nm^2*g * |u|/h^1.33; 
Nm is the manning coefficent. Values between [0.01 and 0.025];
Nm = 0.011 for smooth asphal and Nm = 0.024 to rubble.
For no friction set this to zero or do not activate it.</a:documentation>
            <attribute name="name">
              <value>manning_coef</value>
            </attribute>
            <element name="prescribed">
              <ref name="material_mesh_choice"/>
              <ref name="prescribed_scalar_field"/>
            </element>
          </element>
          <optional>
            <element name="averaging">
              <a:documentation>Perform the mean of the bathymetry when calculating the Manning formula;</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="shallow_drag">
              <a:documentation>Factor that controls the strenght of the drag introduced in the dry areas;
it has a simmilar effect as the artificial diffusion. Default value = 1e-1.</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="numerical_methods">
          <a:documentation>numerical_methods options</a:documentation>
          <optional>
            <element name="use_reflect_method">
              <a:documentation>Use a method to avoid distortion due to boundaries</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="local_upwinding">
              <a:documentation>Upwinding is used for the parts of the domain where there is no shock-front nor rarefaction.
Elsewhere a high-order advection scheme is used. This should increase the speed of the simulation.</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="simple_mass_matrix">
              <a:documentation>Use the diagonal simple version of the mass matrix. M_ii=(Vol/U_NLOC)
This is os by default for the CV pressure formulation </a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="CV_press_homogenisation">
              <a:documentation>For the CV pressure formulation this controls the homogenisation of the velocity nodes of per element
the bigger it is the more P0DG the element becomes. The default values have been obtained so the results are stable.
The default value for P1DGP1 =&gt; 1e4 and disabled for other element types.
To disable it manually, set it to negative values. </a:documentation>
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="Bad_element_fix">
              <a:documentation>Look for bad elements to change its anisotropic permeability to improve their quality</a:documentation>
              <optional>
                <element name="Angle">
                  <a:documentation>Select angle considered too large (degrees) 
Default is 177</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="KvKh_ratio">
                  <a:documentation>What Kv/Kh ratio to use to artifically stretch element
Default is 0.01</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="create_P_mat_fast">
              <a:documentation>Use the fast method to create the pressure matrix. Be aware that some methods only work with the slow method</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </start>
  <define name="prognostic_density_field">
    <optional>
      <ref name="scalar_equation_choice"/>
    </optional>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Continuous Galerkin formulation.</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by
parts.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <ref name="comment"/>
        </element>
        <element name="control_volumes">
          <a:documentation>Use a control volume discretisation.</a:documentation>
          <ref name="spatial_control_volume_options"/>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of field advection equation
 TBETA=1. -- conservative (divergence form)
 TBETA=0. -- non-conservative
 0. &lt; TBETA &lt; 1.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicholson
 =1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
    </element>
    <optional>
      <choice>
        <element name="solver">
          <a:documentation>Solver</a:documentation>
          <ref name="linear_solver_options_asym"/>
        </element>
        <element name="explicit">
          <a:documentation>Assume this field is being solved explicitly and skip the solver.

ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.

Assumes lhs matrix only has diagonal lumped mass (times
density if appropriate for equation)
and divides the rhs by this.</a:documentation>
          <empty/>
        </element>
      </choice>
    </optional>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <optional>
            <ref name="region_ids"/>
          </optional>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <group>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin,
and control_volume spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
              <optional>
                <element name="boundary_overwrites_initial_condition">
                  <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <ref name="input_choice_real"/>
          </element>
        </group>
      </element>
    </zeroOrMore>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
            <optional>
              <ref name="recalculation_options"/>
            </optional>
          </element>
          <element name="diagnostic">
            <a:documentation>This only works for traffic modelling</a:documentation>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="geometry">
    <element name="geometry">
      <a:documentation>Options dealing with the specification of geometry</a:documentation>
      <element name="dimension">
        <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
        <element name="integer_value">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <value>3</value>
            <value>2</value>
            <value>1</value>
          </choice>
        </element>
      </element>
      <element name="mesh">
        <a:documentation>The position mesh</a:documentation>
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <optional>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
      </optional>
      <optional>
        <element name="mesh">
          <a:documentation>The pressure mesh</a:documentation>
          <attribute name="name">
            <value>PressureMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
      </optional>
      <zeroOrMore>
        <element name="mesh">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="mesh_info"/>
          <optional>
            <element name="exclude_from_mesh_adaptivity">
              <empty/>
            </element>
          </optional>
        </element>
      </zeroOrMore>
      <element name="quadrature">
        <a:documentation>Quadrature</a:documentation>
        <element name="degree">
          <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
          <ref name="integer"/>
        </element>
        <optional>
          <!--
                       ## Surface quadrature degree
                       ## 
                       ## note: this specifies the degree of surface
                       ## quadrature not the number of surface gauss points
                       element surface_degree {
                          integer
                       }?,
                       ## Sets the degree of quadrature on each quadrilateral
                       ## face of the control volume. 
                       ##
                       ## Defaults to 1 if
                       ## unselected which is the same as pre-new options
                       ## behaviour.
                       element controlvolume_surface_degree {
                          integer
                       }?,
                       ## Select which family of quadrature rules to use.
                       ## The default is family_cools.
                       ## family_wandzura allows for degree up to 30
                       ## on triangular meshes.
                       ## family_grundmann_moeller allows for degree up to
                       ## 29 on simplicial meshes in arbitrary dimension.
          -->
          <element name="quadrature_family">
            <element name="string_value">
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </element>
        </optional>
      </element>
      <optional>
        <element name="create_binary_msh">
          <a:documentation>Use Fluidity to overwrite the input .msh file into a binary .msh file. 

Useful to convert your ASCII msh files into binary to be able to decompose the mesh.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_tensor_stat_options"/>
    <ref name="adaptivity_options_tensor_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <define name="diagnostic_cv_gradient_vector_field">
    <optional>
      <element name="lump_mass_matrix">
        <a:documentation>Choose whether the mass matrix is lumped or not</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="solver">
        <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Normalise the gradient by its magnitude</a:documentation>
        <empty/>
      </element>
    </optional>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_gradient_vector_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_cv_divergence_scalar_field">
    <!-- No solver options because it can be solved directly! -->
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_fe_divergence_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the normal direction
of the rotation matrix.
If off then fluidity computes the normal
If on the tangents vectors must also be specified.</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>specify first unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>specify second (if exists, i.e. if 3d) unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <choice>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
        <optional>
          <element name="debugging_mode">
            <a:documentation>this will calculate the determinant of the
rotation matrix for every boundary node
and dump a vtu with the node 
normals and tangenials 1/2</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>NOT USED - choose "dirichlet" instead for the cty bcs

This applies a Dirichlet condition through the continuity equation
and thus will only apply a normal component of this specified
velocity as the boundary condition.</a:documentation>
        <attribute name="name">
          <value>dirichlet_continuity</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>This applies a Dirichlet condition through the viscous terms in the
momentum equation. It will be applied to each of the components specified.</a:documentation>
        <attribute name="name">
          <value>dirichlet_viscosity</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>This applies a Dirichlet condition for the advection velocity
of the momentum equation.</a:documentation>
        <attribute name="name">
          <value>dirichlet_advection</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Add a bulk formulae boundary condition. Only makes sense
on the Velocity field.</a:documentation>
        <attribute name="name">
          <value>bulk_formulae</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
        <optional>
          <element name="surface_stabilisation">
            <a:documentation>This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far. 
Note: Once activated, the stabilisation term will occur in all free surface areas in the domain. 
IN DEVELOPMENT</a:documentation>
            <element name="scale_factor">
              <a:documentation>Scale factor for the surface stabilisation.</a:documentation>
              <ref name="real"/>
            </element>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <optional>
              <element name="manning-strickler">
                <a:documentation>Use the Manning-Strickler formulation:
n^2*g*|u|*u/H^(1/3)
where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.

The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density 
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air. 

&lt;b&gt;Note that you have to specify
this density in the same units as the 
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the 
recommended (non-dimensional) value of 1.0 for 
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a penalty function for the near wall region.
Using this option coarse meshes can
be used in the near wall region.

Should be used in combination with a no_normal_flow condition. 

See Bazilevs et al. 2007</a:documentation>
        <attribute name="name">
          <value>near_wall_treatment</value>
        </attribute>
        <element name="tolerance">
          <ref name="real"/>
        </element>
        <optional>
          <element name="Cb">
            <a:documentation>if not set then Cb=2*h, where h is the element size</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Log law of the wall

Should be used in combination with a no_normal_flow condition. </a:documentation>
        <attribute name="name">
          <value>log_law_of_wall</value>
        </attribute>
        <element name="surface_roughness">
          <ref name="real"/>
        </element>
      </element>
      <element name="type">
        <a:documentation>Dummy BC

Should be used in combination with the near_wall_treatment condition.
When activated wall treatment is not applied on the wall-outflow edge.</a:documentation>
        <attribute name="name">
          <value>outflow</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Momentun BC
</a:documentation>
        <attribute name="name">
          <value>momentum</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Momentun BC
</a:documentation>
        <attribute name="name">
          <value>momentuminout</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a file details the convergence (or otherwise) of
this field with every advective nonlinear
iteration.
ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for pressure (can't have a convergence file) -->
  <define name="pressure_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="debugging_vtus">
          <a:documentation>Write out some extra debugging vtu files that can be used
to analyse what goes on in the pressure projection steps.
WARNING: this may create a huge amount of vtu files, as 
multiple files are written per nonlinear iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Field output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="checkpoint">
          <a:documentation>To be used with time-averaged diagnostic fields so that they can be checkpointed.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="field_output_options_disabled">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <choice>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_vtu">
          <a:documentation>Include this field in dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_velocity_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_velocity_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Diagnostic statistics for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_velocity_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_velocity_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <optional>
          <element name="output_terms">
            <a:documentation>Enable to output the pressure and viscous terms separately (as well
as the total force)</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="divergence_stats">
        <a:documentation>Compute the divergence of this field at the Gauss points
and return its stats.  This is a direct measure of the
divergence at the gauss points rather than a discrete measure
at the nodes (provided by several other diagnostic fields).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="calculate_momentum_conservation_error">
        <a:documentation>Calculate the error in the conservation of momentum
IN PROGRESS - Does not include all terms!</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Combining of stat elements for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat">
    <ref name="tensor_field_stat_options_enabled_default"/>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field 
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Salinity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Salinity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundTemperature</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note 
that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction
Required in porous_media and multiphase problem types</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase1
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase1</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="equation_of_state"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase2
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase2</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="equation_of_state"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase3
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase3</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="equation_of_state"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase4
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase4</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="equation_of_state"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
        </choice>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the PhaseVolumeFraction (which could be saturation).</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFractionFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the Density of this phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DensityFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the Temperature of this phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TemperatureFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase1</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase2</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase3</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component mass fraction.

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionFEInterpolationPhase4</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Finite element interpolation of CV solution
of the component sum concentration.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentSumConcentrationFEInterpolation</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>FiniteElementDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_fe_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grid Reynolds number</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridReynoldsNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>GridPecletNumber

Peclet Number Pe = U*dx/2*diffusivity

Also see the test case 'grid_peclet_number'
if you wish to see the effect of changing the 
diffusivity on a 1D, cg-discretised tracer-field

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridPecletNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice">
              <a:documentation>Mesh on which to calculate dx</a:documentation>
            </ref>
            <element name="field_name">
              <a:documentation>This is the name of the scalar field
to calculate the Peclet number for
Note this field needs to have a diffusivity</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vorticity for a 2D field:

 du   dv
 -- - --
 dy   dx</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity2D</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="vorticity_2d_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Gravitational potential energy density:

-rho*(g dot (r - r_0))

where rho is the Density scalar field
r_0 is the potential energy zero point
and g is the gravity vector

BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD

Limitations:
 - Requires a constant gravity direction.
 - The Density and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GravitationalPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Local average mesh edge lengths</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshEdgeLengths</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="scalar_edge_lengths_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the horizontal stream function psi where:
  \partial_x \psi = -v
  \partial_y \psi = u
where u and v are perpendicular to the gravity direction. Applies a
strong Dirichlet boundary condition of 0 on all boundaries.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <element name="solver">
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>An estimate of the edge wieghts whilst adapting using Zoltan
Note: you *must* turn on inteprolation otherwise this field
will be emptied by an adapt.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxEdgeWeightOnNodes</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumVelocityDivergence

Diagnostic field used in multiphase simulations.
Sums up the divergence of each phase's bulk velocity, i.e. \sum{ div(vfrac*u) }</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumVelocityDivergence</value>
        </attribute>
        <element name="diagnostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="internal_algorithm"/>
          <optional>
            <element name="integrate_divergence_by_parts">
              <empty/>
            </element>
          </optional>
          <ref name="diagnostic_scalar_field_no_adapt"/>
          <element name="solver">
            <ref name="linear_solver_options_sym"/>
          </element>
        </element>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Dummy</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TotalFlux</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DummyT</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CV_Pressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Projection of the Velocity vector field of this material_phase 
that uses an overlapping formulation to a conventional DG function space. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VelocityOverlappingProjectedToDG</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_gradient_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>LinearMomentum field.
 p = \rho*u 
(where p is the linear momentum, \rho the density and u the velocity)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the control volume auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DGAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>delta_U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>solid_U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Darcy_Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>f_x</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="nphase">
            <a:documentation>
TO BE DELETED
		
THIS OPTION IS USED TO SET TENSOR DIMENSIONS		</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <a:documentation>Field type		</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <attribute name="name">
          <value>Dummy</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="name">
          <value>a_xx</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <a:documentation>This is the gradient of the velocity field - calculated in the dynamic core.</a:documentation>
        <attribute name="name">
          <value>grad_U</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="name">
          <value>Viscosity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="cap_option">
    <element name="cap_values">
      <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
      <optional>
        <element name="upper_cap">
          <a:documentation>Set the upper bound on the field.
Defaults to huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Set the lower bound on the field.
Defaults to -huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="limiter_options">
    <choice>
      <element name="limit_face_value">
        <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
        <choice>
          <ref name="sweby_limiter"/>
          <ref name="ultimate_limiter"/>
          <ref name="extrema_limiter"/>
          <ref name="compressive_advection_limiter"/>
          <ref name="ENO_advection"/>
        </choice>
      </element>
      <element name="do_not_limit_face_value">
        <a:documentation>Do not limit the face value</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="ultimate_limiter">
    <element name="limiter">
      <a:documentation>See "The Ultimate Conservative Difference Scheme Applied
to Unsteady One-Dimensional Advection", B. P. Leonard,
1991, Computer Methods in Applied Mechanics and
Engineering, 88, 17-74</a:documentation>
      <attribute name="name">
        <value>Ultimate</value>
      </attribute>
      <ref name="field_based_cfl_number_options"/>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="extrema_limiter">
    <element name="limiter">
      <attribute name="name">
        <value>Extrema</value>
      </attribute>
    </element>
  </define>
  <define name="compressive_advection_limiter">
    <element name="limiter">
      <attribute name="name">
        <value>CompressiveAdvection</value>
      </attribute>
    </element>
  </define>
  <define name="ENO_advection">
    <element name="limiter">
      <attribute name="name">
        <value>ENO</value>
      </attribute>
    </element>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as 
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes except periodic domains.</a:documentation>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
and the fraction of the field in each bin with,
-1.5&lt;=field&lt;0.0, 0.0&lt;=field&lt;1.5, 1.5&lt;=field&lt;2.0, 2.0&lt;=field, 
will be calculated.  </a:documentation>
        <choice>
          <element name="constant">
            <a:documentation>list of bin bounds</a:documentation>
            <ref name="real_vector"/>
          </element>
          <element name="python">
            <a:documentation>Python function prescribing bin bounds. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value that should be an array of reals

</a:documentation>
            <ref name="python_code"/>
          </element>
        </choice>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <element name="solenoidal_lagrange_update">
          <a:documentation>Update this field using the lagrangian multiplier
calculated in the solenoidal projection of a
scalar field.

Note this field must be specified as the update field
underneath that vector field too.

Note also this only really makes sense for coupled
fields like velocity and pressure.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <ref name="solenoidal_options"/>
      </optional>
    </element>
  </define>
  <define name="solenoidal_options">
    <element name="solenoidal">
      <a:documentation>Constrained divergence-free projection.
This adds an additional constraint that ensures that the field
is solenoidal, i.e. divergence-free.
This is equivalent in cost to a pressure solve.
This is expensive, and thus best left until
needed.

Note well: this only makes sense for nondivergent
vector fields, such as incompressible velocity!</a:documentation>
      <element name="interpolated_field">
        <a:documentation>Options for the mass matrix of the field being interpolated</a:documentation>
        <choice>
          <element name="continuous">
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)

Required when using interpolating continuous fields</a:documentation>
              <optional>
                <element name="use_submesh">
                  <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </element>
          <element name="discontinuous">
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </element>
      <element name="lagrange_multiplier">
        <a:documentation>Options for the lagrange multiplier

Must be on a continuous mesh!</a:documentation>
        <ref name="pressure_mesh_choice"/>
        <element name="spatial_discretisation">
          <choice>
            <element name="continuous_galerkin">
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts.

Automatic when projecting a discontinuous field</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="control_volumes">
              <empty/>
            </element>
          </choice>
        </element>
        <optional>
          <element name="reference_node">
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="repair_stiff_nodes">
            <a:documentation>**UNDER DEVELOPMENT**
This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
At a debug level of 2 it also prints out the value and the sum of the row values.
This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <empty/>
            </element>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </optional>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a projection matrix.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </element>
    </element>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="equation_of_state">
    <element name="equation_of_state">
      <a:documentation>Use this option to specify the density of fluids</a:documentation>
      <choice>
        <element name="incompressible">
          <a:documentation>Equations of state</a:documentation>
          <element name="linear">
            <a:documentation>Incompressible linear equation of state

(DEN = EOS_COEFS( 1 ) + EOS_COEFS( 2 ) * P + EOS_COEFS( 3 ) * T + EOS_COEFS( 4 ) * P * T
+ EOS_COEFS( 5 ) * ( P **2 )     + EOS_COEFS( 6 ) * ( T **2 ) + EOS_COEFS( 7 ) * ( P **2 ) * T 
+ EOS_COEFS( 8 ) * P * ( T **2 ) + EOS_COEFS( 9 ) * (( P * T ) **2 )</a:documentation>
            <choice>
              <element name="all_equal">
                <a:documentation>All eos_coefficients equal as in most of
the test cases (=1)</a:documentation>
                <ref name="real"/>
              </element>
              <element name="specify_all">
                <a:documentation>Specify the coefficients separately
There should probably be at least 9
see multi_eos.F90 lines 132-140</a:documentation>
                <element name="number_of_ccefficients">
                  <ref name="real"/>
                </element>
                <element name="coefficients">
                  <ref name="real_vector"/>
                </element>
              </element>
            </choice>
            <optional>
              <element name="reference_density">
                <a:documentation>The reference or background density</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="temperature_dependency">
                <a:documentation>Enable to add temperature dependency
to the equation of state.</a:documentation>
                <element name="reference_temperature">
                  <a:documentation>The reference or background
temperature (actual temperature =
calculated temperature plus this
value).</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="thermal_expansion_coefficient">
                  <a:documentation>The thermal expansion coefficient</a:documentation>
                  <ref name="real"/>
                </element>
              </element>
            </optional>
            <optional>
              <element name="salinity_dependency">
                <a:documentation>Enable to add salinity dependency to
the equation of state.</a:documentation>
                <element name="reference_salinity">
                  <a:documentation>The reference or background
salinity (actual salinity =
calculated salinity plus this
value).</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="saline_contraction_coefficient">
                  <a:documentation>The haline contraction coefficient</a:documentation>
                  <ref name="real"/>
                </element>
              </element>
            </optional>
            <optional>
              <element name="subtract_out_hydrostatic_level">
                <a:documentation>Enable this option to subtract out
the hydrostatic level</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </element>
        <element name="compressible">
          <a:documentation>Equations of state for compressible applications</a:documentation>
          <choice>
            <element name="stiffened_gas">
              <a:documentation>Stiffened Gas EoS

DEN = ( P + EOS_COEFS( 1 )) * EOS_COEFS( 2 ) / T

Note that setting EOS_COEFS( 1 ) = 0. and EOS_COEFS( 2 ) = 1/gas constant (Rd [J/kg/K])
The equation for ideal gases is obtained.</a:documentation>
              <element name="eos_option1">
                <ref name="real"/>
              </element>
              <element name="eos_option2">
                <ref name="real"/>
              </element>
              <optional>
                <element name="reference_density">
                  <a:documentation>reference uncompressed density

if activated then either Liquid EoS or
full Stiffened Gas EoS</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="ratio_specific_heats">
                  <a:documentation>Ratio of specific heats at constant
pressure to that at constant volume

Requires an energy field.
If activated then a full Stiffened Gas EoS </a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="bulk_sound_speed_squared">
                  <a:documentation>bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density

if activated then either full or partial Liquid EoS or full
Stiffened Gas EoS</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <element name="JWL_equation">
              <a:documentation>Jones-Wilkins-Lee equation of state for explosives (JWL-equation)

Used with compressible simulations

P=A*(1-w/(R1*V))*exp(-R1*V)+B*(1-w/(R2*V))*exp(-R2/V)+w*E0/V;

The ratio V =roe/ro is defined by using roe = density of the explosive (solid part) and ro = density of the detonation products.</a:documentation>
              <element name="density_of_explosive_roe">
                <ref name="real"/>
              </element>
              <element name="A">
                <ref name="real"/>
              </element>
              <element name="B">
                <ref name="real"/>
              </element>
              <element name="R1">
                <ref name="real"/>
              </element>
              <element name="R2">
                <ref name="real"/>
              </element>
              <element name="E0">
                <ref name="real"/>
              </element>
              <element name="w">
                <ref name="real"/>
              </element>
            </element>
            <element name="exponential_oil_gas">
              <a:documentation>Exponential EOS (SPE 102542)

DEN = DEN_REF * EXP( COMPRES_FACTOR * ( P_oil * P_oil_ref ))
</a:documentation>
              <optional>
                <element name="compressibility">
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="reference_density">
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <element name="linear_in_pressure">
              <a:documentation>Linear in Pressure EOS 

DEN = A * P + B

Use this option for flooding, being A = 1/gravity and B the bathymetry</a:documentation>
              <element name="coefficient_A">
                <ref name="real"/>
              </element>
              <element name="coefficient_B">
                <choice>
                  <element name="constant">
                    <a:documentation>list of bin bounds</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="python">
                    <a:documentation>Python function prescribing real input. Functions should be of the form:
   def val(X, t):
   # Function code
   return # Return value

   where X is a tuple of length geometry dimension.</a:documentation>
                    <ref name="python_code"/>
                  </element>
                </choice>
              </element>
              <optional>
                <element name="include_internal_energy">
                  <a:documentation>If chosen: DEN = A * P / T + B</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="exponential_in_pressure">
              <a:documentation>Exponential in Pressure EOS 

DEN = A * P ^ B
</a:documentation>
              <element name="coefficient_A">
                <ref name="real"/>
              </element>
              <element name="coefficient_B">
                <ref name="real"/>
              </element>
            </element>
            <element name="Temperature_Pressure_correlation">
              <a:documentation>Temperature-Pressure correlation for liquids ONLY.

Range of applicability: 0 to 2*10^9 Pa.

rho1 = rho0/(1+Beta(T1-T0))/(1-(P1-P0)/E)

where rho0 is the reference density at temperature T0 and pressure P0;

Beta is volumetric expansion coefficient (m^3/m^3 Celsius);
                       
E is the liquid elasticity bulk modulus (N/m^2)

NOTE: if temperature is not defined the temperature is defined as zero.</a:documentation>
              <element name="rho0">
                <a:documentation>Reference density</a:documentation>
                <ref name="real"/>
              </element>
              <element name="T0">
                <a:documentation>Reference temperature</a:documentation>
                <ref name="real"/>
              </element>
              <element name="P0">
                <a:documentation>Reference Pressure</a:documentation>
                <ref name="real"/>
              </element>
              <element name="coefficient_Beta">
                <a:documentation>volumetric expansion coefficient (m^3/m^3 Celsius)</a:documentation>
                <ref name="real"/>
              </element>
              <element name="coefficient_E">
                <a:documentation>liquid elasticity bulk modulus (N/m^2)</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </choice>
        </element>
        <element name="python_state">
          <a:documentation>The "Dummy" diagnotic field on the pressure mesh is required for this option</a:documentation>
          <ref name="scalar_python_diagnostic_algorithm"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="rheology">
    <element name="rheology">
      <a:documentation>Specify rheologival model for this materal</a:documentation>
      <choice>
        <element name="newtonian">
          <a:documentation>Newtonian material with single coefficient of viscosity</a:documentation>
          <element name="tensor_field">
            <attribute name="name">
              <value>Viscosity</value>
            </attribute>
            <element name="prescribed">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_values_tensor_field"/>
              <ref name="prescribed_output_options"/>
            </element>
          </element>
        </element>
        <element name="non_newtonian">
          <a:documentation>Models including power law and Herschel-Bulkley	</a:documentation>
          <attribute name="name">
            <value>ShearDependent</value>
          </attribute>
          <optional>
            <element name="yield_stress">
              <ref name="real"/>
            </element>
          </optional>
          <element name="exponent">
            <ref name="real"/>
          </element>
          <element name="consistency_index">
            <ref name="real"/>
          </element>
          <optional>
            <element name="tolerance">
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="lower_bound">
              <ref name="real"/>
            </element>
          </optional>
          <optional>
            <element name="upper_bound">
              <ref name="real"/>
            </element>
          </optional>
          <element name="tensor_field">
            <attribute name="name">
              <value>Viscosity</value>
            </attribute>
            <element name="diagnostic">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_output_options"/>
            </element>
          </element>
        </element>
        <element name="non_newtonian">
          <attribute name="name">
            <value>Carreau</value>
          </attribute>
          <element name="viscosity_at_zero_shear">
            <ref name="real"/>
          </element>
          <optional>
            <element name="viscosity_at_infinite_shear">
              <ref name="real"/>
            </element>
          </optional>
          <element name="relaxation_time">
            <ref name="real"/>
          </element>
          <element name="exponent">
            <ref name="real"/>
          </element>
          <element name="tensor_field">
            <attribute name="name">
              <value>Viscosity</value>
            </attribute>
            <element name="diagnostic">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_output_options"/>
            </element>
          </element>
        </element>
      </choice>
    </element>
  </define>
</grammar>
