<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers.rng"/>
  <include href="stabilisation.rng"/>
  <include href="mesh_options.rng"/>
  <include href="physical_parameters.rng"/>
  <include href="prognostic_field_options.rng"/>
  <include href="prescribed_field_options.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <start>
    <element name="icferst_options">
      <a:documentation>IC-FERST is a next generation simulator based on Double-Control-Volume
Finite Element methods and dynamic unstructured mesh optimisation.

IC-FERST is licensed under the LGPL. For more information
please visit: http://multifluids.github.io/</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <choice>
        <element name="inertia_dominated_simulator">
          <a:documentation>Navier-stokes simulator</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="porous_media_simulator">
          <a:documentation>Darcy flow simulator</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="magma_simulator">
          <a:documentation>Magma flow simulator</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="poroelasticity">
          <a:documentation>Poro-elasticity simulator:
This requires to define through diamond the tensor field in phase 1 UAbsorB
as an absorption term and also the RHS that should include the second time-derivative for the solid phase
and also the coupling terms. The first phase is considered the solid phase.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="flooding_simulator">
          <a:documentation>Flooding simulator</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
      <ref name="geometry"/>
      <ref name="solver_options"/>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="real"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <choice>
              <element name="constant">
                <ref name="integer"/>
              </element>
              <element name="python">
                <a:documentation>Python function prescribing integer input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </choice>
        <optional>
          <element name="PropertiesFromFile">
            <a:documentation>Path (without the extension) to the .csv file containing the fluid and porous media properties.
NOTE: Properties in the .csv file will overwrite the input from diamond.

The information is stored as:

Property, phase, region_ids(0= if all), value (values separated by _ for region ids and tensors)

You can find an example in the Proous_media_general test case

If using this, all the modifiable fields need to have the option to read from a csv file</a:documentation>
            <data type="string"/>
          </element>
        </optional>
        <optional>
          <element name="Show_Convergence">
            <a:documentation>Prints the number of iterations and
the final convergence achieved by the FPI solver</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="Courant_number">
            <a:documentation>If porous_media, printout the Courant number every time-step</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="dump_boundaryflux">
            <a:documentation>Surface to Integrate Over</a:documentation>
            <empty/>
            <element name="surface_ids">
              <a:documentation>Surface id:</a:documentation>
              <ref name="integer_vector"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value
required. A value of zero indicates that checkpoints
should be created at every dump. If
/io/max_dumpfile_count is exceeded then earlier
checkpoints may be overwritten.</a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_start">
                <a:documentation>Enable to checkpoint at simulation start.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="detectors">
            <a:documentation>Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled. When running in serial, although the output is in principle still generated in ascii format if binary_output is not enabled, it is not certain that it is working well. Hence, it is recommended to enable binary_output and work with binary files.</a:documentation>
            <zeroOrMore>
              <choice>
                <element name="static_detector">
                  <a:documentation>A single static detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="lagrangian_detector">
                  <a:documentation>A single lagrangian detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <a:documentation>This is the initial location of a detector that moves with the fluid velocity.</a:documentation>
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="detector_array">
                  <a:documentation>Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <element name="number_of_detectors">
                    <a:documentation>The number of detectors prescribed by the python function.</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <choice>
                    <element name="static">
                      <a:documentation>Create fixed detectors.</a:documentation>
                      <empty/>
                    </element>
                    <element name="lagrangian">
                      <a:documentation>Create detectors which move with the fluid velocity.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                  <choice>
                    <element name="python">
                      <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                      <ref name="python_code"/>
                    </element>
                    <element name="from_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
              </choice>
            </zeroOrMore>
            <optional>
              <element name="binary_output">
                <a:documentation>Enable to write detector output in binary format</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="lagrangian_timestepping">
                <choice>
                  <element name="explicit_runge_kutta_guided_search">
                    <a:documentation>Use explicit runge kutta method with
binary search</a:documentation>
                    <element name="subcycles">
                      <a:documentation>Number of subdivisions of the timestep
increase this if you are not happy with your
detector trajectory accuracy, or if particles
are jumping out of the domain a lot</a:documentation>
                      <ref name="integer"/>
                    </element>
                    <element name="search_tolerance">
                      <a:documentation>Tolerance for deciding if detector is in a given
element. Recommended value 1.0e-10.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="n_stages">
                      <a:documentation>Number of RK stages
For the RK4 method, it should be 4.</a:documentation>
                      <ref name="integer"/>
                    </element>
                    <element name="stage_weights">
                      <a:documentation>ERK stage array. This is an array
containing the lower-triangular
part of the Butcher weight matrix
A that explains how to compute the
RK stages.  See
http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
for notation.  The array is stored
in the following order:
[a_{21},a_{31},a_{32},...,a_{s1},a_{s2},a_{s(s-1)}]
and so the array has size s(s-1)/2
where s is the number of stages.
For the RK4 method, it should be
[0.5,0,0.5,0,0,1]</a:documentation>
                      <ref name="real_vector"/>
                    </element>
                    <element name="timestep_weights">
                      <a:documentation>ERK timestep weights. This is the
b vector that explains how to
compute the timestep from the RK
stages.  See
http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
for notation.  It should have size
s where s is the number of stages.
For the RK4 method, it should be
[1/6,1/3,1/3,1/6]</a:documentation>
                      <ref name="real_vector"/>
                    </element>
                  </element>
                  <element name="binary_search">
                    <a:documentation>Use binary search algorithm</a:documentation>
                    <empty/>
                  </element>
                </choice>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="log_output">
            <a:documentation>Options to create even more output in the logs:

Note that the main option to control the log output is given on the command line:

-v0  only output error and warnings

-v1  also give "navigational information", to indicate where in the code we currently are

-v2  also give any additional information (mins and maxes of fields, etc.)
</a:documentation>
            <optional>
              <element name="memory_diagnostics">
                <a:documentation>Log all allocates and deallocates done for meshes, fields, sparsities and matrices.

NOTE: Requires -v2</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="Mesh_Diagnostics_Angles">
            <a:documentation>Printout the number of elements and percentage that contain an angle
equal or bigger than the ones specified here
Note: This may slow down your simulation should be used as a diagnostic tool</a:documentation>
            <ref name="real_vector"/>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <element name="adaptive_timestep">
            <a:documentation>Vary the timestep according to the courant number.</a:documentation>
            <element name="requested_cfl">
              <a:documentation>The timestep will be adjusted (within the tolerance
and bounds specified) to target this courant
number. Timestep adapts occur at the end of each
timestep and after a mesh adapt.</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="requested_cfl_pressure">
                <a:documentation>Multiplier of the requested CFL based on which the pressure and velocity fields
will be recalculated. Otherwise, the pressure will not be updated.</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
            <ref name="timestep_cfl_number_options"/>
            <optional>
              <element name="minimum_timestep">
                <a:documentation>Minimum time step size.
Manual suggests 0.0</a:documentation>
                <optional>
                  <element name="dump_vtu_if_reached">
                    <a:documentation>If enabled, signals model dump if a timestep less
than or equal to the minimum_timestep is requested.</a:documentation>
                    <optional>
                      <element name="terminate">
                        <a:documentation>If enabled, signals model termination if a timestep less
than or equal to the minimum_timestep is requested. The
model will stop at the end of the timestep in order to
allow for the latest output to be written.</a:documentation>
                        <ref name="comment"/>
                      </element>
                    </optional>
                    <ref name="comment"/>
                  </element>
                </optional>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="maximum_timestep">
                <a:documentation>Maximum time step size.
Manual suggests 1.E+10</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="increase_tolerance">
                <a:documentation>The maximum ratio by which the timestep is allowed
to increase in a timestep adapt. e.g., a value of
1.1 indicates that the timestep may be increased by
at most 10%.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="at_first_timestep">
                <a:documentation>Specify whether you want to calculate a new timestep
at the first timestep or not.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <optional>
        <ref name="physical_parameter_options"/>
      </optional>
      <oneOrMore>
        <element name="material_phase">
          <a:documentation>The material or phase options</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <element name="is_multiphase_component">
              <a:documentation>Specify whether this phase is actually a component</a:documentation>
              <element name="alpha_beta">
                <a:documentation>Specify the weighting for the component equation
between 0 and 1. Test cases have 1.</a:documentation>
                <ref name="real"/>
              </element>
              <optional>
                <element name="KComp_Sigmoid">
                  <a:documentation>Enable this option to use sigmoid method for finding equilibrium</a:documentation>
                  <element name="K_Comp">
                    <a:documentation>KComp value for this component</a:documentation>
                    <ref name="real"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="Comp_Sum2One">
                  <a:documentation>Enable this option to force component mass fractions
to sum to 1 by adding constraint into compositional source term.</a:documentation>
                  <element name="Relaxation_Coefficient">
                    <a:documentation>Relaxation coefficient to summation constraint [0,1].
--&gt; 0: under-relaxation ; --&gt; 1: over-relaxation</a:documentation>
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="Ensure_Positive">
                      <a:documentation>Ensure that this constraint acts only as a positive absorption term</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="Enforce_Comp_Sum2One">
                      <a:documentation>Explicitly enforce components to sum to one</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="surface_tension">
                  <a:documentation>Surface tension</a:documentation>
                  <element name="coefficient">
                    <a:documentation>Surface tension coefficient.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="angle">
                      <a:documentation>Contact angle.</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="smooth">
                      <a:documentation> Smoothing.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="linearise_component">
                  <a:documentation>Linearises a P2 field. Use this if having stability issues with high-order discretisations</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <ref name="phase_properties_options">
            <a:documentation>Options to provide properties of the fluid for the given phase.</a:documentation>
          </ref>
          <optional>
            <element name="scalar_field">
              <a:documentation>Pressure</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_pressure_field"/>
                </element>
                <element name="prescribed">
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="diagnostic">
                  <a:documentation>Compute pressure from Density and InternalEnergy
via a compressible equation of state.</a:documentation>
                  <!-- mesh choice with PressureMesh as first option -->
                  <ref name="pressure_mesh_choice"/>
                  <ref name="internal_algorithm"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Pressure</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_velocity_field"/>
              </element>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="diagnostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="vector_python_diagnostic_algorithm"/>
                <ref name="diagnostic_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
          <optional>
            <element name="multiphase_properties">
              <a:documentation>Parameters required to model multiphase flow</a:documentation>
              <optional>
                <element name="Relperm_Corey">
                  <a:documentation>Option for relperm type in prototype code
Corey relperm:

relperm = relperm_max * ((Sat-S_immobile)/(1-Sum(Immobile_saturations)))^relperm_exponent</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Relative permeability end point

Value between 0 and 1. Default value 1.0</a:documentation>
                    <attribute name="name">
                      <value>relperm_max</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Relative permeability exponent

Default value 2.0</a:documentation>
                    <attribute name="name">
                      <value>relperm_exponent</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="capillary_pressure">
                  <a:documentation>Option for capillary pressure</a:documentation>
                  <optional>
                    <element name="type_Brooks_Corey">
                      <a:documentation>Brooks-Corey equation

Pc = c * ((S_w-Swir)/(1-Swirr-Sor)) ** -a; here c is the entry pressure

For imbibition swith the formula is:

## Pc = c * ( ((S_w-Swir)/(1-Swirr-Sor)) ** -a ) - B; here c - B is the entry pressure

You should specify this ONLY for the wetting phase</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Entry pressure of the formula</a:documentation>
                        <attribute name="name">
                          <value>C</value>
                        </attribute>
                        <element name="prescribed">
                          <ref name="material_mesh_choice"/>
                          <ref name="prescribed_scalar_field"/>
                        </element>
                      </element>
                      <optional>
                        <element name="scalar_field">
                          <a:documentation>Imbibition term. if on, entry pressure = C - B;
By default this value is set to zero.</a:documentation>
                          <attribute name="name">
                            <value>B</value>
                          </attribute>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                        </element>
                      </optional>
                      <element name="scalar_field">
                        <a:documentation>exponent -a</a:documentation>
                        <attribute name="name">
                          <value>a</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="type_Power_Law">
                      <a:documentation>Power Law equation

Pc = c*(1-s_eff)**a

where s_eff = (S_w-Swir)/(1-Swir-Sor)

c = maximum pc pressure; a = pc exponent

(no entry pressure)

ONLY specify for the wetting phase</a:documentation>
                      <element name="scalar_field">
                        <a:documentation>Maximum pressure</a:documentation>
                        <attribute name="name">
                          <value>C</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                      <element name="scalar_field">
                        <a:documentation>exponent a</a:documentation>
                        <attribute name="name">
                          <value>a</value>
                        </attribute>
                        <choice>
                          <element name="prescribed">
                            <ref name="material_mesh_choice"/>
                            <ref name="prescribed_scalar_field"/>
                          </element>
                          <element name="aliased">
                            <ref name="generic_aliased_field"/>
                          </element>
                        </choice>
                      </element>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="immobile_fraction">
                  <a:documentation>Immobile volume of fluid phase</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Immobile fraction</a:documentation>
                    <attribute name="name">
                      <value>value</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                  </element>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </oneOrMore>
      <optional>
        <ref name="mesh_adaptivity_options"/>
      </optional>
      <optional>
        <element name="porous_media">
          <a:documentation>Porous Media</a:documentation>
          <element name="scalar_field">
            <a:documentation>Specify scalar field Porosity</a:documentation>
            <attribute name="name">
              <value>Porosity</value>
            </attribute>
            <choice>
              <element name="prescribed">
                <ref name="material_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
              <element name="aliased">
                <ref name="generic_aliased_field"/>
              </element>
            </choice>
          </element>
          <choice>
            <a:documentation>Specify field Permeability</a:documentation>
            <element name="scalar_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="diagnostic">
                  <ref name="material_mesh_choice"/>
                  <ref name="scalar_python_diagnostic_algorithm"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
              </choice>
            </element>
            <element name="vector_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_vector_field"/>
                </element>
                <element name="diagnostic">
                  <ref name="material_mesh_choice"/>
                  <ref name="vector_python_diagnostic_algorithm"/>
                  <ref name="diagnostic_vector_field"/>
                </element>
              </choice>
            </element>
            <element name="tensor_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_tensor_field"/>
                </element>
                <element name="diagnostic">
                  <ref name="material_mesh_choice"/>
                  <ref name="tensor_python_diagnostic_algorithm"/>
                  <ref name="diagnostic_tensor_field"/>
                </element>
              </choice>
            </element>
          </choice>
          <optional>
            <element name="Dispersion">
              <a:documentation>Specify scalar field Longitudinal Dispersivity</a:documentation>
              <element name="scalar_field">
                <attribute name="name">
                  <value>Longitudinal_Dispersivity</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="material_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <optional>
                <element name="scalar_field">
                  <attribute name="name">
                    <value>Transverse_Dispersivity</value>
                  </attribute>
                  <choice>
                    <element name="prescribed">
                      <ref name="material_mesh_choice"/>
                      <ref name="prescribed_scalar_field"/>
                    </element>
                    <element name="aliased">
                      <ref name="generic_aliased_field"/>
                    </element>
                  </choice>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="thermal_porous">
              <a:documentation>Parameters for thermal porous media simulations</a:documentation>
              <element name="scalar_field">
                <a:documentation>Specify scalar field density of the porous media</a:documentation>
                <attribute name="name">
                  <value>porous_density</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="material_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="scalar_field">
                <a:documentation>Specify scalar field heat capacity of the porous media</a:documentation>
                <attribute name="name">
                  <value>porous_heat_capacity</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="material_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="tensor_field">
                <a:documentation>Specify field Thermal conductivity of the porous media</a:documentation>
                <attribute name="name">
                  <value>porous_thermal_conductivity</value>
                </attribute>
                <element name="prescribed">
                  <ref name="material_mesh_choice"/>
                  <ref name="prescribed_tensor_field"/>
                </element>
              </element>
            </element>
          </optional>
          <optional>
            <element name="wells_and_pipes">
              <a:documentation>Options to specify the wells/pipes</a:documentation>
              <element name="scalar_field">
                <a:documentation>Option to define laterals from diamond
if in doubt set it to 1.</a:documentation>
                <attribute name="name">
                  <value>Pipe</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="material_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="diagnostic">
                    <ref name="vector_python_diagnostic_algorithm"/>
                    <ref name="diagnostic_scalar_field_no_adapt"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="scalar_field">
                <a:documentation>Specify where and how much the well/pipes are opened
It goes from 0 to 1. If completely opened, set it to 1.</a:documentation>
                <attribute name="name">
                  <value>Gamma</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="pressure_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="diagnostic">
                    <ref name="vector_python_diagnostic_algorithm"/>
                    <ref name="diagnostic_scalar_field_no_adapt"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="scalar_field">
                <a:documentation>Absorption in the pipes.
If none, set it to 1.

Recommended. set to 1 and/or use the internal method based on the Moody diagram that can be selected in
/wells_and_pipes/well_options/calculate_sigma_pipe</a:documentation>
                <attribute name="name">
                  <value>Sigma</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="subcv_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="diagnostic">
                    <ref name="vector_python_diagnostic_algorithm"/>
                    <ref name="diagnostic_scalar_field_no_adapt"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <element name="scalar_field">
                <a:documentation>Specify the diameter of the pipe.
This effectively defines where and where not there is a pipe.
If the diameter is &lt;=0 no pipe, else there is pipe.</a:documentation>
                <attribute name="name">
                  <value>DiameterPipe</value>
                </attribute>
                <choice>
                  <element name="prescribed">
                    <ref name="pressure_mesh_choice"/>
                    <ref name="prescribed_scalar_field"/>
                  </element>
                  <element name="diagnostic">
                    <ref name="vector_python_diagnostic_algorithm"/>
                    <ref name="diagnostic_scalar_field_no_adapt"/>
                  </element>
                  <element name="aliased">
                    <ref name="generic_aliased_field"/>
                  </element>
                </choice>
              </element>
              <optional>
                <element name="thermal_well_properties">
                  <a:documentation>Specify thermal well-related options</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Specify the conductivity of the well/pipe material.
If there are several layers this, it has to be the equivalent conductivity from inside the well/pipe to
the reservoir.
This is only required for heat transport</a:documentation>
                    <attribute name="name">
                      <value>Conductivity</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="pressure_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="vector_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Specify the thickness of the well/pipe.
If there are several layers this, it has to be the equivalent thiness from inside the well/pipe to
the reservoir.
This is only required for heat transport</a:documentation>
                    <attribute name="name">
                      <value>well_thickness</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="pressure_mesh_choice"/>
                        <ref name="prescribed_scalar_field"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="vector_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="well_options">
                  <a:documentation>Specify well-related options</a:documentation>
                  <optional>
                    <element name="calculate_sigma_pipe">
                      <a:documentation>Calculate the well \sigma field internally
using a non-linear friction factor.
This will over-write the field specified in Sigma1.</a:documentation>
                      <optional>
                        <!-- Defaults to 1.0e-6. -->
                        <element name="pipe_roughness">
                          <ref name="real"/>
                        </element>
                      </optional>
                    </element>
                  </optional>
                  <optional>
                    <element name="dumping_well_factor">
                      <a:documentation>(ONLY FOR CONSERVATIVE FORMULATIONS) This term is used to control a combination of implicit/explicit implementation in this way:
(1 + dumping_well_factor) Implicit - dumping_well_factor (Explicit)

Values above 0 imply that explicit is used to dump the effect of the implicit term (which may be unstable);

A Value of 0 =&gt; Fully implicit; A Value of -1 implies only Explicit

Recommended values are 0.0 (Fully implicit), 0.25 or 0.5 (Some dumping but primarily implicit)
By default this is 0.5                   </a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="dt_pipe_factor">
                      <a:documentation>Factor by which to reduce the pipe eqns time step size e.g. 10^{-3}</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="switch_wells_on_and_off">
                      <a:documentation>Switches wells on and off to optimise production</a:documentation>
                      <element name="phase_exclude">
                        <ref name="integer"/>
                      </element>
                    </element>
                  </optional>
                  <optional>
                    <element name="wells_bdf_tolerance">
                      <a:documentation>If when using mesh adaptivity the well path is disappearing, this tolerance can probably solve the problem.
.bdf files have only 6 digits precision, therefore for coordinates bigger than 1000 this values might need to be reduced and
the other way round for values below 100.
The default value is 1e-2.</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="well_volume_ids">
                  <a:documentation>When using mesh adaptivity, introduce here the ids of the prisms of the wells to ensure
that the well trajectories are preserved.

***This is MANDATORY when using files to define wells***</a:documentation>
                  <ref name="integer_vector"/>
                  <optional>
                    <element name="Show_well_volumes_ids">
                      <a:documentation>Output the ids of the wells</a:documentation>
                      <ref name="comment"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <zeroOrMore>
                <element name="well_from_file">
                  <a:documentation>Introduce here the relative path to the file defining a 1D well
Note that the only accepted file format is NASTRAN, i.e. .bdf.
Each file has to describe a continuous well touching an external boundary.

***Well_volume_ids option is MANDATORY when using this method to define wells.***</a:documentation>
                  <attribute name="name">
                    <data type="string" datatypeLibrary=""/>
                  </attribute>
                  <attribute name="file_path">
                    <data type="string" datatypeLibrary=""/>
                  </attribute>
                </element>
              </zeroOrMore>
            </element>
          </optional>
          <optional>
            <element name="FWL">
              <a:documentation>Multiphase Initialisation: Free water level is the height (m) where Pc=0, water saturation below this will be at residual oil.

This is used to initialise the porous media model, defining the initial saturation and pressure. Currently for two-phase models.

The following must be specified:

- Densities of water (phase 1) and oil (phase 2)

- Gravity

- Capillary pressure curve</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="femdem_fracture">
          <a:documentation>Fracking options</a:documentation>
          <optional>
            <element name="femdem_file">
              <a:documentation>Specify FEMDEM input file</a:documentation>
              <attribute name="name">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
          <optional>
            <element name="oneway_coupling_only">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <choice>
                <value>1way</value>
                <value>p2way</value>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="include_pore_pressure">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="flooding">
          <a:documentation>Flooding parameters</a:documentation>
          <element name="scalar_field">
            <a:documentation>This is the term Nm of the manning formula:
b = Nm^2*g * |u|/h^1.33;
Nm is the manning coefficent. Values between [0.01 and 0.025];
Nm = 0.011 for smooth asphal and Nm = 0.024 to rubble.
For no friction set this to zero or do not activate it.</a:documentation>
            <attribute name="name">
              <value>manning_coef</value>
            </attribute>
            <element name="prescribed">
              <ref name="material_mesh_choice"/>
              <ref name="prescribed_scalar_field"/>
            </element>
          </element>
          <optional>
            <element name="averaging">
              <a:documentation>Perform the mean of the bathymetry when calculating the Manning formula;</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="shallow_drag">
              <a:documentation>Factor that controls the strenght of the drag introduced in the dry areas;
it has a simmilar effect as the artificial diffusion. Default value = 1e-1.</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="numerical_methods">
          <a:documentation>Advanced options that are kept for debugging purposes</a:documentation>
          <optional>
            <element name="do_not_bound_after_adapt">
              <a:documentation>Automatically after adapting the mesh and interpolating the fields a method to ensure boundeness of the field 
is run to guarantee physically plausible solutions. Nonetheless this may spread errors occurred during the interpolation 
that otherwise might have been cut off. Enable this option to avoid doing this operation.

This option is useful if your field is suddenly changing after adapting the mesh.</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="use_reflect_method">
              <a:documentation>Use a method to avoid distortion due to boundaries</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="local_upwinding">
              <a:documentation>Upwinding is used for the parts of the domain where there is no shock-front nor rarefaction.
Elsewhere a high-order advection scheme is used. This should increase the speed of the simulation.</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Use the row-sum method to create a lumped mass matrix.
For porous media this will not have an effect.
Also options to convert P1DG into P0DG and introduce the temporal terms into the mass matrix</a:documentation>
              <optional>
                <element name="lump_weight">
                  <a:documentation>For the CV pressure formulation this controls the homogenisation of the velocity nodes of per element
the bigger it is the more P0DG the element becomes. The default values have been obtained so the results are stable.
The default value for P1DGP1 =&gt; 1e4 and disabled for other element types.
To disable it manually, set it to negative values.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="get_all_in_mass_matrix">
                  <a:documentation>Introduce in the pivit matrix the temporal terms</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="no_matrix_store">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="lump_momentum_inertia">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="max_sat_its">
              <a:documentation>Impose a maximum number of iterations for the saturation non-linear solver within the non-linear solver
By default this number is 9. Recommended range: 3 to 9.</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
          <optional>
            <element name="solve_nphases_minus_one">
              <a:documentation>Decide to solve for nphases-1. This should be faster. Still in development.</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="porous_output_force_density">
              <a:documentation>For porous media only the Darcy velocity is outputed as the normal velocity is actually the force density
activate this to also output the force_density</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="create_P_mat_fast">
              <a:documentation>Use the fast method to create the pressure matrix. Be aware that some methods only work with the slow method</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </start>
  <define name="geometry">
    <element name="geometry">
      <a:documentation>Options dealing with the specification of geometry</a:documentation>
      <element name="dimension">
        <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
        <element name="integer_value">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <value>3</value>
            <value>2</value>
            <value>1</value>
          </choice>
        </element>
      </element>
      <element name="mesh">
        <a:documentation>The position mesh</a:documentation>
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <element name="simulation_quality">
        <a:documentation>Selects the quality configuration of the experiment
For Porous media the P1/P0 stands for P0, for inertia for P1.

Fast =&gt; Element pair = P1/P0DGP1(CV). Upwinding and implicit Euler;

Balanced (recommended) =&gt; Element pair = P1/P0DGP1(CV). High order advection scheme and adaptive theta;

Precision =&gt; Element pair = P1DGP2(CV). High order advection scheme and adaptive theta

Discontinuous_pressure =&gt; P1DG(BL)P1DG(CV). High order advection scheme and adaptive theta</a:documentation>
        <element name="string_value">
          <choice>
            <value>fast</value>
            <value>balanced</value>
            <value>precision</value>
            <value>discontinuous_pressure</value>
          </choice>
        </element>
      </element>
      <optional>
        <element name="Advance_options">
          <a:documentation>Settings to change the values specified in simulation_quality.
Only the activated options will overwrite the values decided in simulation_quality</a:documentation>
          <optional>
            <element name="mesh">
              <a:documentation>The velocity mesh</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
              <ref name="mesh_info"/>
            </element>
          </optional>
          <optional>
            <element name="mesh">
              <a:documentation>The pressure mesh</a:documentation>
              <attribute name="name">
                <value>PressureMesh</value>
              </attribute>
              <ref name="mesh_info"/>
            </element>
          </optional>
          <zeroOrMore>
            <element name="mesh">
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <ref name="mesh_info"/>
              <optional>
                <element name="exclude_from_mesh_adaptivity">
                  <empty/>
                </element>
              </optional>
            </element>
          </zeroOrMore>
          <zeroOrMore>
            <element name="Time_Discretisation">
              <a:documentation>Specify a different time discretisation method for different fields
You can use as inputs here: PhaseVolumeFraction, Velocity or Tracer.
Tracer accounts for Temperature, SoluteMassFraction, etc.</a:documentation>
              <attribute name="name">
                <a:documentation>Name of the Field</a:documentation>
                <data type="string"/>
              </attribute>
              <element name="Theta">
                <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit
 =-1. -- Automatic based on a NVD criterion.</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </zeroOrMore>
          <zeroOrMore>
            <element name="Space_Discretisation">
              <a:documentation>Specify a different flux calculation for different fields
You can use as inputs here: PhaseVolumeFraction or Tracer.
Tracer accounts for Temperature, SoluteMassFraction, etc.</a:documentation>
              <attribute name="name">
                <a:documentation>Name of the Field</a:documentation>
                <data type="string"/>
              </attribute>
              <element name="advection_scheme">
                <choice>
                  <element name="upwind">
                    <a:documentation>Straightforward upwinding of the nonlinear velocity.</a:documentation>
                    <empty/>
                  </element>
                  <element name="High_order">
                    <a:documentation>High order method based on a TVD criteria to ensure stability.</a:documentation>
                    <ref name="limiter_options"/>
                  </element>
                </choice>
              </element>
            </element>
          </zeroOrMore>
          <zeroOrMore>
            <element name="Conservative_formulation_settings">
              <a:documentation>Conservative discretisation options
Note that non-conservative does NOT mean that we do not conserve mass
For transport equations this is recommended to be zero.
For PhaseVolumeFraction the recommendation is one.

You can use as inputs here: PhaseVolumeFraction, Velocity or Tracer.
Tracer accounts for Temperature, SoluteMassFraction, etc.</a:documentation>
              <attribute name="name">
                <a:documentation>Name of the Field</a:documentation>
                <data type="string"/>
              </attribute>
              <element name="conservative_advection">
                <a:documentation> BETA=1. -- conservative (divergence form)
 BETA=0. -- non-conservative
 0. &lt; BETA &lt; 1.</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </zeroOrMore>
          <optional>
            <element name="FE_Pressure">
              <a:documentation>By default ICFERST uses a DCVFEM because it is more robust (Salinas et al. 2018),
nonetheless the classical CVFEM can also be used.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="create_binary_msh">
          <a:documentation>Use Fluidity to overwrite the input .msh file into a binary .msh file.

Useful to convert your ASCII msh files into binary to be able to decompose the mesh.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="solver_options">
    <element name="solver_options">
      <a:documentation>Options related to the linear and non-linear solvers.</a:documentation>
      <optional>
        <element name="Linear_solver">
          <a:documentation>Default Options for all the solvers</a:documentation>
          <ref name="advanced_solver_options_sym"/>
          <ref name="linear_solver_options_sym"/>
          <element name="Custom_solver_configuration">
            <optional>
              <element name="Pressure">
                <a:documentation>Options for pressure solver</a:documentation>
                <ref name="advanced_solver_options_sym"/>
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <optional>
              <element name="Velocity">
                <a:documentation>Options for velocity solver</a:documentation>
                <ref name="advanced_solver_options_asym"/>
                <ref name="linear_solver_options_asym"/>
              </element>
            </optional>
            <zeroOrMore>
              <element name="field">
                <a:documentation>Options for Transport solver</a:documentation>
                <attribute name="name">
                  <data type="string"/>
                </attribute>
                <ref name="advanced_solver_options_sym"/>
                <ref name="linear_solver_options_sym"/>
              </element>
            </zeroOrMore>
          </element>
        </element>
      </optional>
      <optional>
        <element name="Non_Linear_Solver">
          <a:documentation>Maximum number of non-linear iterations for the Fixed-Point iteration solver.

Manual suggests 2 for problems that are not very non-linear

If using Fixed_Point_Iteration for multiphase porous media flow the recommendation is ~ 20

If using Fixed_Point_Iteration/Infinite_norm_tol/adaptive_non_linear_iterations to dynamically control the number of
non-linear iterations or Fixed_Point_Iteration/adaptive_timestep_nonlinear then ~ 15 is recommended.</a:documentation>
          <ref name="integer"/>
          <optional>
            <element name="Fixed_Point_Iteration">
              <a:documentation>NOTE: For multiphase porous media only. Otherwise this value is ignored.

This is the convergence criterion for the Fixed Point Iteration solver.
The functional to compare is:

f = L2norm(S*-So)/L2norm(S1-So)

S* is the latest saturation; So is the saturation at the previous FPI
S1 is the saturation after the first FPI. Hence, the reduction of the difference
of saturation is tested

Recommended value: 5e-2</a:documentation>
              <ref name="real"/>
              <optional>
                <element name="Infinite_norm_tol">
                  <a:documentation>Tolerance for the infinite norm of the variation of the normalized selected field
between two consecutive non-linear iterations.

This can be used to control the number of non-linear interations dynamically.

By default 0.01, 0.03 is a good value to increase the speed of the simulations; Recommended between 0.05 and 0.005</a:documentation>
                  <ref name="real"/>
                  <optional>
                    <element name="adaptive_non_linear_iterations">
                      <a:documentation>Use the infinity norm of the selected field to control the number of non-linear interations dynamically.

A Variable to check has to be chosen:
1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature

The field selected in "adaptive_timestep_nonlinear" has preference over this</a:documentation>
                      <ref name="integer"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="Backtracking_factor">
                  <a:documentation>
Recommended settings: Non-linear iterations ~ 20
Backtracking_parameter = -10 automatically selection based on the Courant number, the shock-front Courant number and the physics of the problem

The Backtracking value introduced is used as reference, so it may have a big impact on the convergence

Recommended settings: Backtracking_parameter = -0.33 or -0.5 or -0.8;
Note: Dynamic dumping loops over the Saturation solver up to 9 times and also uses techniques to accelerate the FPI convergence

The more complex the problem is (i.e. bigger time-steps, gravity, capillary, etc) the smaller the value should be</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="Vanishing_relaxation">
                  <a:documentation>Introduce over-relaxation in the saturation equation.
This severely HELPS to reduce the number of FPI.

If positive, the input value is the entry pressure.

If negative, the input value is Peclet number desired.

Recommended value for Saturation =&gt; -1e2

Tip: If running with temperature and single phase disable this setting it to 0.</a:documentation>
                  <ref name="real"/>
                  <optional>
                    <element name="Vanishing_for_transport">
                      <a:documentation>This method can also be applied for a transport equation.

Recommended value for Temperature =&gt; -1e0</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="Impose_min_max">
                  <a:documentation>For TEMPERATURE ONLY, if there are no sources nor sinks
the non-linear solver can be accelerated by imposing physical constraints. Recommended to use.

This imposes that the temperature has to be between bounds.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="Test_mass_consv">
                  <a:documentation>Convergence criterion based on the
conservation of volume of each phase for the non-linear solver

By default the tolerance is 1e-2</a:documentation>
                  <ref name="real"/>
                  <optional>
                    <element name="stop_at_min_ts">
                      <a:documentation>Select this option if you want the simulation to terminate if after reaching the minimum time-step the non-linear solver fails to ensure mass convergence. Only works when adaptive time-step is on.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="adaptive_timestep_nonlinear">
                  <a:documentation>Adaptive timestep based on the number of non-linear iterations performed by the FPI solver.

A Variable to check has to be chosen:
1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature</a:documentation>
                  <ref name="integer"/>
                  <group>
                    <optional>
                      <element name="PID_controller">
                        <a:documentation>Time-step size controlled using a PID approach.
By default this method only controls the errors, and based on that increases or decreases the time-step size.
The default aim of number of FPI is the 20% of the maximum number of non-linear iterations.
The increase_factor and decrease_factor are multiplied by 1.2 to give more flexibility to the PID controller.

If this is off, a classical method based on the number of FPI performed is used instead.</a:documentation>
                        <empty/>
                        <optional>
                          <element name="Aim_num_FPI">
                            <a:documentation>Time-step size is controlled to try to always perform the specified number of FPI introduced here.
By default this is the 20% of the maximum number of non-linear iterations.</a:documentation>
                            <ref name="integer"/>
                          </element>
                        </optional>
                      </element>
                    </optional>
                    <optional>
                      <element name="ensure_solvers_convergence">
                        <a:documentation>If any of the solvers failt to achieve convergence the time-step size is
reduced and the time-level repeated without waiting to reach the maximum number of FPI.
Note: For the saturation for porous media it allows to diverge inside the saturation FPI.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="increase_threshold">
                        <a:documentation>Number of FPI below which the time-step size is increased
by default it is the 25% of the maximum allowed FPIs</a:documentation>
                        <ref name="integer"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="increase_factor">
                        <a:documentation>Multiply present timestep by this factor when increasing it.
By default 1.1</a:documentation>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="decrease_factor">
                        <a:documentation>Multiply present timestep by this factor when decreasing it.
By default 2.0</a:documentation>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="max_timestep">
                        <a:documentation>Maximum timestep. Beyond this value the timestep will not be increased.
By default unlimmited.</a:documentation>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="min_timestep">
                        <a:documentation>Minimum timestep. Beyond this value the timestep will not be decreased.
By default dt*1e-3.</a:documentation>
                        <ref name="real"/>
                      </element>
                    </optional>
                  </group>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_tensor_stat_options"/>
    <ref name="adaptivity_options_tensor_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
  </define>
  <define name="diagnostic_cv_gradient_vector_field">
    <optional>
      <element name="lump_mass_matrix">
        <a:documentation>Choose whether the mass matrix is lumped or not</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="solver">
        <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Normalise the gradient by its magnitude</a:documentation>
        <empty/>
      </element>
    </optional>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <define name="diagnostic_gradient_vector_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <define name="diagnostic_cv_divergence_scalar_field">
    <!-- No solver options because it can be solved directly! -->
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <define name="diagnostic_fe_divergence_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the normal direction
of the rotation matrix.
If off then fluidity computes the normal
If on the tangents vectors must also be specified.</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>specify first unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>specify second (if exists, i.e. if 3d) unit tangent vector to boundary</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <ref name="input_choice_real_bc_component"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>NOT USED - choose "dirichlet" instead for the cty bcs

This applies a Dirichlet condition through the continuity equation
and thus will only apply a normal component of this specified
velocity as the boundary condition.</a:documentation>
        <attribute name="name">
          <value>dirichlet_continuity</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>This applies a Dirichlet condition through the viscous terms in the
momentum equation. It will be applied to each of the components specified.</a:documentation>
        <attribute name="name">
          <value>dirichlet_viscosity</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>This applies a Dirichlet condition for the advection velocity
of the momentum equation.</a:documentation>
        <attribute name="name">
          <value>dirichlet_advection</value>
        </attribute>
        <element name="apply_weakly">
          <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
          <optional>
            <element name="boundary_overwrites_initial_condition">
              <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Add a bulk formulae boundary condition. Only makes sense
on the Velocity field.</a:documentation>
        <attribute name="name">
          <value>bulk_formulae</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
        <optional>
          <element name="surface_stabilisation">
            <a:documentation>This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far.
Note: Once activated, the stabilisation term will occur in all free surface areas in the domain.
IN DEVELOPMENT</a:documentation>
            <element name="scale_factor">
              <a:documentation>Scale factor for the surface stabilisation.</a:documentation>
              <ref name="real"/>
            </element>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <optional>
              <element name="manning-strickler">
                <a:documentation>Use the Manning-Strickler formulation:
n^2*g*|u|*u/H^(1/3)
where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.

The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air.

&lt;b&gt;Note that you have to specify
this density in the same units as the
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the
recommended (non-dimensional) value of 1.0 for
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a penalty function for the near wall region.
Using this option coarse meshes can
be used in the near wall region.

Should be used in combination with a no_normal_flow condition.

See Bazilevs et al. 2007</a:documentation>
        <attribute name="name">
          <value>near_wall_treatment</value>
        </attribute>
        <element name="tolerance">
          <ref name="real"/>
        </element>
        <optional>
          <element name="Cb">
            <a:documentation>if not set then Cb=2*h, where h is the element size</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Log law of the wall

Should be used in combination with a no_normal_flow condition.</a:documentation>
        <attribute name="name">
          <value>log_law_of_wall</value>
        </attribute>
        <element name="surface_roughness">
          <ref name="real"/>
        </element>
      </element>
      <element name="type">
        <a:documentation>Dummy BC

Should be used in combination with the near_wall_treatment condition.
When activated wall treatment is not applied on the wall-outflow edge.</a:documentation>
        <attribute name="name">
          <value>outflow</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Momentun BC
</a:documentation>
        <attribute name="name">
          <value>momentum</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Momentun BC
</a:documentation>
        <attribute name="name">
          <value>momentuminout</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
    </choice>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for tensor fields, with enabled by default -->
  <define name="tensor_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="tensor_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_velocity_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_velocity_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Diagnostic statistics for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_tensor_stat_options">
    <ref name="prognostic_tensor_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_velocity_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_velocity_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <optional>
          <element name="output_terms">
            <a:documentation>Enable to output the pressure and viscous terms separately (as well
as the total force)</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="divergence_stats">
        <a:documentation>Compute the divergence of this field at the Gauss points
and return its stats.  This is a direct measure of the
divergence at the gauss points rather than a discrete measure
at the nodes (provided by several other diagnostic fields).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="calculate_momentum_conservation_error">
        <a:documentation>Calculate the error in the conservation of momentum
IN PROGRESS - Does not include all terms!</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Combining of stat elements for tensor fields -->
  <define name="prognostic_tensor_stat_no_old_or_nonlinear_options.stat">
    <ref name="tensor_field_stat_options_enabled_default"/>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields,
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="pressure_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Mass Fraction of Solute</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SoluteMassFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction
Required in porous_media and multiphase problem types</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase1
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase1</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="phase_properties_options"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase2
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase2</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="phase_properties_options"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase3
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase

Do not forget to set boundary conditions for the PhaseVolumeFraction
even if the problem is one-phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase3</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="phase_properties_options"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ComponentMassFractionPhase4
Optional in multiphase problem types

attribute material_phase_name associates this
mass fraction with a particular phase</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ComponentMassFractionPhase4</value>
        </attribute>
        <attribute name="material_phase_name">
          <a:documentation>Specify the phase to which this component fraction relates</a:documentation>
          <data type="string"/>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="phase_properties_options"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="pressure_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="pressure_mesh_choice"/>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
        
                ## Prescribed scalar fields below this
                element ___Prescribed_fields_below___ {
                   empty
                }|
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.</a:documentation>
                <empty/>
              </element>
            </optional>
            <element name="solver">
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Dummy</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
                ## Prescribed vector fields below this
                element ___Prognostic_fields_below___ {
                   empty
                }|
      -->
      <!--
        - - List of fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
                ## Prescribed vector fields below this
                element ___Prescribed_fields_below___ {
                   empty
                }|
      -->
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="legacy_internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="nphase">
            <a:documentation>This option is used to specify a dimension different to ndim (typically number of phases), which is the default.
To be used only with the tensor name UAbsorB. Which is a tensor type used
to impose an absorption term for the momentum equation using a diagnostic tensor using python.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="limiter_options">
    <choice>
      <element name="Limiter_options">
        <a:documentation>Limit the face value to satisfy a boundedness criterion.
Only for tracer-type fields</a:documentation>
        <choice>
          <ref name="sweby_limiter"/>
          <ref name="compressive_advection_limiter"/>
          <ref name="ENO_advection"/>
        </choice>
      </element>
      <element name="do_not_limit_face_value">
        <a:documentation>Do not limit the face value</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="compressive_advection_limiter">
    <element name="limiter">
      <attribute name="name">
        <value>CompressiveAdvection</value>
      </attribute>
      <optional>
        <ref name="InterfaceCapturing_options"/>
      </optional>
    </element>
  </define>
  <define name="ENO_advection">
    <element name="limiter">
      <attribute name="name">
        <value>ENO</value>
      </attribute>
    </element>
  </define>
  <define name="InterfaceCapturing_options">
    <optional>
      <element name="value">
        <a:documentation>Controls the negative diffusion added to the interface
Defaults to full negative diffusion (= 1.0) if unselected</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes except periodic domains.</a:documentation>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins
e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins
and the fraction of the field in each bin with,
-1.5&lt;=field&lt;0.0, 0.0&lt;=field&lt;1.5, 1.5&lt;=field&lt;2.0, 2.0&lt;=field,
will be calculated.</a:documentation>
        <choice>
          <element name="constant">
            <a:documentation>list of bin bounds</a:documentation>
            <ref name="real_vector"/>
          </element>
          <element name="python">
            <a:documentation>Python function prescribing bin bounds. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value that should be an array of reals

</a:documentation>
            <ref name="python_code"/>
          </element>
        </choice>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="phase_viscosity">
    <element name="tensor_field">
      <attribute name="name">
        <value>Viscosity</value>
      </attribute>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <choice>
        <element name="prescribed">
          <optional>
            <ref name="velocity_mesh_choice"/>
          </optional>
          <ref name="prescribed_tensor_field_no_adapt"/>
        </element>
        <element name="diagnostic">
          <a:documentation>For electrical modelling only - holds electrical conductivity</a:documentation>
          <choice>
            <ref name="tensor_python_diagnostic_algorithm"/>
            <ref name="internal_algorithm"/>
          </choice>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_tensor_field"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="phase_density">
    <element name="Density">
      <a:documentation>Use this option to specify the density of fluids</a:documentation>
      <choice>
        <element name="incompressible">
          <a:documentation>Equations of state</a:documentation>
          <ref name="real"/>
        </element>
        <element name="compressible">
          <a:documentation>Equations of state for compressible applications</a:documentation>
          <choice>
            <element name="linear_in_pressure">
              <a:documentation>Linear in Pressure EOS

DEN = A * P + B

Use this option for flooding, being A = 1/gravity and B the bathymetry</a:documentation>
              <element name="coefficient_A">
                <ref name="real"/>
              </element>
              <element name="coefficient_B">
                <choice>
                  <element name="constant">
                    <a:documentation>list of bin bounds</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="python">
                    <a:documentation>Python function prescribing real input. Functions should be of the form:
   def val(X, t):
   # Function code
   return # Return value

   where X is a tuple of length geometry dimension.</a:documentation>
                    <ref name="python_code"/>
                  </element>
                </choice>
              </element>
              <optional>
                <element name="include_internal_energy">
                  <a:documentation>If chosen: DEN = A * P / T + B</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="stiffened_gas">
              <a:documentation>Stiffened Gas EoS

DEN = ( P + EOS_COEFS( 1 )) * EOS_COEFS( 2 ) / T

Note that setting EOS_COEFS( 1 ) = 0. and EOS_COEFS( 2 ) = 1/gas constant (Rd [J/kg/K])
The equation for ideal gases is obtained.</a:documentation>
              <element name="eos_option1">
                <ref name="real"/>
              </element>
              <element name="eos_option2">
                <ref name="real"/>
              </element>
              <optional>
                <element name="reference_density">
                  <a:documentation>reference uncompressed density

if activated then either Liquid EoS or
full Stiffened Gas EoS</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="ratio_specific_heats">
                  <a:documentation>Ratio of specific heats at constant
pressure to that at constant volume

Requires an energy field.
If activated then a full Stiffened Gas EoS</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="bulk_sound_speed_squared">
                  <a:documentation>bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density

if activated then either full or partial Liquid EoS or full
Stiffened Gas EoS</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <element name="exponential_in_pressure">
              <a:documentation>Exponential in Pressure EOS

DEN = A * P ^ B
</a:documentation>
              <element name="coefficient_A">
                <ref name="real"/>
              </element>
              <element name="coefficient_B">
                <ref name="real"/>
              </element>
            </element>
            <element name="concentration_dependant">
              <a:documentation>Concentration-dependant EOS

Temperature and concentration can be considered simultaneously with this equation which is the recommended for the Boussinesq approximation.

DEN = DEN0 * ( 1 + Alpha * C - Beta * (Temp -T0))

C is the solute mass concentration and DEN0 is the reference density corresponding to C = 0

Beta is the thermal expansion and a reference Temperature needs to be set.

Note: this equation can be used only with concentration, temperature or both simultaneously.</a:documentation>
              <element name="reference_density">
                <ref name="real"/>
              </element>
              <optional>
                <element name="alpha">
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="T0">
                  <a:documentation>Reference temperature (default 298)</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="beta">
                  <a:documentation>Thermal expansion (Kelvin^-1)</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <element name="Temperature_Pressure_correlation">
              <a:documentation>Temperature-Pressure correlation for liquids ONLY. With the Boussinesq approximation, only temperature
variation is considered.

Range of applicability: 0 to 2*10^9 Pa.

rho1 = rho0/(1+Beta(T1-T0))/(1-(P1-P0)/E)

where rho0 is the reference density at temperature T0 and pressure P0;

Beta is volumetric expansion coefficient (m^3/m^3 Celsius);

E is the liquid elasticity bulk modulus (N/m^2);

NOTE: if temperature is not defined the temperature is defined as zero.</a:documentation>
              <element name="rho0">
                <a:documentation>Reference density</a:documentation>
                <ref name="real"/>
              </element>
              <element name="T0">
                <a:documentation>Reference temperature</a:documentation>
                <ref name="real"/>
              </element>
              <element name="P0">
                <a:documentation>Reference Pressure</a:documentation>
                <ref name="real"/>
              </element>
              <element name="coefficient_Beta">
                <a:documentation>volumetric expansion coefficient (m^3/m^3 Celsius)</a:documentation>
                <ref name="real"/>
              </element>
              <element name="coefficient_E">
                <a:documentation>liquid elasticity bulk modulus (N/m^2)</a:documentation>
                <ref name="real"/>
              </element>
            </element>
          </choice>
          <optional>
            <element name="Boussinesq_approximation">
              <a:documentation>Use the boussinesq approximation. Useful for small variations of density.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="python_state">
          <a:documentation>The "Dummy" diagnotic field on the pressure mesh is required for this option</a:documentation>
          <ref name="scalar_python_diagnostic_algorithm"/>
        </element>
      </choice>
      <optional>
        <element name="linearise_density">
          <a:documentation>Linearises a P2 field. Use this if having stability issues with high-order discretisations</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="phase_properties_options">
    <element name="phase_properties">
      <a:documentation>Options to provide properties of the fluid for the given phase.
Component properties overwrite the ones given for a phase and are mandatory for all the components.</a:documentation>
      <ref name="phase_density">
        <a:documentation>Phase density</a:documentation>
      </ref>
      <element name="Viscosity">
        <a:documentation>Viscosity of the current phase (tensor field)</a:documentation>
        <ref name="phase_viscosity"/>
        <optional>
          <element name="linearise_viscosity">
            <a:documentation>Linearises a P2 field. Use this if having stability issues with high-order discretisations</a:documentation>
            <empty/>
          </element>
        </optional>
        <element name="viscosity_scheme">
          <choice>
            <element name="tensor_form">
              <a:documentation>Tensor form</a:documentation>
              <empty/>
            </element>
            <element name="stress_form">
              <a:documentation>Stress form</a:documentation>
              <empty/>
            </element>
            <element name="compact_discontinuous_galerkin">
              <a:documentation>Compact discontinuous Galerkin scheme.
(Peraire and Persson SIAM J. Sci. Comput. 30, p1806)</a:documentation>
              <optional>
                <element name="penalty_parameter">
                  <a:documentation>Penalty_parameter
Add penalty term Int [u][v] dS on element boundaries
scaled by C_0</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <element name="bassi_rebay">
              <a:documentation>Classical scheme from Bassi and Rebay
(JCP 131 267-179 1997)</a:documentation>
              <empty/>
            </element>
            <element name="arbitrary_upwind">
              <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
              <empty/>
            </element>
          </choice>
          <choice>
            <element name="nonlinear_scheme">
              <a:documentation>Non-linear scheme</a:documentation>
              <optional>
                <element name="beta_viscosity_min">
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="beta_viscosity_max">
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <element name="linear_scheme">
              <a:documentation>Linear scheme</a:documentation>
              <optional>
                <element name="high_order">
                  <empty/>
                </element>
              </optional>
            </element>
          </choice>
          <optional>
            <element name="zero_or_two_thirds">
              <a:documentation>defaults to 0.</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
        </element>
      </element>
      <optional>
        <element name="tensor_field">
          <a:documentation>Thermal conductivity (in S.I. watts per meter-kelvin =&gt; W/(m·K) ).</a:documentation>
          <attribute name="name">
            <value>Thermal_Conductivity</value>
          </attribute>
          <attribute name="rank">
            <value>2</value>
          </attribute>
          <choice>
            <element name="prescribed">
              <optional>
                <ref name="mesh_choice"/>
              </optional>
              <ref name="prescribed_tensor_field_no_adapt"/>
            </element>
            <element name="diagnostic">
              <a:documentation>For electrical modelling only - holds electrical conductivity</a:documentation>
              <choice>
                <ref name="tensor_python_diagnostic_algorithm"/>
                <ref name="internal_algorithm"/>
              </choice>
              <ref name="diagnostic_tensor_field"/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="scalar_field">
          <a:documentation>Specific heat capacity for field</a:documentation>
          <attribute name="name">
            <value>HeatCapacity</value>
          </attribute>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <element name="prescribed">
              <ref name="prescribed_scalar_field_no_adapt"/>
            </element>
            <element name="diagnostic">
              <a:documentation>This only works for traffic modelling</a:documentation>
              <choice>
                <ref name="scalar_python_diagnostic_algorithm"/>
                <ref name="internal_algorithm"/>
              </choice>
              <ref name="diagnostic_scalar_field_no_adapt"/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="tensor_field">
          <a:documentation>Solute diffusivity (in S.I. m^2/s ).</a:documentation>
          <attribute name="name">
            <value>Solute_Diffusivity</value>
          </attribute>
          <attribute name="rank">
            <value>2</value>
          </attribute>
          <choice>
            <element name="prescribed">
              <optional>
                <ref name="mesh_choice"/>
              </optional>
              <ref name="prescribed_tensor_field_no_adapt"/>
            </element>
            <element name="diagnostic">
              <a:documentation>For electrical modelling only - holds electrical conductivity</a:documentation>
              <choice>
                <ref name="tensor_python_diagnostic_algorithm"/>
                <ref name="internal_algorithm"/>
              </choice>
              <ref name="diagnostic_tensor_field"/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="Stabilisation">
          <a:documentation>Stabilisation for Inertia dominated flow.
LES and Petrov-Galerkin stabilisation are available.</a:documentation>
          <optional>
            <element name="les_model">
              <a:documentation>Usual LES modeling</a:documentation>
              <element name="model">
                <a:documentation>=0 No LES,
=1 Anisotropic element length scale,
=2 Take the average length scale h,
=3 Take the min length scale h,
=4 Take the max length scale h</a:documentation>
                <ref name="integer"/>
              </element>
              <optional>
                <element name="smagorinsky_coefficient">
                  <a:documentation>literature sybol: Cs

defaults to 0.1</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <choice>
                <element name="tensor_form">
                  <a:documentation>Tensor form</a:documentation>
                  <empty/>
                </element>
                <element name="stress_form">
                  <a:documentation>Stress form</a:documentation>
                  <empty/>
                </element>
              </choice>
              <optional>
                <element name="les_theta">
                  <a:documentation>defaults to 1.0</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="Petrov_Galerkin_stabilisation">
              <a:documentation>This applies a non-linear shock capturing scheme which
may be used to reduce oscillations in velocity or
perform implicit LES modelling of turbulence.</a:documentation>
              <element name="method">
                <a:documentation>What type of Petrov-Galerkin method to use:
=1 is the residual squared approach,
=2 is max(0, A . grad U * residual ),
=3 is the max of 1 and 2 (the most dissipative).</a:documentation>
                <ref name="integer"/>
              </element>
              <optional>
                <element name="nonlinear_velocity_coefficient">
                  <a:documentation>[0,1] is the magnitude of the non-linear dissipation.
=0.25 is small,
=1.0 is large.
Defaults to 1.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="include_pressure">
                  <a:documentation>[0,1] decides if we include the pressure term in A . grad soln if
=0.0 don't include pressure term,
=1.0 include the pressure term.
Defaults to 1.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <choice>
                <element name="tensor_form">
                  <a:documentation>Tensor form</a:documentation>
                  <empty/>
                </element>
                <element name="stress_form">
                  <a:documentation>Stress form</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </define>
</grammar>
