include "spud_base.rnc"

include "ICFERST_schemas/adaptivity_options_ICFERST.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "ICFERST_schemas/solvers_ICFERST.rnc"
include "stabilisation.rnc"
include "ICFERST_schemas/mesh_options_ICFERST.rnc"
include "ICFERST_schemas/physical_parameters_ICFERST.rnc"
include "ICFERST_schemas/prognostic_field_options_ICFERST.rnc"
include "prescribed_field_options.rnc"
include "spatial_discretisation.rnc"
include "temporal_discretisation.rnc"

start =
   (
      ## The root node of the options dictionary.
      element multiphase_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Select the simulation type
         element is_porous_media {
             empty
         },
         geometry,
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            },
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                (
                     element constant {
                     real
                   }|
                   ## Python function prescribing real input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )  
               }|                 
               ## Dump period, in timesteps.
               ## 
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                 (
                     element constant {
                     integer
                   }|
                   ## Python function prescribing integer input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )   
               }
            ),
            ## Output the Darcy velocity
            element output_darcy_vel {
               empty
            }?,
            ## If porous_media, printout the Courant number every time-step
            element Courant_number {
               comment
            }?,
            ## Printout the number of elements and percentage that contain an angle
            ## equal or bigger than the ones specified here
	        ## Note: This may slow down your simulation should be used as a diagnostic tool 
            element Mesh_Diagnostics_Angles {
               real_vector
            }?,
            ## Surface to Integrate Over
            element dump_boundaryflux {
            empty,
            ## Surface id:
            element surface_ids {
            integer_vector
            }}?,
	    ## Whether to enable dumping of checkpointing output.
            ##
            ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options
            element checkpointing {
               ## Checkpointing period, in dumps. Non-negative value
               ## required. A value of zero indicates that checkpoints
               ## should be created at every dump. If
               ## /io/max_dumpfile_count is exceeded then earlier
               ## checkpoints may be overwritten.
               element checkpoint_period_in_dumps {
                  integer
               },
               ## Enable to checkpoint at simulation start.
               element checkpoint_at_start {
                  comment
               }?,
               ## Enable to force a checkpoint at simulation end.
               element checkpoint_at_end {
                  comment
               }?,
               comment
            }?
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## maximum number of non-linear iterations.
            ## 
            ## Manual suggests 2
            ## 
            ## If using Fixed_Point_Iteration the recommendation is 25
			element nonlinear_iterations {
               integer,
               ## This is the convergence criterion for the Fixed Point Iteration solver.
               ## The functional to compare is: 
               ##
               ## f = L2norm(S*-So)/L2norm(S1-So)
               ##
               ## S* is the latest saturation; So is the saturation at the previous FPI
               ## S1 is the saturation after the first FPI. Hence, the reduction of the difference
               ## of saturation is tested
               ##
               ## Recommended value: 5e-2
               element Fixed_Point_Iteration{
                  real,
                  (
                    ## Prints the number of iterations and
                    ## the final convergence achieved by the FPI solver
                    element Show_Convergence{comment}?
                  ),
                  (
                    ## Adaptive timestep based on the number of non-linear iterations performed by the FPI solver.
                    ##
                    ## A Variable to check has to be chosen:
                    ## 1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (Default)
                    element adaptive_timestep_nonlinear{
                        integer,
                      (
                        ## Time-step size controlled using a PID approach.
                        ## By default this method only controls the errors, and based on that increases or decreases the time-step size.
                        ## The default aim of number of FPI is the 20% of the maximum number of non-linear iterations.
                        ## The increase_factor and decrease_factor are multiplied by 1.2 to give more flexibility to the PID controller.
                        ## 
                        ## If this is off, a classical method based on the number of FPI performed is used instead.
                        element PID_controller {
                          empty,
                            ## Time-step size is controlled to try to always perform the specified number of FPI introduced
                            ## here, but in a soft way so if the other checks are performing correctly it can still increase the time-step size. 
                            ## By default this is the 20% of the maximum number of non-linear iterations.
                            element Aim_num_FPI {
                              integer
                            }?
                        }?,
                        ## If any of the solvers failt to achieve convergence the time-step size is 
                        ## reduced and the time-level repeated without waiting to reach the maximum number of FPI.
                        ## Note: For the saturation for porous media it allows to diverge inside the saturation FPI.
                        element ensure_solvers_convergence {
                          empty
                        }?,
                        ## Number of FPI below which the time-step size is increased
                        ## by default it is the 25% of the maximum allowed FPIs
                        element increase_threshold{
                        integer
                        }?,
                        ## Multiply present timestep by this factor when increasing it.
                        ## By default 1.1
                        element increase_factor{
                        real
                        }?,
                        ## Multiply present timestep by this factor when decreasing it.
                        ## By default 2.0
                        element decrease_factor{
                        real
                        }?,
                        ## Maximum timestep. Beyond this value the timestep will not be increased.
                        ## By default unlimmited.
                        element max_timestep{
                        real
                        }?,
                        ## Minimum timestep. Beyond this value the timestep will not be decreased.
                        ## By default dt*1e-3.
                        element min_timestep{
                        real
                        }?
                      )
                    }?
                  )
               }?
            }?,
            ## Vary the timestep according to the courant number.
            element adaptive_timestep {
               ## The timestep will be adjusted (within the tolerance
               ## and bounds specified) to target this courant
               ## number. Timestep adapts occur at the end of each
               ## timestep and after a mesh adapt.
               element requested_cfl {
                  real
               },
               timestep_cfl_number_options,
               ## Minimum time step size.
               ## Manual suggests 0.0
               element minimum_timestep {
                  ## If enabled, signals model termination if a timestep less
                  ## than or equal to the minimum_timestep is requested. The
                  ## model will stop at the end of the timestep in order to
                  ## allow for the latest output to be written. 
                  element terminate_if_reached {
                     comment
                  }?,
                  real
               }?,
               ## Maximum time step size.
               ## Manual suggests 1.E+10
               element maximum_timestep {
                  real
               }?,
               ## The maximum ratio by which the timestep is allowed
               ## to increase in a timestep adapt. e.g., a value of
               ## 1.1 indicates that the timestep may be increased by
               ## at most 10%.
               element increase_tolerance {
                  real
               }?,
               ## Specify whether you want to calculate a new timestep
               ## at the first timestep or not.
               element at_first_timestep {
                  empty
               }?
            }?
         },
         physical_parameter_options?,
         ## The material or phase options
         element material_phase {
            attribute name { xsd:string },
            
            ## Phase density
            phase_density,

            ### ## Equation of State
            ###equation_of_state?,

            ## Pressure
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Pressure" },
               ## Field type
               (
                  element prognostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prognostic_pressure_field
                  }|
                  element prescribed {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prescribed_scalar_field
                  }|
                  ## Compute pressure from Density and InternalEnergy
                  ## via a compressible equation of state.
                  element diagnostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     internal_algorithm,
                     diagnostic_scalar_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Pressure" }
                  }
               )
            }?,
            ## Velocity vector and momentum options
            element vector_field {
               attribute rank { "1" },
               attribute name { "Velocity" },
               ## Field type
               (
                  element prognostic {
                     velocity_mesh_choice,
                     prognostic_velocity_field
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_vector_field
                  }|
                  element diagnostic {
                     velocity_mesh_choice,
                     vector_python_diagnostic_algorithm,
                     diagnostic_vector_field
                  }|                  
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Velocity" }
                  }
               )
            },
            scalar_field_choice*,
            vector_field_choice*,
            tensor_field_choice*,
            ## Parameters required to model multiphase flow
            element multiphase_properties {
               ## Option for relperm type in prototype code
                  ## Corey relperm:
                  ##
                  ## relperm = relperm_max * ((Sat-S_immobile)/(1-Sum(Immobile_saturations)))^relperm_exponent
               element Relperm_Corey {
                     ## Relative permeability end point
                     ##
                     ## Value between 0 and 1. Default value 1.0
                 element relperm_max {
                 ## End-point relative permeability
                    element scalar_field {
                       attribute name { "relperm_max" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }
                       )
                    }
                 }?,
                     ## Relative permeability exponent
                     ##
                     ## Default value 2.0
                 element relperm_exponent {
                 ## Exponent of the formula
                     element scalar_field {
                        attribute name { "relperm_exponent" },
                        (
                           element prescribed {
                              material_mesh_choice,
                              prescribed_scalar_field
                  }
                        )
                     }
                }?
                }?,	      
               ## Option for capillary pressure				 
               element capillary_pressure {
            ## Non-consistent implementation of the capillary pressure, increases the stability of the method and allows bigger time-steps, use only when capillary affects are not dominant. 
            ## The capillary pressure term is introduced only in the saturation equation, acting as a pure diffusive term. 
            element Diffusive_cap_only { comment }?,
                  ## Brooks-Corey equation
                  ##
                  ## Pc = c * ((S_w-Swir)/(1-Swirr-Sor)) ** -a
                  ## You should specify this ONLY for the wetting phase
                  element type_Brooks_Corey {
                    ## Entry pressure of the formula
                    element scalar_field {
                       attribute name { "C" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    },
                    ## exponent -a
                    element scalar_field {
                       attribute name { "a" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }}?,
                  ## Implements capillary pressure curve of Jaure et. al (http://dx.doi.org/10.2118/172989-MS)
                  element type_TOTALCapillary {
                    ## Overall coefficient scaling the capillary pressure
                    element scalar_field {
                       attribute name { "C" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    },
                    ## Exponent in the capillary pressure formula
                    element scalar_field {
                       attribute name { "a" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }}?
               }?,
               ## Immobile volume of fluid phase
               element immobile_fraction {
               ## Immobile fraction
                    element scalar_field {
                       attribute name { "value" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }
                       )
                    }
               }?,
               ## Introduce over-relaxation in the saturation equation. 
               ## This severely HELPS to increase the convergence rate of the FPI solver.
               ## You MUST specify this ONLY for the wetting phase.
               ##
               ## If positive, the input value is the entry pressure.
               ##
               ## If negative, the input value is Peclet number desired.
               ##
               ## Recommended value => -1e1
               ##
               ## Tip: if Diffusive_cap_only is activated Sat_overRelax is ignored.
               element Sat_overRelax {real}?
            }?
         }+,
         mesh_adaptivity_options?,
         ## Porous Media
         element porous_media {
            ## Specify scalar field Porosity
            element scalar_field {
               attribute name { "Porosity" },
               (
                  element prescribed {
                     material_mesh_choice,
                     prescribed_scalar_field
                  }|
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify field Permeability
            (
               element scalar_field {
                  attribute name { "Permeability" },
                  (
                     element prescribed {
                        material_mesh_choice,
                        prescribed_scalar_field
                     }|
                     element aliased {
                        generic_aliased_field
                     }
                  )
               }|
               element vector_field {
                  attribute name { "Permeability" },
                  element prescribed {
                     material_mesh_choice,
                     prescribed_vector_field
                  }
               }|
               element tensor_field {
                  attribute name { "Permeability" },
                  element prescribed { 
                     material_mesh_choice,
                     prescribed_tensor_field
                  }
               }|
               element Permeability_from_femdem {
                  attribute name { xsd:string },
                  element background_permeability { real }
               }
            ),
            ## Specify well-related options
            element well_options {
               ## Calculate the well \sigma field internally
               ## using a non-linear friction factor.
               ## This will over-write the field specified in Sigma1.
               element calculate_sigma_pipe{
                  # Defaults to 1.0e-6.
                  element pipe_roughness{ real }?
               }?,
               ## Factor by which to reduce the pipe eqns time step size e.g. 10^{-3}
               element dt_pipe_factor{ real }?,
               ## Switches wells on and off to optimise production
               element switch_wells_on_and_off{
                  element phase_exclude{ integer }
               }?
            }?
         }?
      }
   )


geometry = 
   (
      ## Options dealing with the specification of geometry
      element geometry {
         ## Dimension of the problem.
         ## <b>This can only be set once</b>
         element dimension {
            element integer_value {
               attribute rank {"0"},
               ("3"|"2"|"1")
            }
         },
         ## The position mesh
         element mesh {
            attribute name { "CoordinateMesh" },
            mesh_info
         },

           ## Selects the quality configuration of the experiment
           ##
           ## Fast => Element pair = P0DGP1CV. Upwinding and implicit Euler; 
           ##
           ## Balanced (recommended) => Element pair = P0DGP1CV. Local decision whether upwinding or high order advection scheme and adaptive theta; 
           ##
           ## Precision => Element pair = P1DGP2CV. High order advection scheme and adaptive theta
           ##
           ## discontinuous_pressure => P2DGP1DG. High order advection scheme and adaptive theta
            element simulation_quality {
              element string_value{
                 "fast" | "balanced" | "precision"|"discontinuous_pressure"
              }
            },
        ## Use Fluidity to overwrite the input .msh file into a binary .msh file. 
        ##
        ## Useful to convert your ASCII msh files into binary to be able to decompose the mesh.
        element create_binary_msh {
           empty
        }? 
      }
   )


# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?,
      interpolation_algorithm_scalar?
   )
   
# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_scalar_stat_options,
      diagnostic_detector_options
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_vector_stat_options,
      vector_convergence_options,      
      diagnostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_vector_field,
      recalculation_options?,
      interpolation_algorithm_vector?
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_tensor_stat_options,
      adaptivity_options_tensor_field,
      interpolation_algorithm_vector?
   )

diagnostic_cv_gradient_vector_field =
   (
      ## Choose whether the mass matrix is lumped or not
      element lump_mass_matrix {
            empty
      }?,
      ## Solver options are necessary if you're not lumping your mass or if you're field isn't dg
      element solver {
         linear_solver_options_sym
      }?,
      ## Normalise the gradient by its magnitude
      element normalise {
        empty
      }?,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_gradient_vector_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_cv_divergence_scalar_field =
   (
      # No solver options because it can be solved directly!
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

diagnostic_fe_divergence_scalar_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

# three optional input vectors for user-specified rotation matrix
rotation_matrix_components =
   (
      ## Select if you want to specify the normal direction
      ## of the rotation matrix.
      ## If off then fluidity computes the normal
      ## If on the tangents vectors must also be specified.
      element normal_direction {
         input_choice_real_dim_vector
      }?,
      ## specify first unit tangent vector to boundary
      element tangent_direction_1 {
         input_choice_real_dim_vector
      }?,
      ## specify second (if exists, i.e. if 3d) unit tangent vector to boundary
      element tangent_direction_2 {
         input_choice_real_dim_vector
      }?
   )

velocity_components_choice =
   (
      (
         element align_bc_with_surface {
            element normal_component {
               input_choice_real
            }?,
            element tangent_component_1 {
               input_choice_real
            }?,
            element tangent_component_2 {
               input_choice_real
            }?,
            rotation_matrix_components,
            ## this will calculate the determinant of the
            ## rotation matrix for every boundary node
            ## and dump a vtu with the node 
            ## normals and tangenials 1/2
            element debugging_mode{empty}?
         }|
         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## NOT USED - choose "dirichlet" instead for the cty bcs
         ##
         ## This applies a Dirichlet condition through the continuity equation
         ## and thus will only apply a normal component of this specified
         ## velocity as the boundary condition.
         element type {
            attribute name { "dirichlet_continuity" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## This applies a Dirichlet condition through the viscous terms in the
         ## momentum equation. It will be applied to each of the components specified.
         element type {
            attribute name { "dirichlet_viscosity" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## This applies a Dirichlet condition for the advection velocity
         ## of the momentum equation.
         element type {
            attribute name { "dirichlet_advection" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         ## Add a bulk formulae boundary condition. Only makes sense
         ## on the Velocity field.
         element type {
            attribute name { "bulk_formulae" },
               empty
         }|
         element type {
           attribute name { "free_surface" },
           (
              ## This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far. 
              ## Note: Once activated, the stabilisation term will occur in all free surface areas in the domain. 
              ## IN DEVELOPMENT
              element surface_stabilisation {
                  ## Scale factor for the surface stabilisation.
                  element scale_factor{
                    real
                  }
              }?
           )
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                ## Use the Manning-Strickler formulation:
                ## n^2*g*|u|*u/H^(1/3)
                ## where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.
                ##
                ## The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)
                element manning-strickler {
                   empty
                }?
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|


         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density 
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air. 
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the 
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the 
                  ## recommended (non-dimensional) value of 1.0 for 
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real},
            ## if not set then Cb=2*h, where h is the element size
            element Cb {real}?
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }|
         ## Dummy BC
         ##
         ## Should be used in combination with the near_wall_treatment condition.
         ## When activated wall treatment is not applied on the wall-outflow edge.
         element type{
            attribute name { "outflow" }
         }|
         ## Momentun BC
         ##
         element type{
            attribute name { "momentum" },
            velocity_components_choice
         }|
         ## Momentun BC
         ##
         element type{
            attribute name { "momentuminout" },
            velocity_components_choice
         }
      )
   )
   
   
# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options = 
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )
  
# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat
         
      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat = 
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )   
   
# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_enabled_default = include_stat
tensor_field_stat_options_enabled_default |= exclude_components_from_stat
tensor_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_disabled_default = exclude_stat
tensor_field_stat_options_disabled_default |= exclude_components_from_stat
tensor_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_velocity_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_velocity_stat_options.stat
         )
      }      
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Diagnostic statistics for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_tensor_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options
prescribed_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_velocity_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_velocity_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         ## Enable to output the pressure and viscous terms separately (as well
         ## as the total force)
         element output_terms {
            comment
         }?,
         integer_vector
      }?,
      ## Compute the divergence of this field at the Gauss points
      ## and return its stats.  This is a direct measure of the
      ## divergence at the gauss points rather than a discrete measure
      ## at the nodes (provided by several other diagnostic fields).
      element divergence_stats {
        empty
      }?,
      ## Calculate the error in the conservation of momentum
      ## IN PROGRESS - Does not include all terms!
      element calculate_momentum_conservation_error {
         empty
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Combining of stat elements for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options.stat =
   (
      tensor_field_stat_options_enabled_default
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields, 
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  pressure_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  pressure_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that FLUIDITY knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.
         
         ## Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Temperature" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CopiedField - This field copies the previous timesteps
         ## values from another (specified) field at every iteration
         ## and then solves the field using different (again, specified)
         ## scheme and solution options.
         ## For instance, this field can be used to create a diffused
         ## field to adapt to.
         ## Unless someone requests otherwise this is only currently possible
         ## for fields within the same material_phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopiedField" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  attribute copy_from_field { string },
                  prognostic_scalar_field
               }
            )
         }|         
         ## PhaseVolumeFraction
         ## Required in porous_media and multiphase problem types
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFraction" },
            (
               element prognostic {
                  pressure_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt
               }
            )
         }|
         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }
         
# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.
#
#         ## Prescribed scalar fields below this
#         element ___Prescribed_fields_below___ {
#            empty
#         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "Dummy" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }
# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
#         ## Prescribed vector fields below this
#         element ___Prognostic_fields_below___ {
#            empty
#         }|

# -- List of fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
#         ## Prescribed vector fields below this
#         element ___Prescribed_fields_below___ {
#            empty
#         }|

#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,                  
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }


# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )  

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  tensor_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_tensor_field
               }
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }

# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

limiter_options =
  (
      (
        ## Limit the face value to satisfy a boundedness criterion.
        element limit_face_value{
          (
            sweby_limiter|
            ultimate_limiter|
	    extrema_limiter|
            compressive_advection_limiter|
            ENO_advection
          )
        }|
        ## Do not limit the face value
        element do_not_limit_face_value{
          empty
        }
      )
  )

sweby_limiter = 
  ## See "High-Resolution Schemes Using Flux Limiters for
  ## Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
  ## Journal on Numerical Analysis, 21, 995-1011
  element limiter {
    attribute name {"Sweby"},
    slope_options?,
    upwind_value_options?
  }

ultimate_limiter =
  ## See "The Ultimate Conservative Difference Scheme Applied
  ## to Unsteady One-Dimensional Advection", B. P. Leonard,
  ## 1991, Computer Methods in Applied Mechanics and
  ## Engineering, 88, 17-74
  element limiter {
    attribute name {"Ultimate"},
    field_based_cfl_number_options,
    upwind_value_options?
  }

extrema_limiter = 
  element limiter {
    attribute name {"Extrema"}
  }

compressive_advection_limiter = 
  element limiter {
    attribute name {"CompressiveAdvection"}
  }

ENO_advection = 
  element limiter {
    attribute name {"ENO"}
  }


slope_options =
   (
      ## Control the upper and lower slopes of the NVD limiter
      element slopes {
         ## Defaults to Sweby, 1984 limiter (= 1.0) if unselected
         element lower {
            real
         }?,
         ## Defaults to Sweby, 1984 limiter (= 2.0) if unselected
         element upper {
            real
         }?
      }
   )

upwind_value_options =
   (
      (
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## This method projects the upwind value from a point in the element just
         ## upwind of the node pair straddling the face.  It is otherwise known as 
         ## anisotropic limiting.
         ## This is only available on simplex meshes as it involes a search around
         ## the donor node to find the upwind element.
         element project_upwind_value_from_point {
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which it was found from.
            element bound_projected_value_locally {
               empty
            }?,
            ## Store the locations of the elements where the upwind values
            ## are projected from for each node pair.
            ## This inserts an integer csr matrix into state so is memory expensive but
            ## saves a significant amount of time (searching around the neighbouring elements).
            ## This is unsafe for moving meshes but should be ok for adaptive meshes.
            element store_upwind_elements {
               ## Store the quadrature locations within the elements
               ## where the upwind values
               ## are projected from for each node pair.
               ## This inserts a real block csr matrix into state so is even more memory
               ## expensive than just storing the upwind elements and
               ## only saves a comparitively
               ## marginal amount of time (as actually searching the
               ## neighbouring elements is the
               ## slowest bit, finding the quadrature is relatively easy).
               element store_upwind_quadrature {
                  empty
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Projects the value of the advected variable from the downwind or donor node
         ## using the interpolated gradient at the donor node in the
         ## direction of the vector
         ## connecting the node pair straddling the face.
         ## This is available on all meshes (except if bounding the values).
         element project_upwind_value_from_gradient {
            (
               ## Select which node to project from:
               ## Project from the downwind node (Jasak et al., 1999) so that:
               ## upwind_value = downwind_value - 2*gradient.vector
               element project_from_downwind_value {
                  comment
               }|
               ## Select which node to project from:
               ## Project from the donor node so that:
               ## upwind_value = donor_value - gradient.vector
               element project_from_donor_value {
                  comment
               }
            ),
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which surround it.
            ## This is only available on simplex meshes as it involes a search around
            ## the donor node to find the upwind element.
            element bound_projected_value_locally {
               ## Store the locations of the elements closest to the project value.
               ## This inserts an integer csr matrix into state so is
               ## memory expensive but
               ## saves a significant amount of time (searching around
               ## the neighbouring elements).
               ## This is unsafe for moving meshes but should be ok for adaptive meshes.
               element store_upwind_elements {
                  comment
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the maximum or minimum of the neighbouring
         ## nodes depending on the local slope of the donor and downwind values.
         ## Otherwise known as isotropic limiting.
         ## This is available on all meshes except periodic domains.
         element locally_bound_upwind_value {
            empty
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the value at the node most directy
         ## upwind from the vector connecting the donor and downwind nodes.
         ## This is available on all meshes.
         element pseudo_structured_upwind_value {
            empty
         }
      )
   )

field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain  
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins 
         ## e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
         ## and the fraction of the field in each bin with,
         ## -1.5<=field<0.0, 0.0<=field<1.5, 1.5<=field<2.0, 2.0<=field, 
         ## will be calculated.  
         element mixing_bin_bounds { 
            (
                 ## list of bin bounds
                 element constant { 
                     real_vector
                 }|
                 ## Python function prescribing bin bounds. Functions should be of the form:
                 ##
                 ##  def val(t):
                 ##     # Function code
                 ##     return # Return value that should be an array of reals
                 ##
                 ## 
                 element python {
                     python_code
                   }
              )
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file   
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )


phase_density = 
	(
## Specify the density of the current material phase (can also specify density for each component)
        element Density {
            real
         }
        )


equation_of_state =
               (
                  (
## Use this option to specify the density of fluids
element equation_of_state{

                     ## Equations of state
                     element incompressible {
                        (
                           element linear {
                              (
                                 ## All eos_coefficients equal as in most of
                                 ## the test cases (=1)
                                 element all_equal {
                                    real
                                 }
                              )
                           }
                        )
                     }

         }
)
)

		  

	         
	 
