<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="">
  <define name="scalar_boundary_conditions">
    <element name="boundary_conditions">
      <a:documentation>Boundary conditions</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="surface_ids">
        <a:documentation>Surface id:</a:documentation>
        <ref name="integer_vector"/>
      </element>
      <choice>
        <a:documentation>Type</a:documentation>
        <element name="type">
          <attribute name="name">
            <value>dirichlet</value>
          </attribute>
          <element name="apply_weakly">
            <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin and
control_volume
spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
            <optional>
              <element name="boundary_overwrites_initial_condition">
                <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <optional>
            <element name="component_density">
              <a:documentation>For multimaterial simulations.</a:documentation>
              <empty/>
            </element>
          </optional>
          <ref name="input_choice_real"/>
        </element>
        <element name="type">
          <attribute name="name">
            <value>neumann</value>
          </attribute>
          <ref name="input_choice_real"/>
        </element>
        <ref name="robin_bc_scalar"/>
        <element name="type">
          <a:documentation>Prevent the field from fluxing out of the boundary.
Only applicable to control volume spatial discretisations.</a:documentation>
          <attribute name="name">
            <value>zero_flux</value>
          </attribute>
          <empty/>
        </element>
        <element name="type">
          <a:documentation>Add a bulk formulae flux to the scale field. Should
really be added to Temperature, Salinity, or PhotosyntheticRadation
fields, or nothing will happen. Do not add another Neumann boundary
onto the same surface, or you will get an error.</a:documentation>
          <attribute name="name">
            <value>bulk_formulae</value>
          </attribute>
          <empty/>
        </element>
        <element name="type">
          <a:documentation>Sediment reentrainment boundary. Any sediment in the correct
sediment class will be rentrained back into the flow
depending on the bed shear stress and the parameters of the
sediment grain</a:documentation>
          <attribute name="name">
            <value>sediment_reentrainment</value>
          </attribute>
          <empty/>
        </element>
        <element name="type">
          <a:documentation>[UNDER DEVELOPMENT - DOES NOT WORK YET]
Special type of Dirichlet boundary condition for the k-epsilon
turbulence model. Can be used on TurbulentKineticEnergy (k)
and/or TurbulentDissipation (epsilon) fields.
e.g. use a Dirichlet BC on inlets and k_epsilon on walls.</a:documentation>
          <attribute name="name">
            <value>k_epsilon</value>
          </attribute>
          <element name="string_value">
            <a:documentation>Select high/low Reynolds number wall functions for k and epsilon fields.</a:documentation>
            <choice>
              <value>low_Re</value>
              <value>high_Re</value>
            </choice>
          </element>
        </element>
      </choice>
    </element>
  </define>
  <define name="robin_bc_scalar">
    <element name="type">
      <a:documentation> A robin boundary condition of the form
 C1*T + n.(k*grad(T)) = C0
 where k is the diffusivity tensor,
 n the outward normal vector to the surface,
 T the scalar field value on the surface,
 C0 is the input order zero coefficient and
 C1 is the input order one coefficient.
 THIS WILL ONLY WORK FOR CONTINUOUS GALERKIN SPATIAL DISCRETISATION</a:documentation>
      <attribute name="name">
        <value>robin</value>
      </attribute>
      <element name="order_zero_coefficient">
        <a:documentation> The order zero coefficient represented as C0 in
 C1*T + n.(k*grad(T)) = C0</a:documentation>
        <choice>
          <ref name="input_choice_real"/>
          <element name="from_field">
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="order_one_coefficient">
        <a:documentation> The order one coefficient represented as C1 in
 C1*T + n.(k*grad(T)) = C0</a:documentation>
        <choice>
          <ref name="input_choice_real"/>
          <element name="from_field">
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
    </element>
  </define>
  <define name="prognostic_scalar_field">
    <group>
      <oneOrMore>
        <!--
               scalar_equation_choice,
               spatial_discretisation_options,
               temporal_discretisation_options,
        -->
        <choice>
          <element name="initial_condition">
            <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
            <attribute name="name">
              <value>WholeMesh</value>
            </attribute>
            <ref name="input_choice_initial_condition_real"/>
          </element>
          <element name="initial_condition">
            <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <optional>
              <ref name="region_ids"/>
            </optional>
            <ref name="input_choice_initial_condition_real"/>
          </element>
        </choice>
      </oneOrMore>
      <zeroOrMore>
        <ref name="scalar_boundary_conditions"/>
      </zeroOrMore>
      <optional>
        <element name="scalar_field">
          <a:documentation>Source term</a:documentation>
          <attribute name="name">
            <value>Source</value>
          </attribute>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <element name="prescribed">
              <ref name="prescribed_scalar_field_no_adapt"/>
            </element>
            <element name="diagnostic">
              <a:documentation>This only works for traffic modelling</a:documentation>
              <choice>
                <ref name="scalar_python_diagnostic_algorithm"/>
                <ref name="internal_algorithm"/>
              </choice>
              <ref name="diagnostic_scalar_field_no_adapt"/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="scalar_field">
          <a:documentation>Absorption term</a:documentation>
          <attribute name="name">
            <value>Absorption</value>
          </attribute>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <element name="prescribed">
              <ref name="prescribed_scalar_field_no_adapt"/>
            </element>
            <element name="diagnostic">
              <choice>
                <ref name="scalar_python_diagnostic_algorithm"/>
                <ref name="internal_algorithm"/>
              </choice>
              <ref name="diagnostic_scalar_field_no_adapt"/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="tensor_field">
          <a:documentation>Absorption term</a:documentation>
          <attribute name="name">
            <value>Absorption</value>
          </attribute>
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <element name="diagnostic">
            <ref name="tensor_python_diagnostic_algorithm"/>
            <ref name="diagnostic_tensor_field_no_adapt"/>
          </element>
        </element>
      </optional>
      <!--
             prognostic_scalar_stat_options,
             scalar_convergence_options,
      -->
      <ref name="prognostic_detector_options"/>
      <!--      scalar_steady_state_options, -->
      <ref name="adaptivity_options_prognostic_scalar_field"/>
      <ref name="interpolation_algorithm_scalar"/>
    </group>
    <!--
           discrete_properties_algorithm_scalar?
           ## Set the priority of this field
           ## This determines the order in which scalar_fields are solved for:
           ##  - higher numbers have the highest priority
           ##  - lower numbers (including negative) have the lowest priority
           ##  - default if not set is 0
           element priority {
              integer
           }?
    -->
  </define>
  <define name="prognostic_velocity_field">
    <oneOrMore>
      <!--
             ## Reference node (Node at which all components of velocity = 0.)
             ##
             ## Must be less than the total number of nodes.
             ## If parallel must be less than the total number of nodes of the first processor.
             ##
             ## This is used to impose a pressure level when there are no pressure boundary conditions
             element reference_node {
                integer
             }?,
      -->
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <ref name="region_ids"/>
          </optional>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="velocity_boundary_conditions"/>
      </element>
    </zeroOrMore>
    <optional>
      <element name="vector_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="imposed_material_velocity_source_algorithm"/>
              <ref name="internal_velocity_source_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_source">
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Absorption

Note: When in spherical geometry the absorption is now automatically rotated.
The input values below correspond to setting the diagonal of the absorption matrix
in the rotated frame of reference. The columns correspond to phi, theta and r
respectively.</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="imposed_material_velocity_absorption_algorithm"/>
              <ref name="internal_velocity_absorption_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <choice>
          <element name="default_absorption">
            <a:documentation>Default absorption: no lumping, is fully evaluated before the
the pressure correction.</a:documentation>
            <empty/>
          </element>
          <element name="lump_absorption">
            <a:documentation>Lump the inclusion of absorbtion terms.</a:documentation>
            <optional>
              <element name="use_submesh">
                <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="include_pressure_correction">
            <a:documentation>Includes the pressure correction to the velocity in the
absorption term (for theta&gt;0). This makes the absorption
term more implicit. The absorption term is lumped if and
only if the mass matrix is lumped (lump_mass_matrix).</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
    </optional>
    <ref name="prognostic_detector_options"/>
    <ref name="adaptivity_options_prognostic_vector_field"/>
    <ref name="interpolation_algorithm_vector"/>
  </define>
  <define name="prognostic_pressure_field">
    <group>
      <optional>
        <choice>
          <element name="reference_node">
            <a:documentation>Reference node (Node at which pressure = 0.) Note that the node number must be less than the total number of nodes.
If running in parallel, the node number must be less than the total number of nodes of the first processor.
** Note - it is also an option to remove the null-space of the residual vector. This
option is available under solvers</a:documentation>
            <ref name="integer"/>
          </element>
          <element name="reference_coordinates">
            <a:documentation>Input coordinates of desired reference node. If a node does not exist at these
coordinates, the nearest vertex will be selected.</a:documentation>
            <ref name="real_dim_vector"/>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="hydrostatic_boundaries">
          <a:documentation>It calculates the pressure based on p = rho * g * ( -1.0 * y ) + p0  in 2D and p = rho * g * (-1.0 * z ) + p0 in 3D.
where "y" and "z" are the vertical coordinates in 2D and 3D, respectively; "p0" is the pressure in
[pa] at the highest point of the boundary (normally at y=0 or z=0). With this hydrostatic option "p0" should be assinged
under 'dirichlet/constant' for each boundary (however, it typically has a value of 0.0).
p0 can also be used to adjust the pressure at the highest point of a pressure boundary if it is located below 0.0.

It should be noted that all parts of the model should be located below zero in y (or z in 3D) direction.
The gravitational acceleration is considered to be in negative y (or negative z in 3D) direction.</a:documentation>
          <empty/>
        </element>
      </optional>
      <zeroOrMore>
        <choice>
          <element name="initial_condition">
            <a:documentation>Initial condition for WholeMesh
asc
Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
            <attribute name="name">
              <value>WholeMesh</value>
            </attribute>
            <ref name="input_choice_initial_condition_pressure"/>
          </element>
          <element name="initial_condition">
            <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <optional>
              <ref name="region_ids"/>
            </optional>
            <ref name="input_choice_initial_condition_pressure"/>
          </element>
        </choice>
      </zeroOrMore>
      <zeroOrMore>
        <element name="boundary_conditions">
          <a:documentation>Boundary conditions</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <element name="surface_ids">
            <a:documentation>Surface id:</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <choice>
            <a:documentation>Type</a:documentation>
            <element name="type">
              <attribute name="name">
                <value>dirichlet</value>
              </attribute>
              <element name="apply_weakly">
                <optional>
                  <element name="boundary_overwrites_initial_condition">
                    <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
              <ref name="input_choice_real"/>
            </element>
            <element name="type">
              <attribute name="name">
                <value>freesurface</value>
              </attribute>
              <ref name="input_choice_real"/>
            </element>
            <element name="type">
              <attribute name="name">
                <value>top</value>
              </attribute>
              <ref name="input_choice_real"/>
            </element>
          </choice>
        </element>
      </zeroOrMore>
      <!--
        pressure_output_options,
        prognostic_scalar_stat_options,
        scalar_convergence_options,
      -->
      <ref name="detector_options_disabled_default"/>
      <!-- scalar_steady_state_options, -->
      <ref name="adaptivity_options_prognostic_scalar_field"/>
      <ref name="interpolation_algorithm_scalar_full"/>
    </group>
    <!-- discrete_properties_algorithm_scalar? -->
  </define>
  <define name="prognostic_geostrophic_pressure_field">
    <element name="spatial_discretisation">
      <element name="geostrophic_pressure_option">
        <a:documentation>Enables / disables RHS terms in the geopressure solver:

  include_buoyancy - Include both the buoyancy and Coriolis terms on the RHS
  exclude_buoyancy - Include only the Coriolis term on the RHS
  exclude_coriolis - Include only the buoyancy term on the RHS</a:documentation>
        <element name="string_value">
          <choice>
            <value>include_buoyancy</value>
            <value>exclude_buoyancy</value>
            <value>exclude_coriolis</value>
          </choice>
        </element>
      </element>
    </element>
    <optional>
      <choice>
        <element name="reference_node">
          <a:documentation>Sets node 1 in the mesh as a reference node</a:documentation>
          <attribute name="name">
            <value>node_1</value>
          </attribute>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>1</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="reference_node">
          <a:documentation>Sets a custom node in the mesh as a reference node</a:documentation>
          <attribute name="name">
            <value>custom</value>
          </attribute>
          <ref name="integer"/>
        </element>
        <element name="zero_coord">
          <a:documentation>Sets the value of the field to zero at a supplied coordinate.
This is a post-processing step after the solve, and hence should
be used with the solver/remove_null_space option.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
      </choice>
    </optional>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <zeroOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <ref name="region_ids"/>
          </optional>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </zeroOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Apply a strong dirichlet boundary condition to GeostrophicPressure.
If applied, this would normally be a homogeneous bc on the top but
this only makes sense when excluding coriolis.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <element name="type">
          <a:documentation>Type</a:documentation>
          <attribute name="name">
            <value>dirichlet</value>
          </attribute>
          <ref name="input_choice_real_plus_boundary_forcing"/>
        </element>
      </element>
    </zeroOrMore>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Vertical balance pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_vertical_balance_pressure_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <oneOrMore>
      <element name="boundary_conditions">
        <a:documentation>Apply a strong dirichlet boundary condition to VerticalBalancePressure.
This is normally be a homogeneous bc on the top surface.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <element name="type">
          <a:documentation>Type</a:documentation>
          <attribute name="name">
            <value>dirichlet</value>
          </attribute>
          <ref name="input_choice_real_plus_boundary_forcing"/>
        </element>
      </element>
    </oneOrMore>
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Hydrostatic pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_hydrostatic_pressure_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="discontinuous_galerkin">
          <a:documentation>Uses an advancing front technique to integrate
downwards through the mesh.

Requires a discontinuous mesh!</a:documentation>
          <empty/>
        </element>
        <element name="continuous_galerkin">
          <a:documentation>Solves a continuous steady state equation.

Requires a continuous mesh and solver options below.</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <optional>
            <element name="do_not_integrate_gradient_by_parts">
              <a:documentation>By default when the gradient of the HydrostaticPressure is
subtracted from the rhs of the momentum equation, it is
integrated by parts.  This is the most general case as the
HydrostaticPressure can be discontinuous.
Use this option to turn off this behaviour, which will
be valid for a continuous HydrostaticPressure.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
    </element>
    <optional>
      <element name="solver">
        <a:documentation>Solver
Only required for continuous_galerkin spatial_discretisations!</a:documentation>
        <ref name="linear_solver_options_asym"/>
      </element>
    </optional>
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!-- Hydrostatic pressure gradient field -->
  <define name="prognostic_hydrostatic_pressure_gradient_field">
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <ref name="prognostic_velocity_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_vector_field"/>
    <ref name="interpolation_algorithm_vector_full"/>
  </define>
  <!--
    Foam Velocity Potential field.
    Used to calculate the velocity of flowing foams.
  -->
  <define name="prognostic_foam_velocity_potential_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="foam_velocity_option">
        <empty/>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <optional>
              <element name="apply_weakly">
                <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin,
control_volume, and mixed_cv_cg
spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
                <optional>
                  <element name="boundary_overwrites_initial_condition">
                    <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <ref name="robin_bc_scalar"/>
          <element name="type">
            <a:documentation>Prevent the field from fluxing out of the boundary.
Only applicable to control volume spatial discretisations.</a:documentation>
            <attribute name="name">
              <value>zero_flux</value>
            </attribute>
            <empty/>
          </element>
        </choice>
      </element>
    </zeroOrMore>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    free surface field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_free_surface_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <optional>
        <element name="free_surface_3D">
          <a:documentation>Form a full 3D system for the free surface</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="fourth_order_dissipation">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="low_order_free_surface">
          <a:documentation>low order (linear) free surface</a:documentation>
          <empty/>
        </element>
      </optional>
      <choice>
        <element name="default_free_surface_filter">
          <a:documentation>Select free surface filter

With PN-PN we need some filter to supress spurious modes.</a:documentation>
          <empty/>
        </element>
        <element name="user_specified_free_surface_filter">
          <a:documentation>Select free surface filter

With PN-PN we need some filter to supress spurious modes.</a:documentation>
          <element name="non_linear_filter_coefficient">
            <a:documentation>Default is to apply 0.01 and for wetting and drying cases 1.0</a:documentation>
            <ref name="real"/>
          </element>
        </element>
        <element name="switch_off_free_surface_filter">
          <a:documentation>Switch off free surface filter, this is more efficient than setting the coefficient to 0.</a:documentation>
          <empty/>
        </element>
      </choice>
      <optional>
        <element name="wetting_drying">
          <a:documentation>Apply wetting and drying routines</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="tidal_forcing">
          <a:documentation>Tidal forcing options</a:documentation>
          <optional>
            <element name="M2">
              <a:documentation>M2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="S2">
              <a:documentation>S2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="N2">
              <a:documentation>N2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="K2">
              <a:documentation>K2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="K1">
              <a:documentation>K1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="O1">
              <a:documentation>O1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="P1">
              <a:documentation>P1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="Q1">
              <a:documentation>Q1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="all_tidal_components">
              <a:documentation>Switch on all tidal components</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="love_number">
              <a:documentation>Switches on a Love number of 0.3</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="static_tidal_force">
              <a:documentation>Use static tidal force for testing</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
    <!--
      atheta, ctheta and fstheta (absorption, coriolis and free surface)
      need to go in temporal discretisation
      they are currently hard-coded however
    -->
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicitness for the free surface.

Suggested value 1.0 (should be at least bigger than 0.5).
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <!-- Maybe this should go under a proper absorption field under free surface? -->
        <element name="absorption_theta">
          <a:documentation>Implicit/explicitness for absorption
=0.  -- explicit (default)
=0.5 -- Crank-Nicolson
=1.  -- implicit</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <ref name="region_ids"/>
          </optional>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <choice>
              <ref name="input_choice_real_contents"/>
              <element name="from_file">
                <oneOrMore>
                  <element name="tidal">
                    <attribute name="file_name">
                      <data type="string"/>
                    </attribute>
                    <attribute name="variable_name_amplitude">
                      <data type="string"/>
                    </attribute>
                    <attribute name="variable_name_phase">
                      <data type="string"/>
                    </attribute>
                    <attribute name="name">
                      <a:documentation>See E.W. Schwiderski - Rev. Geophys. Space
Phys. Vol. 18 No. 1 pp. 243--268, 1980
for details of these constituent.</a:documentation>
                      <choice>
                        <value>M2</value>
                        <value>S2</value>
                        <value>N2</value>
                        <value>K2</value>
                        <value>K1</value>
                        <value>O1</value>
                        <value>P1</value>
                        <value>Q1</value>
                        <value>Mf</value>
                        <value>Mm</value>
                        <value>Ssa</value>
                      </choice>
                    </attribute>
                  </element>
                </oneOrMore>
              </element>
              <element name="NEMO_data">
                <a:documentation>Set the boundary free-surface height from NEMO data.
A prescribed NEMO pressure scalar field must be set to use this option.
Set the name of the prescribed NEMO pressure scalar field below.</a:documentation>
                <attribute name="field_name">
                  <data type="string"/>
                </attribute>
              </element>
            </choice>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <ref name="robin_bc_scalar"/>
        </choice>
      </element>
    </zeroOrMore>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    stream function, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_stream_function_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    stream function, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_multipath_stream_function_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <element name="boundary_conditions">
      <a:documentation>Boundary conditions</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="surface_ids">
        <a:documentation>Surface id:</a:documentation>
        <ref name="integer_vector"/>
      </element>
      <element name="primary_boundary">
        <a:documentation>The streamfunction will be zero on the primary boundary. There must be exactly one primary boundary.</a:documentation>
        <empty/>
      </element>
      <group>
        <a:documentation>Type</a:documentation>
        <element name="type">
          <attribute name="name">
            <value>dirichlet</value>
          </attribute>
          <element name="internally_calculated">
            <empty/>
          </element>
        </element>
      </group>
    </element>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <element name="secondary_boundary">
          <a:documentation>Secondary boundaries have a value given by the flux between this boundary and the primary boundary.</a:documentation>
          <element name="primary_point">
            <a:documentation>A point on or behind the primary boundary *from* which the flux line should extend.
Note: Path should not go through periodic boundary</a:documentation>
            <ref name="real_dim_vector"/>
          </element>
          <element name="secondary_point">
            <a:documentation>A point on or behind the secondary boundary *to* which the flux line should extend.
Note: Path should not go through periodic boundary</a:documentation>
            <ref name="real_dim_vector"/>
          </element>
        </element>
        <group>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="internally_calculated">
              <empty/>
            </element>
          </element>
        </group>
      </element>
    </zeroOrMore>
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <define name="scalar_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for this field.
Advection Diffusion is the norm for scalar fields.
Works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
        <empty/>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Heat Transfer equation - requires the selection of a Density field.

ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS.

This equation is very similar to a standard advection of temperature equation
except that a coefficient density field may be spatially and/or temporally
varying.</a:documentation>
        <attribute name="name">
          <value>HeatTransfer</value>
        </attribute>
        <ref name="equation_coefficients"/>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS</a:documentation>
        <attribute name="name">
          <value>ConservationOfMass</value>
        </attribute>
        <ref name="equation_coefficients"/>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Reduced Conservation of Mass equation - requires the selection of a Density field.

ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS

This equation is very similar to a standard conservation of mass equation
except that the time discretisation uses only a single time level of density.
This enables consistency between the
MaterialVolumeFraction (ReducedConservationOfMass) and
MaterialDensity (Advection) equations in compressible multimaterial simulations.</a:documentation>
        <attribute name="name">
          <value>ReducedConservationOfMass</value>
        </attribute>
        <ref name="equation_coefficients"/>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Internal Energy equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS
Solve the internal energy equation for this field.
Requires pressure and velocity fields to be present.
Uses a nonconservative time discretisation.</a:documentation>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <ref name="equation_coefficients"/>
      </element>
      <element name="equation">
        <a:documentation>Option to solve for electrical potential from
electrokinetic, electrochemical or electrothermal sources</a:documentation>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="equation_coefficients">
    <choice>
      <element name="density">
        <a:documentation>Select density to use in the equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present
Whatever field is selected must be present.</a:documentation>
        <attribute name="name">
          <value>MaterialDensity</value>
        </attribute>
        <optional>
          <ref name="coefficient_discretisation_options"/>
        </optional>
      </element>
      <element name="density">
        <a:documentation>Select density to use in the equation
Use the bulk Density
Clearly this requires a Density field to be present
Whatever field is selected must be present.</a:documentation>
        <attribute name="name">
          <value>Density</value>
        </attribute>
        <optional>
          <ref name="coefficient_discretisation_options"/>
        </optional>
      </element>
      <element name="density">
        <a:documentation>Select density to use in the equation
Whatever field is selected must be present.</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <optional>
          <ref name="coefficient_discretisation_options"/>
        </optional>
      </element>
    </choice>
  </define>
  <define name="coefficient_discretisation_options">
    <element name="discretisation_options">
      <a:documentation>Provide discretisation options for the coefficient density field.

If not provided then the discretisation options will default to those
under the field that is named (hence it will generally have to be a prognostic
field itself).</a:documentation>
      <element name="spatial_discretisation">
        <element name="control_volumes">
          <ref name="spatial_control_volume_options_excluding_none"/>
        </element>
      </element>
      <element name="temporal_discretisation">
        <element name="theta">
          <a:documentation>Implicit/explicit control (TTHETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
          <ref name="real"/>
        </element>
        <element name="control_volumes">
          <optional>
            <element name="limit_theta">
              <a:documentation>Only works if a control volume or coupled_cv spatial discretisation is selected.
If not active then the theta specified above will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </element>
    </element>
  </define>
</grammar>
