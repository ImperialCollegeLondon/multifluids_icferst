<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!-- The radiation options -->
  <define name="radiation">
    <element name="radiation">
      <a:documentation>Radiation model </a:documentation>
      <ref name="comment"/>
      <optional>
        <ref name="particle_type_neutron"/>
      </optional>
      <optional>
        <ref name="particle_type_photon"/>
      </optional>
    </element>
  </define>
  <define name="particle_type_neutron">
    <element name="particle_type">
      <a:documentation>Particle type neutron</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Neutron</value>
      </attribute>
      <ref name="equation_type_neutron"/>
      <ref name="particle_type_generic"/>
      <optional>
        <ref name="delayed_precursor"/>
      </optional>
    </element>
  </define>
  <define name="particle_type_photon">
    <element name="particle_type">
      <a:documentation>Particle type photon</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Photon</value>
      </attribute>
      <ref name="equation_type_photon"/>
      <ref name="particle_type_generic"/>
    </element>
  </define>
  <define name="equation_type_neutron">
    <choice>
      <ref name="eigenvalue_equation"/>
      <ref name="time_equation"/>
    </choice>
  </define>
  <define name="equation_type_photon">
    <ref name="time_equation"/>
  </define>
  <define name="particle_type_generic">
    <ref name="energy_discretisation"/>
    <oneOrMore>
      <ref name="radiation_material_data_set"/>
    </oneOrMore>
    <ref name="radiation_material_mapping"/>
  </define>
  <define name="energy_discretisation">
    <element name="energy_discretisation">
      <a:documentation>The energy discretisation for the whole spatial mesh</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>WholeSpatialMesh</value>
      </attribute>
      <ref name="energy_continuity"/>
      <ref name="energy_degree"/>
      <oneOrMore>
        <ref name="energy_group_set"/>
      </oneOrMore>
    </element>
  </define>
  <define name="energy_continuity">
    <element name="continuity">
      <a:documentation>The energy discretisation continuity</a:documentation>
      <ref name="comment"/>
      <element name="string_value">
        <value>discontinuous</value>
      </element>
    </element>
  </define>
  <define name="energy_degree">
    <element name="degree">
      <a:documentation>The energy discretisation degree</a:documentation>
      <ref name="comment"/>
      <element name="integer_value">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <value>0</value>
      </element>
    </element>
  </define>
  <define name="energy_group_set">
    <element name="energy_group_set">
      <a:documentation>Define a group set of consecutive energy groups, where each group 
within the set shares the group set options. The global 
group numbering starts at 1 from the first group within 
the first group set then increases in the order the group 
sets are defined.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="number_of_energy_groups"/>
      <ref name="angular_discretisation"/>
    </element>
  </define>
  <define name="number_of_energy_groups">
    <element name="number_of_energy_groups">
      <a:documentation>The number of energy groups</a:documentation>
      <ref name="comment"/>
      <ref name="integer"/>
    </element>
  </define>
  <define name="angular_discretisation">
    <element name="angular_discretisation">
      <a:documentation>The angular discetisation for the whole spatial mesh 
assoicated with this energy group set</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>WholeSpatialMesh</value>
      </attribute>
      <ref name="angular_discretisation_method"/>
    </element>
  </define>
  <define name="angular_discretisation_method">
    <element name="method">
      <a:documentation>The spherical harmonic angular discretisation method </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>SphericalHarmonic</value>
      </attribute>
      <ref name="angular_parity"/>
    </element>
  </define>
  <define name="angular_parity">
    <element name="parity">
      <a:documentation>Solve for the even parity flux
of this angular discretisation </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Even</value>
      </attribute>
      <ref name="even_parity_source_options"/>
      <optional>
        <ref name="calculate_current"/>
      </optional>
      <ref name="angular_moment_set_even_parity"/>
    </element>
  </define>
  <define name="even_parity_source_options">
    <element name="exclude_odd_parity_time_source">
      <a:documentation> Exclude the odd parity time source
 NOT RELEVANT FOR EQUATION(EIGENVALUE)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="calculate_current">
    <element name="vector_field">
      <a:documentation>The particle current vector field calculated 
diagnostically from the even parity solution.
This is for each energy group with in this
energy group set. </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>ParticleCurrent</value>
      </attribute>
      <ref name="current_internal_algorithm_diagnostic_vector_field_no_adapt"/>
    </element>
  </define>
  <define name="current_internal_algorithm_diagnostic_vector_field_no_adapt">
    <element name="diagnostic">
      <ref name="comment"/>
      <ref name="internal_algorithm"/>
      <ref name="current_mesh_choice"/>
      <ref name="radiation_output_options"/>
      <ref name="radiation_stat_options"/>
      <ref name="diagnostic_detector_options"/>
    </element>
  </define>
  <define name="current_mesh_choice">
    <choice>
      <element name="mesh">
        <a:documentation>THE CURRENT MESH MUST BE DISCONTINUOUS</a:documentation>
        <attribute name="name">
          <value>ParticleCurrentMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <a:documentation>THE CURRENT MESH MUST BE DISCONTINUOUS</a:documentation>
        <attribute name="name">
          <value>ParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <a:documentation>THE CURRENT MESH MUST BE DISCONTINUOUS</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="angular_moment_set_even_parity">
    <element name="angular_moment_set">
      <a:documentation>Define a consecutive angular moment set, where each 
moment within the set shares the same options. Global
moment numbering starts from moment 1 of the first set
then increases in the order that the moment sets are defined.
The moment sets defined are only for the prognostically 
calculated parity flux moments (e.g. for even parity only
define the necessary even parity moments)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>AllMoments</value>
      </attribute>
      <ref name="number_of_angular_moments"/>
      <ref name="particle_type_material_mesh_choice"/>
      <ref name="angular_moment_set_diffusivity_field"/>
      <ref name="angular_moment_set_absorption_field"/>
      <ref name="particle_flux_diffusion_field"/>
    </element>
  </define>
  <define name="number_of_angular_moments">
    <element name="number_of_angular_moments">
      <a:documentation>The number of angular moments</a:documentation>
      <ref name="comment"/>
      <element name="integer_value">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <value>1</value>
      </element>
    </element>
  </define>
  <define name="particle_type_material_mesh_choice">
    <choice>
      <element name="mesh">
        <a:documentation>THE PARTICLE MATERIAL MESH MUST BE DISCONTINUOUS</a:documentation>
        <attribute name="name">
          <value>ParticleMaterialMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <a:documentation>THE PARTICLE MATERIAL MESH MUST BE DISCONTINUOUS</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="angular_moment_set_diffusivity_field">
    <element name="tensor_field">
      <a:documentation>The tensor field used during assemble for the moments of this set
associated with the diffusivity term. </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Diffusivity</value>
      </attribute>
      <element name="diagnostic">
        <ref name="comment"/>
        <element name="algorithm">
          <a:documentation>Calculated via interpolation of a prescribed data set.</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <value>Internal</value>
          </attribute>
        </element>
        <zeroOrMore>
          <ref name="rotate_diffusivity_tensor"/>
        </zeroOrMore>
        <ref name="field_exclude_all_output"/>
      </element>
    </element>
  </define>
  <define name="rotate_diffusivity_tensor">
    <element name="rotation">
      <a:documentation> Apply successive rotations of the diffusivity tensor around a 
 chosen dimension axis (XYZ). This induces a counter-clockwise
 rotation when the axis about which they occur points towards an observer  
 (ie. the right hand rule for positive sign of angles).
 Intrinsic rotations are applied to the mobile (co-moving) axis frame.
 In 1 dimension this is pointless, in 2 dimensions only rotations about
 the Z axis are appropriate. The rotation angle unit is degree.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string" datatypeLibrary=""/>
      </attribute>
      <choice>
        <element name="axis">
          <a:documentation>The axis of the mobile frame to rotate about</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <value>X</value>
          </attribute>
        </element>
        <element name="axis">
          <a:documentation>The axis of the mobile frame to rotate about</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <value>Y</value>
          </attribute>
        </element>
        <element name="axis">
          <a:documentation>The axis of the mobile frame to rotate about</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <value>Z</value>
          </attribute>
        </element>
      </choice>
      <element name="scalar_field">
        <a:documentation>The rotation angle field in degree units</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>Angle</value>
        </attribute>
        <element name="prescribed">
          <a:documentation>Field Type</a:documentation>
          <ref name="comment"/>
          <ref name="particle_type_material_mesh_choice"/>
          <ref name="prescribed_scalar_field_no_adapt_exclude_all_output"/>
        </element>
      </element>
    </element>
  </define>
  <define name="angular_moment_set_absorption_field">
    <element name="scalar_field">
      <a:documentation>The scalar field used during assemble for the moments of this set
associated with the absorption term. </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Absorption</value>
      </attribute>
      <element name="diagnostic">
        <ref name="comment"/>
        <element name="algorithm">
          <a:documentation>Calculated via interpolation of a prescribed data set.</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <value>Internal</value>
          </attribute>
        </element>
        <ref name="field_exclude_all_output"/>
      </element>
    </element>
  </define>
  <define name="particle_flux_diffusion_field">
    <element name="scalar_field">
      <a:documentation>The particle flux scalar field for the angular discretised
even parity formulation for this group set</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>ParticleFlux</value>
      </attribute>
      <ref name="prognostic_particle_diffusion_removal_source_scalar_field"/>
    </element>
  </define>
  <define name="prognostic_particle_diffusion_removal_source_scalar_field">
    <element name="prognostic">
      <a:documentation>Field Type</a:documentation>
      <ref name="comment"/>
      <ref name="particle_type_mesh_choice"/>
      <ref name="radiation_spatial_diffusion_equation"/>
      <ref name="radiation_diffusion_spatial_discretisation"/>
      <ref name="radiation_temporal_discretisation"/>
      <ref name="radiation_diffusion_inner_solver_options"/>
      <oneOrMore>
        <ref name="radiation_initial_conditions"/>
      </oneOrMore>
      <zeroOrMore>
        <ref name="radiation_diffusion_boundary_conditions"/>
      </zeroOrMore>
      <optional>
        <ref name="radiation_diffusion_prescribed_source"/>
      </optional>
      <ref name="radiation_output_options"/>
      <ref name="radiation_stat_options"/>
      <ref name="prognostic_detector_options"/>
      <ref name="adaptivity_options_scalar_field"/>
      <ref name="interpolation_algorithm_scalar"/>
    </element>
  </define>
  <define name="particle_type_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>ParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="radiation_spatial_diffusion_equation">
    <element name="equation">
      <a:documentation>The equation to solve for this scalar field</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>AdvectionDiffusion</value>
      </attribute>
    </element>
  </define>
  <define name="radiation_diffusion_spatial_discretisation">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <ref name="comment"/>
      <ref name="radiation_diffusion_continuous_galerkin_options"/>
      <ref name="radiation_diffusion_conservative_advection_option"/>
    </element>
  </define>
  <define name="radiation_diffusion_continuous_galerkin_options">
    <element name="continuous_galerkin">
      <a:documentation>Continuous galerkin formulation</a:documentation>
      <ref name="comment"/>
      <ref name="radiation_diffusion_cg_advection_terms"/>
      <ref name="radiation_diffusion_cg_mass_terms"/>
    </element>
  </define>
  <define name="radiation_diffusion_cg_advection_terms">
    <element name="advection_terms">
      <a:documentation>Discretisation options for the advection terms.</a:documentation>
      <ref name="comment"/>
      <element name="exclude_advection_terms">
        <a:documentation>EXCLUDE THE ADVECTION TERMS FROM THE GENERAL ADVECTIONDIFFUSION SCALAR FIELD SOLVER</a:documentation>
        <ref name="comment"/>
      </element>
    </element>
  </define>
  <define name="radiation_diffusion_cg_mass_terms">
    <element name="mass_terms">
      <a:documentation> FOR EQUATION(EIGENVALUE) THE MASS TERMS MUST BE REMVOVED
 Discretisation options for the mass terms.</a:documentation>
      <optional>
        <element name="lump_mass_matrix">
          <a:documentation>Lump the mass matrix</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="exclude_mass_terms">
          <a:documentation>Remove the mass terms from the equation. This requires an
implicitness factor theta = 1.0 (under
temporal_discretisation).</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="radiation_diffusion_conservative_advection_option">
    <element name="conservative_advection">
      <a:documentation> THIS OPTION IS NOT USED BUT IS NEEDED FOR THE GENERAL ADVECTIONDIFFUSION SCALAR FIELD SOLVER</a:documentation>
      <ref name="comment"/>
      <element name="real_value">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <value>1.0</value>
      </element>
    </element>
  </define>
  <define name="radiation_temporal_discretisation">
    <element name="temporal_discretisation">
      <a:documentation> The temporal discretisation options 
 FOR EQUATION(EIGENVALUE) THIS MUST BE SET TO 1.0 FOR THE GENERAL ACCELERATION SOLVER</a:documentation>
      <ref name="comment"/>
      <element name="theta">
        <a:documentation>the theta value</a:documentation>
        <ref name="comment"/>
        <ref name="real"/>
      </element>
    </element>
  </define>
  <define name="radiation_diffusion_inner_solver_options">
    <element name="solver">
      <a:documentation>The inner solver options</a:documentation>
      <ref name="comment"/>
      <ref name="linear_solver_options_sym"/>
    </element>
  </define>
  <define name="radiation_initial_conditions">
    <element name="initial_condition">
      <a:documentation>Initial condition for WholeSpatialMesh associated with this
angular moment set (itself associated with a energy group set)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <choice>
        <element name="constant">
          <a:documentation>Constant value</a:documentation>
          <ref name="real"/>
        </element>
        <element name="from_file">
          <a:documentation>Initialise the field from an existing file (indended
primarily for use in checkpointing). The file mesh must match
the mesh of this field  (except for piecewise constant fields 
which will be remapped back from the discontinuous nodal values). 
In parallel the process number is
appended to the filename, e.g. if the file_name attribute is
set to "input.vtu", process 0 reads from "input-0.vtu".</a:documentation>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <ref name="vtu_input_format"/>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="radiation_diffusion_boundary_conditions">
    <element name="boundary_conditions">
      <a:documentation>The problem boundary conditions associated with this
angular moment set (itself associated with a energy group set)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="surface_ids"/>
      <ref name="diffusion_bc_type"/>
    </element>
  </define>
  <define name="surface_ids">
    <element name="surface_ids">
      <a:documentation>The surface id associated with this boundary condition</a:documentation>
      <ref name="comment"/>
      <ref name="integer_vector"/>
    </element>
  </define>
  <define name="diffusion_bc_type">
    <choice>
      <a:documentation>Type</a:documentation>
      <ref name="diffusion_robin"/>
      <ref name="diffusion_dirichlet"/>
      <ref name="diffusion_neumann"/>
    </choice>
  </define>
  <define name="diffusion_robin">
    <element name="type">
      <a:documentation> A robin boundary condition of the form
 C1*T + n.(k*grad(T)) = C0
 where k is the diffusivity tensor,
 n the outward normal vector to the surface,
 T the scalar field value on the surface,
 C0 is the input order zero coefficient and
 C1 is the input order one coefficient.
 THIS WILL ONLY WORK FOR CONTINUOUS GALERKIN SPATIAL DISCRETISATION
 
 This can be used for vacuum and more general albedo.
 For a vacuum BC set the order_zero_coefficient to 0.0 and the order_one_coefficient
 to 0.5. For a albedo BC set the order_zero_coefficient to 0.0 and the order_one_coefficient
 to 0.5*((1.0-alpha)/(1.0+alpha)) where alpha is defined in [0.0,1.0] with alpha equal 1.0
 being a perfect reflective and alpha equal 0.0 a perfect vacuum.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>robin</value>
      </attribute>
      <element name="order_zero_coefficient">
        <a:documentation> The order zero coefficient represented as C0 in
 C1*T + n.(k*grad(T)) = C0</a:documentation>
        <ref name="input_choice_real"/>
      </element>
      <element name="order_one_coefficient">
        <a:documentation> The order one coefficient represented as C1 in
 C1*T + n.(k*grad(T)) = C0</a:documentation>
        <ref name="input_choice_real"/>
      </element>
    </element>
  </define>
  <define name="diffusion_dirichlet">
    <element name="type">
      <a:documentation>Dirichlet boundary condition. This is typically used for an approximation to a 
vacuum BC via a zero dirichlet for special benchmarks. Not recommended for anything else. </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>dirichlet</value>
      </attribute>
      <ref name="input_choice_real"/>
    </element>
  </define>
  <define name="diffusion_neumann">
    <element name="type">
      <a:documentation>Neumann boundary condition. This is a isotropic particle source boundary condition. 
This value specifies the actually current into the domain NOT the total isotropic 
source strength located on the surface (the total source strength is twice the value input here) </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>neumann</value>
      </attribute>
      <ref name="input_choice_real"/>
    </element>
  </define>
  <define name="radiation_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <ref name="comment"/>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="radiation_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to the .stat file</a:documentation>
      <ref name="comment"/>
      <optional>
        <element name="exclude_from_stat">
          <a:documentation>Exclude this field from the .stat file</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="radiation_diffusion_prescribed_source">
    <element name="scalar_field">
      <a:documentation> Prescribed isotropic source term
 NOT RELEVANT FOR EQUATION(EIGENVALUE)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Source</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <element name="prescribed">
        <ref name="comment"/>
        <ref name="radiation_diffusion_prescribed_source_scalar_field"/>
      </element>
    </element>
  </define>
  <define name="radiation_diffusion_prescribed_source_scalar_field">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="radiation_output_options"/>
    <ref name="radiation_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="eigenvalue_equation">
    <element name="equation">
      <a:documentation>Select the equation type to solve.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Eigenvalue</value>
      </attribute>
      <ref name="eigenvalue_equation_solver"/>
      <ref name="flux_normalisation_options"/>
    </element>
  </define>
  <define name="eigenvalue_equation_solver">
    <group>
      <a:documentation>Eigen Solver Algorithm</a:documentation>
      <element name="power_iteration">
        <a:documentation>Power Iterations</a:documentation>
        <ref name="comment"/>
        <ref name="power_iteration_element"/>
      </element>
    </group>
  </define>
  <define name="flux_normalisation_options">
    <choice>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalFlux</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalProduction</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalFission</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalPower</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
    </choice>
  </define>
  <define name="flux_norm_value_and_symmetry">
    <element name="value">
      <a:documentation>Normalisation value</a:documentation>
      <ref name="comment"/>
      <ref name="real"/>
    </element>
    <optional>
      <element name="domain_symmetry_factor">
        <a:documentation>Normalisation domain symmetry factor
where for example 4 implies quarter geometry represented</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="power_iteration_element">
    <element name="maximum">
      <a:documentation>The maximum number of power iterations</a:documentation>
      <ref name="comment"/>
      <ref name="integer"/>
    </element>
    <element name="flux_tolerance_absolute">
      <a:documentation>The power iteration absolute tolerance for the flux</a:documentation>
      <ref name="comment"/>
      <ref name="real"/>
    </element>
    <element name="keff_tolerance_relative">
      <a:documentation>The power iteration relative tolerance for the eigenvalue called keff</a:documentation>
      <ref name="comment"/>
      <ref name="real"/>
    </element>
    <optional>
      <ref name="accelerate_flux"/>
    </optional>
    <optional>
      <ref name="accelerate_keff"/>
    </optional>
    <optional>
      <ref name="scatter_group_iteration_options"/>
    </optional>
    <optional>
      <element name="terminate_if_not_converged">
        <a:documentation>Terminate the simulation if the maximum number of power
iterations is reached and the tolerance criteria (both flux and keff) are not met.</a:documentation>
        <ref name="comment"/>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="accelerate_flux">
    <element name="flux_acceleration">
      <a:documentation>Accelerate the flux calculation via a relaxation parameter in range (0,2.0)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Relaxation</value>
      </attribute>
      <ref name="real"/>
    </element>
  </define>
  <define name="accelerate_keff">
    <element name="keff_acceleration">
      <a:documentation>Accelerate the Keff calculation via the Aitkens Delta Squared process</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>AitkensDeltaSquared</value>
      </attribute>
    </element>
  </define>
  <define name="scatter_group_iteration_options">
    <element name="scatter_group_iteration">
      <a:documentation>The scatter group iteration options 
(if not present then only one iteration of all energy groups from high to low)</a:documentation>
      <ref name="comment"/>
      <element name="maximum">
        <a:documentation>The maximum number of scatter group iterations</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
      <element name="flux_tolerance_absolute">
        <a:documentation>The scatter group iteration absolute tolerance for the flux</a:documentation>
        <ref name="comment"/>
        <ref name="real"/>
      </element>
      <ref name="scatter_energy_solve_direction_options"/>
      <optional>
        <element name="highest_upscatter_group">
          <a:documentation>The highest upscatter group, if enabled scatter iterations after the
first will start sweeping down from this group</a:documentation>
          <ref name="comment"/>
          <ref name="integer"/>
        </element>
      </optional>
      <optional>
        <element name="terminate_if_not_converged">
          <a:documentation>Terminate the simulation if the maximum number of scatter
iterations is reached and the tolerance criterion is not met.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <ref name="whole_domain_energy_group_rebalance_options"/>
      </optional>
    </element>
  </define>
  <define name="scatter_energy_solve_direction_options">
    <choice>
      <element name="energy_solve_direction">
        <a:documentation>Within each scatter iteration after the first 
sweep from high to low energy </a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>HighToLow</value>
        </attribute>
      </element>
      <element name="energy_solve_direction">
        <a:documentation>Within each scatter iteration after the first 
sweep from low to high energy </a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>LowToHigh</value>
        </attribute>
      </element>
      <element name="energy_solve_direction">
        <a:documentation>Within each scatter iteration after the first 
sweep from high to low then back to high energy</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>HighToLowToHigh</value>
        </attribute>
      </element>
      <element name="energy_solve_direction">
        <a:documentation>Within each scatter iteration after the first 
sweep from low to high then back to low energy </a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>LowToHighToLow</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="time_equation">
    <element name="equation">
      <a:documentation>Select the equation type to solve.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>TimeDependent</value>
      </attribute>
      <ref name="energy_group_iteration_options"/>
    </element>
  </define>
  <define name="energy_group_iteration_options">
    <element name="energy_group_iteration">
      <a:documentation>Set the energy group iteration</a:documentation>
      <ref name="comment"/>
      <element name="maximum">
        <a:documentation>The maximum number of energy group iterations</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
      <element name="flux_tolerance_absolute">
        <a:documentation>The energy group iteration absolute flux tolerance </a:documentation>
        <ref name="comment"/>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="scatter_group_iteration_options"/>
      </optional>
      <optional>
        <element name="terminate_if_not_converged">
          <a:documentation>Terminate the simulation if the maximum number of energy group
iterations is reached and the tolerance criterion is not met.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <ref name="whole_domain_energy_group_rebalance_options"/>
      </optional>
    </element>
  </define>
  <define name="whole_domain_energy_group_rebalance_options">
    <choice>
      <element name="whole_domain_group_rebalance">
        <a:documentation>Whole domain rebalance acceleration of 
all energy groups together    </a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>AllEnergyGroup</value>
        </attribute>
      </element>
      <element name="whole_domain_group_rebalance">
        <a:documentation>Whole domain rebalance acceleration of 
each energy group individually</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>EachEnergyGroup</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="radiation_material_data_set">
    <element name="material_data_set">
      <a:documentation>Define a radiation material data set </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="from_file">
        <a:documentation>Read the radiation material data set from a file
(Include any file name extensions in the file name as well as the path if needed)</a:documentation>
        <ref name="comment"/>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="number_of_scatter_moments"/>
        <ref name="radiation_material_data_set_format"/>
        <oneOrMore>
          <ref name="radiation_physical_material"/>
        </oneOrMore>
      </element>
    </element>
  </define>
  <define name="radiation_material_data_set_format">
    <element name="format_radmats">
      <a:documentation>A keyword based embedded radiation data type format file, of which a subset 
includes the formatted file produced via a LISTTO from WIMS9</a:documentation>
      <ref name="comment"/>
      <element name="maximum_record_length">
        <a:documentation>The maximum line (or record) length of the input file</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
    </element>
  </define>
  <define name="radiation_physical_material">
    <element name="physical_material">
      <a:documentation>Define each physical material</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <oneOrMore>
        <element name="interpolation_dimension">
          <a:documentation>define the tabulated interpolation dimensions for this physical material</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <choice>
            <a:documentation>set the interpolation attribute for this dimension</a:documentation>
            <element name="interpolation_attribute_none">
              <a:documentation>No attribute so the first radmat of this dimension of this physical material will be used</a:documentation>
              <ref name="comment"/>
            </element>
            <element name="interpolation_attribute_prescribed">
              <a:documentation>Prescribed interpolation</a:documentation>
              <ref name="comment"/>
              <ref name="real"/>
            </element>
            <element name="interpolation_attribute_scalar_field">
              <a:documentation>Associate this dimension with a particular scalar field</a:documentation>
              <ref name="comment"/>
              <attribute name="name">
                <data type="string"/>
              </attribute>
            </element>
          </choice>
          <element name="interpolation_values">
            <a:documentation>define the interpolation values for this dimension as a float list</a:documentation>
            <ref name="comment"/>
            <ref name="real_vector"/>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <define name="number_of_scatter_moments">
    <element name="number_of_scatter_moments">
      <a:documentation>The number of scatter moments associated with this material data set</a:documentation>
      <ref name="comment"/>
      <ref name="integer"/>
    </element>
  </define>
  <define name="radiation_material_mapping">
    <optional>
      <element name="region_id_material_mapping">
        <a:documentation>The region id to radiation physical material mapping. This option is intended for radiation alone with no consideration of 
the rest of the fluids state. This must be used with a prescribed physical material interpolation attribute. </a:documentation>
        <ref name="comment"/>
        <oneOrMore>
          <element name="region_to_physical_radiation_material_map">
            <ref name="comment"/>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="region_id"/>
            <ref name="radiation_material"/>
          </element>
        </oneOrMore>
      </element>
    </optional>
    <optional>
      <element name="link_with_multimaterial">
        <a:documentation>Link with multimaterial model</a:documentation>
        <ref name="comment"/>
        <oneOrMore>
          <element name="fluids_material_phase_to_physical_radiation_material_map">
            <a:documentation>The fluids material_phase to radiation physical material mapping</a:documentation>
            <ref name="comment"/>
            <ref name="radiation_material"/>
            <ref name="Rad_MaterialVolumeFraction"/>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </oneOrMore>
        <optional>
          <ref name="Rad_MaterialTemperature"/>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="link_with_porous_media">
        <a:documentation>Link with the porous media model</a:documentation>
        <ref name="comment"/>
        <oneOrMore>
          <element name="porous_media_region_to_physical_radiation_material_map">
            <ref name="comment"/>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="region_id"/>
            <ref name="radiation_material"/>
          </element>
        </oneOrMore>
        <ref name="Rad_Porosity"/>
        <optional>
          <ref name="Rad_PorousTemperature"/>
        </optional>
      </element>
    </optional>
  </define>
  <define name="radiation_material">
    <element name="data_set">
      <a:documentation>Data set name</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
    </element>
    <element name="physical_material">
      <a:documentation>Physical material name</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
    </element>
  </define>
  <define name="region_id">
    <element name="region_id">
      <a:documentation>the region id</a:documentation>
      <ref name="comment"/>
      <ref name="integer_vector"/>
    </element>
  </define>
  <define name="Rad_MaterialVolumeFraction">
    <element name="scalar_field">
      <a:documentation>The material volume fraction scalar field
that is used for the cross section mapping and interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadMaterialVolumeFraction</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="Rad_MaterialTemperature">
    <element name="scalar_field">
      <a:documentation>The temperature scalar field associated with multimaterial
that is used for the cross section interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadMaterialTemperature</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="Rad_Porosity">
    <element name="scalar_field">
      <a:documentation>The porosity scalar field that is used for the cross section interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadPorosity</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="Rad_PorousTemperature">
    <element name="scalar_field">
      <a:documentation>The porous temperature scalar field
that is used for the cross section interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadPorousTemperature</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
    <choice>
      <element name="prescribed">
        <ref name="comment"/>
        <ref name="particle_type_material_mesh_choice"/>
        <ref name="prescribed_scalar_field"/>
      </element>
      <element name="diagnostic">
        <ref name="comment"/>
        <ref name="scalar_diagnostic_algorithms"/>
        <ref name="particle_type_material_mesh_choice"/>
        <ref name="diagnostic_scalar_field"/>
      </element>
    </choice>
  </define>
  <define name="delayed_precursor">
    <element name="delayed_neutron_precursor">
      <a:documentation>Delayed neutron precursor </a:documentation>
      <ref name="comment"/>
      <element name="number_delayed_neutron_precursor_groups">
        <a:documentation>The number of delayed neutron precursor groups</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
      <element name="read_delayed_lambda_spectrum_from_data_set">
        <a:documentation>The dataset from which to read the delayed lambda and spectrum from</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <optional>
        <element name="link_with_region_id">
          <a:documentation>link with region id, requires the neutron object to be linked with region id also</a:documentation>
          <ref name="comment"/>
          <ref name="delayed_neutron_precursor_diagnostic"/>
        </element>
      </optional>
      <optional>
        <element name="link_with_multimaterial">
          <a:documentation>link with multimaterial, requires the neutron object to be linked with multimaterial also</a:documentation>
          <ref name="comment"/>
          <ref name="prompt_delayed_coupling_option"/>
          <ref name="delayed_neutron_precursor_prognostic_or_diagnostic"/>
        </element>
      </optional>
      <optional>
        <element name="link_with_porous_media">
          <a:documentation>link with porous media, requires the neutron object to be linked with porous media also</a:documentation>
          <ref name="comment"/>
          <ref name="delayed_neutron_precursor_diagnostic"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="prompt_delayed_coupling_option">
    <choice>
      <ref name="prompt_delayed_coupling_semi_implicit_option"/>
      <ref name="prompt_delayed_coupling_explicit_option"/>
    </choice>
  </define>
  <define name="prompt_delayed_coupling_semi_implicit_option">
    <element name="prompt_delayed_coupling_semi_implicit">
      <a:documentation>Semi-implicit coupling between prompt and delayed neutron equations</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prompt_delayed_coupling_explicit_option">
    <element name="prompt_delayed_coupling_explicit">
      <a:documentation>Explicit coupling between prompt and delayed neutron equations</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="delayed_neutron_precursor_prognostic_or_diagnostic">
    <element name="scalar_field">
      <a:documentation> The delayed neutron precursor scalar field
 Field Type:
  - use prognostic for time run
  - use diagnostic for eigenvalue run</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>DelayedNeutronPrecursor</value>
      </attribute>
      <choice>
        <ref name="prognostic_delayed_neutron_advection_decay_source_scalar_field"/>
        <ref name="delayed_internal_algorithm_diagnostic_scalar_field_no_adapt"/>
      </choice>
    </element>
  </define>
  <define name="delayed_neutron_precursor_diagnostic">
    <element name="scalar_field">
      <a:documentation>The delayed neutron precursor scalar field</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>DelayedNeutronPrecursor</value>
      </attribute>
      <ref name="delayed_internal_algorithm_diagnostic_scalar_field_no_adapt"/>
    </element>
  </define>
  <define name="delayed_internal_algorithm_diagnostic_scalar_field_no_adapt">
    <element name="diagnostic">
      <ref name="comment"/>
      <ref name="internal_algorithm"/>
      <ref name="delayed_particle_type_mesh_choice"/>
      <ref name="radiation_output_options"/>
      <ref name="radiation_stat_options"/>
      <ref name="diagnostic_detector_options"/>
    </element>
  </define>
  <define name="prognostic_delayed_neutron_advection_decay_source_scalar_field">
    <element name="prognostic">
      <ref name="comment"/>
      <ref name="delayed_particle_type_mesh_choice"/>
      <element name="equation">
        <a:documentation>Solve a delayed neutron advection-decay-source equation</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="spatial_discretisation">
        <a:documentation>Spatial discretisation options</a:documentation>
        <ref name="comment"/>
        <choice>
          <element name="continuous_galerkin">
            <a:documentation>Continuous galerkin formulation</a:documentation>
            <ref name="advection_stabilisation_options"/>
            <ref name="cg_advection_terms"/>
          </element>
          <element name="discontinuous_galerkin">
            <a:documentation>Discontinuous galerkin formulation</a:documentation>
            <ref name="dg_advection_scheme"/>
            <ref name="dg_upwind_stabilisation"/>
          </element>
        </choice>
        <ref name="conservative_advection_option"/>
      </element>
      <element name="temporal_discretisation">
        <a:documentation>The temporal discretisation options </a:documentation>
        <ref name="comment"/>
        <element name="theta">
          <a:documentation>the theta value</a:documentation>
          <ref name="comment"/>
          <ref name="real"/>
        </element>
        <optional>
          <ref name="temporal_discontinuous_galerkin_options"/>
        </optional>
      </element>
      <element name="solver">
        <a:documentation>The solver options</a:documentation>
        <ref name="comment"/>
        <ref name="linear_solver_options_asym"/>
      </element>
      <oneOrMore>
        <ref name="radiation_initial_conditions"/>
      </oneOrMore>
      <ref name="prognostic_scalar_output_options"/>
      <ref name="prognostic_scalar_stat_options"/>
      <ref name="scalar_convergence_options"/>
      <ref name="prognostic_detector_options"/>
      <ref name="scalar_steady_state_options"/>
      <ref name="adaptivity_options_scalar_field"/>
      <ref name="interpolation_algorithm_scalar"/>
    </element>
  </define>
  <define name="delayed_particle_type_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>DelayedParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="field_exclude_all_output">
    <ref name="field_exclude_vtu"/>
    <ref name="field_exclude_stat"/>
    <ref name="field_exclude_detectors"/>
  </define>
  <define name="field_exclude_vtu">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <ref name="comment"/>
      <element name="exclude_from_vtu">
        <a:documentation>Exclude this field from dump files</a:documentation>
        <ref name="comment"/>
      </element>
    </element>
  </define>
  <define name="field_exclude_stat">
    <element name="stat">
      <a:documentation>Specify what is added to the .stat file</a:documentation>
      <ref name="comment"/>
      <element name="exclude_from_stat">
        <a:documentation>Exclude this field from the .stat file</a:documentation>
        <ref name="comment"/>
      </element>
    </element>
  </define>
  <define name="field_exclude_detectors">
    <element name="detectors">
      <a:documentation>Specify what is added to the detector files</a:documentation>
      <ref name="comment"/>
      <element name="exclude_from_detectors">
        <a:documentation>This field is not output at detector locations</a:documentation>
        <ref name="comment"/>
      </element>
    </element>
  </define>
  <define name="prescribed_scalar_field_no_adapt_exclude_all_output">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="field_exclude_all_output"/>
  </define>
</grammar>
