include "spud_base.rnc"

include "adaptivity_options.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "solvers.rnc"
include "stabilisation.rnc"
include "mesh_options.rnc"
include "physical_parameters.rnc"
include "prognostic_field_options.rnc"
include "prescribed_field_options.rnc"
include "spatial_discretisation.rnc"
include "temporal_discretisation.rnc"

start =
   (
      ## The root node of the options dictionary.
      ## S.I. units are RECOMMENDED to obtain consistent results.
      element multiphase_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Select the simulation type
         element simulation_type {
             (
                ## Navier-stokes simulator
                element inertia_dominated{comment}|
                ## Darcy flow simulator
                element porous_media{comment}|
                ## Magma flow simulator
                element magma{comment}|
                ## Flooding simulator
                element flooding{comment}
             ),
          element femdem_fracture{comment}?,
          element boiling{comment}?
         },
         geometry,
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            },
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk. 
               ## If using adaptive time-step this periods will be EXACTLY matched.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                (
                     element constant {
                     real
                   }|
                   ## Python function prescribing real input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )  
               }|                 
               ## Dump period, in timesteps.
               ## 
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                 (
                     element constant {
                     integer
                   }|
                   ## Python function prescribing integer input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )   
               }
            ),
          ## Path (without the extension) to the .csv file containing the fluid and porous media properties.
          ## NOTE: Properties in the .csv file will overwrite the input from diamond.
          ##
          ## The information is stored as:
          ##
          ## Property, phase, region_ids(0= if all), value (values separated by _ for region ids and tensors)
          ##
          ## You can find an example in the Proous_media_general test case
          ##
          ## If using this, all the modifiable fields need to have the option to read from a csv file
          element PropertiesFromFile {xsd:string
          }?,
            ## Disable dump at simulation start
            element disable_dump_at_start {
               comment
            }?,
            ## Disable dump at simulation end
            element disable_dump_at_end {
               comment
            }?,
            ## Number of dumps before we overwrite previous dumps.
            element max_dump_file_count {
               integer
            }?,
            (
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "VelocityMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "PressureMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "CoordinateMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { xsd:string }
               }
            ),
            ## Output FE representation of scalar fields instead of the CV one.
            element output_scalars_fem {
               empty
            }?,
            ## Calculates the Darcy velocity and is outputed in the vtu files.
            element output_darcy_vel {
               empty
            }?,
            ## This option is used to calculate the amount of mass flux across a boundary id.
            ## The output is a .csv file containing this information. use this if you want to 
            ## calculate the production.
            element dump_boundaryflux {
            empty,
            ## Surface id:
            element surface_ids {
            integer_vector
            }}?,
	    ## Do not overwrite initial condition with boundary condition.
	    ## Important for checkpointed runs! 
            element initial_condition_overwrites_boundary {
               empty
            }?,
	    ## Whether to enable dumping of checkpointing output.
            ##
            ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options
            element checkpointing {
               ## Checkpointing period, in dumps. Non-negative value
               ## required. A value of zero indicates that checkpoints
               ## should be created at every dump. If
               ## /io/max_dumpfile_count is exceeded then earlier
               ## checkpoints may be overwritten.
               element checkpoint_period_in_dumps {
                  integer
               },
               ## Enable to checkpoint at simulation start.
               element checkpoint_at_start {
                  comment
               }?,
               ## Enable to force a checkpoint at simulation end.
               element checkpoint_at_end {
                  comment
               }?,
               comment
            }?,
            ## Diagnostic output (.stat file) options
            element stat {
               ## Enable to write diagnostic output at simulation start
               element output_at_start {
                  comment
               }?,
               ## Enable to write diagnostic output immediately before mesh adapts
               element output_before_adapts {
                  comment
               }?,
               ## Enable to write diagnostic output immediately after mesh adapts
               element output_after_adapts {
                  comment
               }?,
               comment
            },

            ## Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled. When running in serial, although the output is in principle still generated in ascii format if binary_output is not enabled, it is not certain that it is working well. Hence, it is recommended to enable binary_output and work with binary files. 
            element detectors {
               (
                  ## A single static detector
                  element static_detector {
                     attribute name { xsd:string },
                     (
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## A single lagrangian detector
                  element lagrangian_detector {
                     attribute name { xsd:string },
                     (
                     ## This is the initial location of a detector that moves with the fluid velocity.
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.
                  element detector_array {
                     attribute name { xsd:string },
                     ## The number of detectors prescribed by the python function.
                     element number_of_detectors {
                        integer
                     },
                     (
                        ## Create fixed detectors.
                        element static {
                           empty
                        }|
                        ## Create detectors which move with the fluid velocity.
                        element lagrangian {
                           empty
                        }
                     ),
                     (
                        ## Python function prescribing dimensional vector input. Functions should be of the form:
                        ##
                        ##  def val(t):
                        ##     # Function code
                        ##     return # Return value
                        ##
                        ## The return value must have length number_of_detectors.
                        ##
                        ## *** IMPORTANT NOTE ***
                        ##
                        ## The t argument is for future use only - currently detector locations are only set at simulation start.
                        element python {
                          python_code
                        }|
                        ## File containing the detectors positions in binary form
                        element from_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                              element string_value {
                                 "binary"
                              }
                           }
                        }
                     )
                  }
               )*,
               ## Enable to write detector output in binary format
               element binary_output {
                  comment
               }?,
               element lagrangian_timestepping {
                  (
                     ## Use explicit runge kutta method with
                     ## binary search
                     element explicit_runge_kutta_guided_search {
                        ## Number of subdivisions of the timestep
                        ## increase this if you are not happy with your 
                        ## detector trajectory accuracy, or if particles
                        ## are jumping out of the domain a lot
                        element subcycles {
                           integer
                        },
                        ## Tolerance for deciding if detector is in a given
                        ## element. Recommended value 1.0e-10.
                        element search_tolerance {
                           real
                        },
                        ## Number of RK stages
                        ## For the RK4 method, it should be 4.
                        element n_stages {
                           integer
                        },
                        ## ERK stage array. This is an array
                        ## containing the lower-triangular
                        ## part of the Butcher weight matrix
                        ## A that explains how to compute the
                        ## RK stages.  See
                        ## http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
                        ## for notation.  The array is stored
                        ## in the following order:
                        ## [a_{21},a_{31},a_{32},...,a_{s1},a_{s2},a_{s(s-1)}]
                        ## and so the array has size s(s-1)/2
                        ## where s is the number of stages.
                        ## For the RK4 method, it should be
                        ## [0.5,0,0.5,0,0,1]
                        element stage_weights {
                           real_vector
                        },
                        ## ERK timestep weights. This is the
                        ## b vector that explains how to
                        ## compute the timestep from the RK
                        ## stages.  See
                        ## http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
                        ## for notation.  It should have size
                        ## s where s is the number of stages.
                        ## For the RK4 method, it should be
                        ## [1/6,1/3,1/3,1/6]
                        element timestep_weights {
                           real_vector
                        }
                     }|
                     ## Use binary search algorithm
                     element binary_search {
                        empty
                     }
                  )
               }?
            }?, 
            ## Options to create even more output in the logs:
            ##
            ## Note that the main option to control the log output is given on the command line:
            ##
            ## -v0  only output error and warnings
            ##
            ## -v1  also give "navigational information", to indicate where in the code we currently are
            ##
            ## -v2  also give any additional information (mins and maxes of fields, etc.)
            ##
            element log_output {
               ## Log all allocates and deallocates done for meshes, fields, sparsities and matrices.
               ##
               ## NOTE: Requires -v2
               element memory_diagnostics {
                  empty
               }?
            }?,
            ## If porous_media, printout the Courant number every time-step
            element Courant_number {
               comment
            }?,
            ## Printout the number of elements and percentage that contain an angle
            ## equal or bigger than the ones specified here
	    ## Note: This may slow down your simulation should be used as a diagnostic tool 
            element Mesh_Diagnostics_Angles {
               real_vector
            }?
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Timestep after which the simulation should end.
            element final_timestep {
               integer
            }?,
#            ## Maximum CPU time (in seconds) before the simulation terminates
#            element cpu_time_limit {
#               real
#            }?,
#            ## Maximum wall time (secs) taken up before
#            ## simulation terminates writing results to disc.
#            ## 
#            ## This is usually disabled.
#            element wall_time_limit {
#               real
#            }?,
            ## Maximum number of non-linear iterations for the Fixed-Point iteration solver.
            ## 
            ## Manual suggests 2 for problems that are not very non-linear
            ##
            ## If using Fixed_Point_Iteration for multiphase porous media flow the recommendation is ~ 20
            ## 
            ## If using Fixed_Point_Iteration/Infinite_norm_tol/adaptive_non_linear_iterations to dynamically control the number of 
            ## non-linear iterations or Fixed_Point_Iteration/adaptive_timestep_nonlinear then ~ 15 is recommended.
			element nonlinear_iterations {
               integer,
               ##NOTE: For multiphase porous media only. Otherwise this value is ignored.  
               ##
               ## This is the convergence criterion for the Fixed Point Iteration solver.
               ## The functional to compare is: 
               ##
               ## f = L2norm(S*-So)/L2norm(S1-So)
               ##
               ## S* is the latest saturation; So is the saturation at the previous FPI
               ## S1 is the saturation after the first FPI. Hence, the reduction of the difference
               ## of saturation is tested
               ##
               ## Recommended value: 5e-2
               element Fixed_Point_Iteration{
                  real,
                  (
                    ## Tolerance for the infinite norm of the variation of the normalized selected field
                    ## between two consecutive non-linear iterations.
                    ##
                    ## This can be used to control the number of non-linear interations dynamically.
                    ##
                    ## By default 0.03; Recommended between 0.05 and 0.005
                    element Infinite_norm_tol{
                    real,
                      (
                        ## Use the infinity norm of the selected field to control the number of non-linear interations dynamically.
                        ##
                        ## A Variable to check has to be chosen:
                        ## 1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature 
                        ##
                        ## The field selected in "adaptive_timestep_nonlinear" has preference over this
                        element adaptive_non_linear_iterations{
                        integer
                        }?,
                        ## Sets the infinite tolerance for the internal loop of the temperature transport equation.
                        ## This is an internal solver, so a higher tolerance should be used.
                        ##                    
                        ## Default = 0.05
                        element Temperature_solver_tol{
                        real
                        }?
                      )
                    }?
                  ),
                  (
                    ##
                    ## Recommended settings: Non-linear iterations ~ 20
                    ## Backtracking_parameter = -10 automatically selection based on the Courant number, the shock-front Courant number and the physics of the problem
                    ##
                    ## The Backtracking value introduced is used as reference, so it may have a big impact on the convergence
                    ##
                    ## Recommended settings: Backtracking_parameter = -0.33 or -0.5 or -0.8; 
                    ## Note: Dynamic dumping loops over the Saturation solver up to 9 times and also uses techniques to accelerate the FPI convergence
                    ##
                    ## The more complex the problem is (i.e. bigger time-steps, gravity, capillary, etc) the smaller the value should be
                    element Backtracking_factor{
                    real
                    }?
                  ),
                    ## Introduce over-relaxation in the saturation equation. 
                    ## This severely HELPS to reduce the number of FPI.
                    ##
                    ## If positive, the input value is the entry pressure.
                    ##
                    ## If negative, the input value is Peclet number desired.
                    ##
                    ## Recommended value for Saturation => -1e2
                    ##
                    ## Tip: If running with temperature and single phase disable this setting it to 0.
                    element Vanishing_relaxation{
                    real,
                      (
                        ## This method can also be applied for a transport equation.
                        ##
                        ## Recommended value for Temperature => -1e0
                        element Vanishing_for_transport{
                        real
                        }?
                      )
                    }?,
#                  (
#                    ## THIS ONLY WORKS with automatics dumpings factor, i.e. Backtracking_factor < 0
#                    ##
#                    ## This parameter change the weight ratio used between the old Saturation and the older Saturation to calculate the new Saturation inside an SFPI
#                    ## 
#                    ## 100 => Only the previous saturation is used (more conservative); 
#                    ## 0.4 => Recommended (default); 
#                    ## 0.3 => Older saturation is at some points as important as the old saturation;
#                    ## 0 => Older saturation is more important than old saturation
#                    ## 
#                    ## If having problems converging the recomendation is to try different parameters from 0.2 to 1.0 or disabling totally the acceleration (100)
#                    element Acceleration_exp{
#                    real
#                    }?
#                  ),
                  (
                    ## For TEMPERATURE ONLY, if there are no sources nor sinks
                    ## the non-linear solver can be accelerated by imposing physical constraints. Recommended to use.
	                ## 
		            ## This imposes that the temperature has to be between bounds.
                    element Impose_min_max{empty}?
                  ),
                  (
                    ## Convergence criterion based on the 
                    ## conservation of mass for the Fixed Point Iteration solver
	            ## 
		    ## By default the tolerance is 5e-3
                    element Test_mass_consv{real}?
                  ),
                  (
                    ## Prints the number of iterations and
                    ## the final convergence achieved by the FPI solver
                    element Show_Convergence{comment}?
                  ),
                  (
                    ## Adaptive timestep based on the number of non-linear iterations performed by the FPI solver.
                    ##
                    ## A Variable to check has to be chosen:
                    ## 1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature 
                    element adaptive_timestep_nonlinear{
                        integer,
                      (
                        ## Time-step size controlled using a PID approach.
                        ## By default this method only controls the errors, and based on that increases or decreases the time-step size.
                        ## The default aim of number of FPI is the 20% of the maximum number of non-linear iterations.
                        ## The increase_factor and decrease_factor are multiplied by 1.2 to give more flexibility to the PID controller.
                        ## 
                        ## If this is off, a classical method based on the number of FPI performed is used instead.
                        element PID_controller {
                          empty,
                            ## Time-step size is controlled to try to always perform the specified number of FPI introduced
                            ## here, but in a soft way so if the other checks are performing correctly it can still increase the time-step size. 
                            ## By default this is the 20% of the maximum number of non-linear iterations.
                            element Aim_num_FPI {
                              integer
                            }?
                        }?,
                        ## If any of the solvers failt to achieve convergence the time-step size is 
                        ## reduced and the time-level repeated without waiting to reach the maximum number of FPI.
                        ## Note: For the saturation for porous media it allows to diverge inside the saturation FPI.
                        element ensure_solvers_convergence {
                          empty
                        }?,
                        ## Number of FPI below which the time-step size is increased
                        ## by default it is the 25% of the maximum allowed FPIs
                        element increase_threshold{
                        integer
                        }?,
                        ## Multiply present timestep by this factor when increasing it.
                        ## By default 1.1
                        element increase_factor{
                        real
                        }?,
                        ## Multiply present timestep by this factor when decreasing it.
                        ## By default 2.0
                        element decrease_factor{
                        real
                        }?,
                        ## Maximum timestep. Beyond this value the timestep will not be increased.
                        ## By default unlimmited.
                        element max_timestep{
                        real
                        }?,
                        ## Minimum timestep. Beyond this value the timestep will not be decreased.
                        ## By default dt*1e-3.
                        element min_timestep{
                        real
                        }?
                      )
                    }?
                  )
               }?
            }?,
            ## Vary the timestep according to the courant number.
            element adaptive_timestep {
               ## The timestep will be adjusted (within the tolerance
               ## and bounds specified) to target this courant
               ## number. Timestep adapts occur at the end of each
               ## timestep and after a mesh adapt.
               element requested_cfl {
                  real
               },
               timestep_cfl_number_options,
               ## Minimum time step size.
               ## Manual suggests 0.0
               element minimum_timestep {
                  ## If enabled, signals model termination if a timestep less
                  ## than or equal to the minimum_timestep is requested. The
                  ## model will stop at the end of the timestep in order to
                  ## allow for the latest output to be written. 
                  element terminate_if_reached {
                     comment
                  }?,
                  real
               }?,
               ## Maximum time step size.
               ## Manual suggests 1.E+10
               element maximum_timestep {
                  real
               }?,
               ## The maximum ratio by which the timestep is allowed
               ## to increase in a timestep adapt. e.g., a value of
               ## 1.1 indicates that the timestep may be increased by
               ## at most 10%.
               element increase_tolerance {
                  real
               }?,
               ## Specify whether you want to calculate a new timestep
               ## at the first timestep or not.
               element at_first_timestep {
                  empty
               }?
            }?
         },
	 element projections {
	    ## Options applicable to the projections used in
	    ## the multiphase prototype code
	    element control_volume_projections {
	       element do_not_project {
	          empty
	       }?,
	       (
	       element test_function_space {
	          attribute name {"FiniteElement"}
	       }|
	       element test_function_space {
	          attribute name {"ControlVolume"}
	       }
               ),
	       element solver {
                    linear_solver_options_asym
               }?	        
	    }?
	 }?,
         physical_parameter_options?,
         ## The material or phase options
         element material_phase {
            attribute name { xsd:string },
            ## Flag to identify components in multiphase modelling
            ## 
            ## Pressure and velocity fields must be aliased
            element is_multiphase_component {
               (
                  ## Specify the weighting for the component equation
                  ## between 0 and 1. Test cases have 1.
                  element alpha_beta { real },
                  ## Enable this option to use sigmoid method for finding equilibrium
                  element KComp_Sigmoid {
                     (
                        ## KComp value for this component
                        element K_Comp { real }
                     )
                  }?,
                  ## Enable this option to force component mass fractions
                  ## to sum to 1 by adding constraint into compositional source term.
                  element Comp_Sum2One { 
                     (
                        ## Relaxation coefficient to summation constraint [0,1]. 
                        ## --> 0: under-relaxation ; --> 1: over-relaxation
                        element Relaxation_Coefficient { real },
                        ## Ensure that this constraint acts only as a positive absorption term
                        element Ensure_Positive { empty }?,
                        ## Explicitly enforce components to sum to one
                        element Enforce_Comp_Sum2One { empty }?			
                     )
                  }?,
                  ## Surface tension
                  element surface_tension { 
                     (
                        ## Surface tension coefficient. 
                        element coefficient { real },
                        ## Contact angle. 
                        element angle { real } ?,
                        ##  Smoothing.
                       element smooth { empty } ?
                     )
                  }?
               )               
            }?,
            ## Scale the momentum equation by the volume fraction for when some problems are not well poised.
            element scale_momentum_by_volume_fraction {empty}?,
            ## linearise density
            element linearise_density{ empty }?,
            ## linearise viscosity
            element linearise_viscosity{ empty }?,
            ## linearise component for the bulk density calculation used in the momentum equation
            element linearise_component{ empty }?,
            ## The equation of state
            equation_of_state?,















## Subgridscale parameterisations
            element subgridscale_parameterisations {
               ## Lagrangian-averaged Navier-Stokes equations 
               element LANS {
                  (
                     ## smoothing length specified as isotropic homogeneous
                     element alpha_isotropic_homogeneous {
                        real
                     }|
                     element alpha_anisotropic_homogeneous_cartesian {
                        real_dim_symmetric_tensor
                     }
                  )
                  #               (
                  #                  element leray {
                  #                     empty
                  #                  }|
                  #                  element LANS_momentum_form {
                  #                     empty
                  #                  }|
                  #                  element LANS_stress_form {
                  #                     empty
                  #                  }
                  #               )
               }?,
               ## This is the generic length scale (vertical turbulence mixed layer) model, 
               ## based here on Warner et al 2005, Ocean Modelling 8:81-113,
               ## which is itself based on the works of Umlauf and Burchard 2003.
               ##
               ## The GLS model encodes four individual turbulence closure models which can be chosen via 'option' below.
               ##
               ## You will need to make sure that DistanceToTop and DistanceToBottom fields (under geometry/ocean_boundaries) 
               ## are switched on, as well as PerturbationDensity.
               element GLS {
                  ## The base GLS option:
                  ## 1. k-kl which is a variant of Mellor-Yamada 2.5
                  ## 2. k-epsilon
                  ## 3. k-omega
                  ## 4. 'gen' from Warner et al 2005
                  ##
                  ## k-epsilon is recommended.
                  element option {
                     element string_value {
                     "k-kl"|"k-epsilon"|"k-omega"|"gen"
                     }
                  },
                  ## The stability function choice:
                  ## 1. KanthaClayson-94 which corresponds to Kantha and Clayson 1994
                  ## 2. Galperin-88 which corresponds to Galperin et al 1988
                  ## 3. Canuto-01-A which corresponds to choice A from Canuto et al 2001
                  ## 4. Canuto-01-B which corresponds to choice B from Canuto et al 2001
                  ##
                  ## Canuto A or B are recommended.
                  element stability_function {
                     element string_value {
                     "KanthaClayson-94"|"GibsonLaunder-78"|"Canuto-01-A"|"Canuto-01-B"
                     }
                  },                  
                  ## The wall function choice:
                  ## 1. None - pick this unless you're using k-kl
                  ## 2. Mellor and Yamada (1980) - parabolic shape
                  ## 3. Burchard (1998) - symmetric linear shape
                  ## 4. Burchard (2001) - Used for infinitely deep basins
                  ## 5. Blumberg et al (1992) - open channel flow
                  ##
                  ## See manual for equations.
                  element wall_function {
                     element string_value {
                     "none"|"MellorYamda"|"Burchard98"|"Burchard01"|"Blumberg"
                     }
                  }?,
                  ## Smooth buoyancy frequency before using it?
                  element smooth_buoyancy{
                    empty
                  }?,
                  ## Smooth velocity shear before using it?
                  element smooth_shear{
                    empty
                  }?,
                  ## Do you want the boundary conditions to be set automatically?
                  ## Make sure the ocean geometry settings are enabled for this option
                  element calculate_boundaries {
                     element string_value {
                     "neumann"|"dirichlet"
                     },
                     element top_surface_ids {
                        integer_vector
                     },
                     element bottom_surface_ids {
                        integer_vector
                     }
                  }?,
                  ## Perform relaxation of the diffusivity and viscosity in the GLS model.
                  ## Value should be >=0 and < 1. 0 is no relaxation (i.e. always use the
                  ## most up-to-date value) and 0.9 would represent making the current value
                  ## be 0.9*old_value + 0.1*new_value. Default is 0.0
                  ## If being used with adaptivity, ensure you switch on interpolation of the 
                  ## GLSVerticalDiffusivity and GLSVerticalViscosity fields. You will seg fault
                  ## otherwise.
                  element relax_diffusivity {
                     real
                  }?,
                  ## Add extra parameterisation for internal wave breaking at base of MLD. This
                  ## is based on the same parameterisation in NEMO and smooths the TKE down 
                  ## the water column based on an exponential function
                  ## Set the two parameters: % of TKE to smooth down and length scale to do this over
                  element ocean_parameterisation {
                     element lengthscale {
                        real
                     },
                     element percentage {
                        real
                     }
                  }?,
                  ## Turbulent kinetic energy. Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSTurbulentKineticEnergy" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field,
                           ## Minimum value of TKE in m2s2. A typical value will be around 1e-6
                           element minimum_value {
                              real
                           }
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Generic second equation used in GLS. 
                  ## Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSGenericSecondQuantity" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                      )
                  },
                  ## Background viscosity
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSBackgroundViscosity" },
                     (
                        element prescribed {
                           mesh_choice,
                           prescribed_tensor_field
                        }|
                        element diagnostic {
                           mesh_choice,
                           (
                              sediment_concentration_dependent_viscosity_algorithm
                           ),
                           diagnostic_tensor_field
                        }
                     )
                  },                  
                  ## Background diffusivity
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSBackgroundDiffusivity" },
                     (
                        element prescribed {
                           mesh_choice,
                           prescribed_tensor_field
                        }
                     )
                  },
                  ## Eddy viscosity K_M
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSEddyViscosityKM" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Eddy diffusivity K_H
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSEddyDiffusivityKH" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Length scale (a diagnostic with GLS)
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSLengthScale" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,                  
                  ## Unedited TKE. The TKE filed has the upper and lower surfaces
                  ## altered with Dirichlet conditions for ouput. This is the
                  ## unedited surface.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSTurbulentKineticEnergyOriginal" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Buoyancy frequency
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSBuoyancyFrequency" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Velocity shear
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSVelocityShear" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Shear production P
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSShearProduction" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Buoyancy production B
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSBuoyancyProduction" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Dissipation epsilon
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSDissipationEpsilon" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Stability function S_M
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSStabilityFunctionSM" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Stability function S_H
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSStabilityFunctionSH" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Source1 - TKE source term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSSource1" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Source2 - Second Quantity source term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSSource2" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Absorption1 - TKE absorption term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSAbsorption1" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Absorption2 - Second Quantity absorption term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSAbsorption2" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## GLS Wall function
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSWallFunction" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Vertical eddy viscosity
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSVerticalViscosity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,                  
                  ## Vertical eddy diffusivity
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSVerticalDiffusivity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?
               }?,
               element Mellor_Yamada {
                  ## Kinetic Energy
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "KineticEnergy" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Turbulent Length Scale x Kinetic Energy
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "TurbulentLengthScalexKineticEnergy" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                      )
                  },
                  ## Vertical Viscosity
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "VerticalViscosity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Vertical Diffusivity of Temperature
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "VerticalDiffusivity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?
               }?,
               ## Trivial case in which the user supplies the diffusivity.
               element prescribed_diffusivity {
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "PrescribedDiffusivity" },
                     element prescribed {
                        mesh_choice,
                        prescribed_tensor_field_no_adapt
                     }
                  }
               }?,
               ## Standard k-epsilon turbulence model (see e.g. Ferziger and Peric(2002) p.295).
               ## Solves 2 additional equations for TurbulentDissipation (epsilon) and TurbulentKineticEnergy (k),
               ## in order to close momentum equations.
               ## Generates an isotropic 'eddy viscosity', added to molecular viscosity field, that
               ## carries the influence of turbulence onto the velocity field. See the manual for details.
               element k-epsilon {
                  ## Turbulent kinetic energy (k).
                  ## 1. 'k_esilon'-type boundary conditions are recommended for this field.
                  ## 2. Turn on diffusivity, source and absorption diagnostic fields.
                  ## 3. Use the same mesh as Velocity.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "TurbulentKineticEnergy" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_scalar_field
                        }
                     )
                  },
                  ## TurbulentDissipation (epsilon).
                  ## 1. 'k_epsilon'-type boundary conditions are recommended for this field.
                  ## 2. Turn on diffusivity, source and absorption diagnostic fields.
                  ## 3. Use the same mesh as Velocity.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "TurbulentDissipation" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_scalar_field
                        }
                     )
                  },
                  ## Set the value of the background (laminar) viscosity field here.
                  ## Make it small to see the influence of the eddy viscosity.
                  ## IMPORTANT: make velocity/viscosity diagnostic.
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "BackgroundViscosity" },
                     (
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_tensor_field
                        }|
                        element diagnostic {
                           velocity_mesh_choice,
                           (
                              sediment_concentration_dependent_viscosity_algorithm
                           ),
                           diagnostic_tensor_field
                        }
                     )
                  },
                  ## Set the value of the background (laminar) diffusivity field here.
                  ## This is used to calculate scalar field diffusivities.
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "BackgroundDiffusivity" },
                     (
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_tensor_field
                        }
                     )
                  }?,
                  ## Eddy viscosity (turbulent diffusion of velocity).
                  ## This is a fictitious isotropic viscosity, added to normal viscosity field, that
                  ## carries the influence of turbulence onto the velocity field.
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "EddyViscosity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_tensor_field
                        }
                     )
                  },
                  ## Scalar component of the eddy viscosity tensor.
                  ## This will appear in the stat file.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "ScalarEddyViscosity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_scalar_field
                        }
                     )
                  },
                  ## Integral length scale of the turbulence (diagnostic).
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "LengthScale" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }
                     )
                  },
                  ## f_1 damping coefficient for low_Re k-epsilon model
                  ## Required for low_Re boundaries. If no low_Re boundaries are present
                  ## this will be set to 1.0 throughout the domain and will not
                  ## affect the result
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "f_1" },
                     element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field                        
                     }
                  },
                  ## f_2 damping coefficient for low_Re k-epsilon model
                  ## Required for low_Re boundaries. If no low_Re boundaries are present
                  ## this will be set to 1.0 throughout the domain and will not
                  ## affect the result
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "f_2" },
                     element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field                        
                     }
                  },
                  ## f_mu damping coefficient for low_Re k-epsilon model
                  ## Required for low_Re boundaries. If no low_Re boundaries are present
                  ## this will be set to 1.0 throughout the domain and will not
                  ## affect the result
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "f_mu" },
                     element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field                        
                     }
                  },
                  ## Limit the maximum value of damping function values. This helps stability when using low_Re number
                  ## boundary conditions. If not using low_Re boundaries this will have no effect. 
                  ## Recommended value (default): 10.0
                  element max_damping_value {real},
                  ## Describes distance to nearest solid wall.
                  ## Required for low_Re boundaries.
                  ## For simple geometries the simplest method of providing this information is to use a python function.
                  ## For complex geometries where this is not possible precursive Eikonal equation or Poisson equation
                  ## simulations must be run using Fluidity to determine the values for this field.
                  ## Details of how this is done can be found in:
                  ## Tucker, P 2011: "Hybrid Hamilton/Jacobi/Poisson wall distance function model"
                  ## Elias et al 2007: "Simple finite element-based computation of distance functions in unstructured grids"
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "DistanceToWall" },
                     element prescribed {
                        velocity_mesh_choice,
                        prescribed_scalar_field
                     }
                  }?,
                  ## VLES Filter function (diagnostic).
                  ## Run a VLES by switching this option on.
                  ## If so then filtering is applied to the eddy viscosity.
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "VLESFilter" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }
                     )
                  }?,
                  ## Eddy-viscosity coefficient: nu_T = density * C_mu * k**2 / epsilon.
                  ## Recommended value (default): 0.09.
                  element C_mu {real},
                  ## TurbulentDissipation production coefficient.
                  ## Recommended value (default): 1.44.
                  element C_eps_1 {real},
                  ## TurbulentDissipation destruction coefficient.
                  ## Recommended value (default): 1.92.
                  element C_eps_2 {real},
                  ## Turbulent Schmidt number (eddy viscosity coefficient from k equation).
                  ## This is also the ratio of eddy viscosity to eddy diffusivity for use in other scalar fields.
                  ## Recommended value (default): 1.0.
                  element sigma_k {real},
                  ## Turbulent Schmidt number (eddy-viscosity coefficient from epsilon equation).
                  ## Recommended value (default): 1.3.
                  element sigma_eps {real},
                  ## The Schmidt number (ratio of viscous diffusion rate to momentum diffusion rate) for 
                  ## massive scalar fields, or Prandtl number (ratio of viscous diffusion rate to thermal diffusion rate) 
                  ## for thermal fields. This is used to calculate the turbulent buoyancy term.
                  ## Recommended value (default): 1.0.
                  element sigma_p {real},
                  ## Time discretisation of the source terms in the k and epsilon equations and also
                  ## of the eddy viscosity
                  element time_discretisation {  
                     ## Implicit/explicit control (THETA) of source terms and eddy viscosity in
                     ## the k-epsilon model
                     ##  = 0.  -- explicit
                     ##  = 0.5 -- Crank-Nicolson
                     ##  = 1.  -- implicit
                     element theta {real},
                     ## Each term in the k and epsilon equations can be implemented as either a 
                     ## source or as an absorbtion term. See the manual under 
                     ## 'Parameterisations/Turbulent flow modelling and simulation/Reynolds Averaged Navier Stokes (RANS) Modelling/Standard k − ε Turbulence Model/Time Discretisation and Coupling' 
                     ## for more information.
                     element source_term_implementation { 
                        element production_term { 'source'|'absorbtion' },
                        element destruction_term { 'source'|'absorbtion' },
                        element buoyancy_term { 'source'|'absorbtion' }
                     }
                  },
                  ## The source terms in the k-epsilon model are calculated before the field is 
                  ## solved. The process requires inversion of a mass matrix. This element contains
                  ## options for defining how this is done. For P1 meshes mass lumping can be used,
                  ## for other discretisations the mass matrix can not be easily inverted and so a 
                  ## solve must be carried out, with solver options specified.
                  element mass_terms {  
                     (
                        element lump_mass { empty }
                        |
                        element use_consistent_mass_matrix { 
                           element solver {
                              linear_solver_options_asym

                           }
                        } 
                     )
                  },
                  ## produce vtu output of individual kk and eps source terms and set prescribed 
                  ## source terms for k and epsilon fields (for mms tests)
                  element debugging_options{
                     ## output fields for each of the source terms in the k-epsilon model
                     element source_term_output_fields{
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentKineticEnergy_production_term" },
                           element diagnostic {
                              internal_algorithm,
                              velocity_mesh_choice,
                              diagnostic_scalar_field                        
                           }
                        }?,
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentKineticEnergy_destruction_term" },
                           element diagnostic {
                              internal_algorithm,
                              velocity_mesh_choice,
                              diagnostic_scalar_field                        
                           }
                        }?,
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentKineticEnergy_buoyancy_term" },
                           element diagnostic {
                              internal_algorithm,
                              velocity_mesh_choice,
                              diagnostic_scalar_field                        
                           }
                        }?,
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentDissipation_production_term" },
                           element diagnostic {
                              internal_algorithm,
                              velocity_mesh_choice,
                              diagnostic_scalar_field                        
                           }
                        }?,
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentDissipation_destruction_term" },
                           element diagnostic {
                              internal_algorithm,
                              velocity_mesh_choice,
                              diagnostic_scalar_field                        
                           }
                        }?,
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentDissipation_buoyancy_term" },
                           element diagnostic {
                              internal_algorithm,
                              velocity_mesh_choice,
                              diagnostic_scalar_field                        
                           }
                        }?
                     },
                     ## Enable to apply prescribed source terms into the k and epsilon equations.
                     ## This is useful for MMS tests
                     element prescribed_source_terms{
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentKineticEnergyPrescribedSource" },
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field                        
                           }
                        }?,
                        element scalar_field {
                           attribute rank { "0" },
                           attribute name { "TurbulentDissipationPrescribedSource" },
                           element prescribed {
                              velocity_mesh_choice,
                              prescribed_scalar_field                        
                           }
                        }?
                     },
                     ## enabling this option disables the production term in the k and epsilon equations
                     element disable_production_term{ empty }?,
                     ## enabling this option disables the destruction term in the k and epsilon equation
                     element disable_destruction_term{ empty }?,
                     ## enabling this option disables the bouyancy term in the k and epsilon equation
                     element disable_buoyancy_term{ empty }?,
                     ## enabling this option enables the low-Re number damping functions regardless of whether there is
                     ## a low-Re boundary condition
                     element enable_lowRe_damping{ empty }?,
                     ## Enabling this option disables feedback from the k-epsilon model back into 
                     ## the rest of the model. Reynolds stress tensor is set to zero by zeroing 
                     ## EddyViscosity and the added source term, based on k, in the momentum equation.
                     ## Hence, Viscosity will always stay as the BackgroundViscosity,
                     ## diffusivities will remain at the relevant BackgroundDiffusivity, and the 
                     ## momentum equation will be as if there were no turbulence model present. 
                     ## 
                     ## ScalarEddyViscosity is still calculated as normal.
                     element zero_reynolds_stress_tensor{ empty }?
                  }?
               }?
            }?,

















            ## Pressure
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Pressure" },
               ## Field type
               (
                  element prognostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prognostic_pressure_field
                  }|
                  element prescribed {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prescribed_scalar_field
                  }|
                  ## Compute pressure from Density and InternalEnergy
                  ## via a compressible equation of state.
                  element diagnostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     internal_algorithm,
                     diagnostic_scalar_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Pressure" }
                  }
               )
            }?,
            ## Density
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Density" },
               ## Field type
               (
                  element diagnostic {
                     internal_algorithm,
                     velocity_mesh_choice,
                     diagnostic_scalar_field
                  }|
                  element prognostic {
                     pressure_mesh_choice,
                     prognostic_density_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Density" }
                  }
               )
            }?,
            ## Velocity vector and momentum options
            element vector_field {
               attribute rank { "1" },
               attribute name { "Velocity" },
               ## Field type
               (
                  element prognostic {
                     velocity_mesh_choice,
                     prognostic_velocity_field
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_vector_field
                  }|
                  element diagnostic {
                     velocity_mesh_choice,
                     vector_python_diagnostic_algorithm,
                     diagnostic_vector_field
                  }|                  
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Velocity" }
                  }
               )
            },
            scalar_field_choice*,
            vector_field_choice*,
            tensor_field_choice*,
            ## Parameters required to model multiphase flow
            element multiphase_properties {
               ## Option for relperm type in prototype code
                  ## Corey relperm:
                  ##
                  ## relperm = relperm_max * ((Sat-S_immobile)/(1-Sum(Immobile_saturations)))^relperm_exponent
               element Relperm_Corey {
                     ## Relative permeability end point
                     ##
                     ## Value between 0 and 1. Default value 1.0
                    element scalar_field {
                       attribute name { "relperm_max" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }
                       )
                    },
                     ## Relative permeability exponent
                     ##
                     ## Default value 2.0
                     element scalar_field {
                        attribute name { "relperm_exponent" },
                        (
                           element prescribed {
                              material_mesh_choice,
                              prescribed_scalar_field
                  }
                        )
                     }
                }?,
		## Mark phase as being the continuous phase in dispersed fluid-fluid flow
		element continuous_phase {
		     comment
		}?,
		(
		   element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "Linear" },
			 element diameter {real},
			 element coefficient{real},
			 comment
		   }|
		    element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "Bilinear" },
			 element diameter {real},
			 element coefficient{real},
			 comment
		   }|
		   element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "Quadratic" },
			 element diameter {real},
			 element coefficient{real},
			 comment
		   }|element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "Wen&Yu" },
			 element diameter {real},
			 element specified_continuum_viscosity{
			 ## Specify a value for the continuum_phase_viscosity to be used in calculating the drag term. If this is not set, the code defaaults to using the actual viscosity field specfied in the description continuum phase
			 real
			 }?,
			 comment
		   }|element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "Gidaspow" },
			 element diameter {real},
			 element coefficient{real},
			 comment
			  }|element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "SmoothedGidaspow" },
			 element diameter {real},
			 element specified_continuum_viscosity{
			 ## Specify a value for the continuum_phase_viscosity to be used in calculating the drag term. If this is not set, the code defaaults to using the actual viscosity field specfied in the description continuum phase
			 real
			 }?,
			 comment
		   }|element drag {
		        ## Options controlling form of drag terms for dispersed fluid-particle interactions
			 attribute name { "python_function" },
			 element function {
	 		 	  python_code
		         },	  			  
			element argument {
			    attribute name { xsd:string },
	    		(
	    		element type {
	      	   	    attribute name { "scalar_field"}
	    		}|
	    		element type {
	      	   	    attribute name { "vector_field"}
            		}|
            		element type {	
                   	    attribute name { "tensor_field"}
	    		}),
	    		element material_phase {
		   	   attribute name {xsd:string}
			}?
	    		}+,
			comment
			}
	       )?,
	       ## apply fluidic drag to polydispersed phase interactions
	       element polydispersive_drag {
	       	  element lubrication_distace {real} ,
		  comment
	       }?,
	       ## Apply additional solid-solid interactions in polydispersed solid-fluid flow
	       element solid_solid_interactions {
	            ## Turns on Syamlal (1987) closure 	 	  			 
	            element closure {
		        attribute name {"Syamlal"},
		        element coefficient_of_friction {real},
			element radial_distribution_function {
			     attribute name {"Lebowitz"},
			     comment
			},	
		    	comment}?,
		    comment
	       }?,
	       element coarse_graining {integer}?,	      
               ## Option for capillary pressure				 
               element capillary_pressure {
                  ## Brooks-Corey equation
                  ##
                  ## Pc = c * ((S_w-Swir)/(1-Swirr-Sor)) ** -a; here c is the entry pressure
                  ##
                  ## For imbibition swith the formula is:
                  ##
                  ## ## Pc = c * ( ((S_w-Swir)/(1-Swirr-Sor)) ** -a ) - B; here c - B is the entry pressure 
                  ##
                  ## You should specify this ONLY for the wetting phase
                  element type_Brooks_Corey {
                    ## Entry pressure of the formula
                    element scalar_field {
                       attribute name { "C" },
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      } 
                    },
                    ## Imbibition term. if on, entry pressure = C - B;
                    ## By default this value is set to zero.
                    element scalar_field {
                       attribute name { "B" },
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      } 
                    }?,
                    ## exponent -a
                    element scalar_field {
                       attribute name { "a" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }}?,
	          ## Power Law equation
                  ## 
                  ## Pc = c*(1-s_eff)**a
		  ##
		  ## where s_eff = (S_w-Swir)/(1-Swir-Sor)
		  ##
		  ## c = maximum pc pressure; a = pc exponent
		  ## 
		  ## (no entry pressure) 
                  ## 
                  ## ONLY specify for the wetting phase
		  element type_Power_Law {
                    ## Maximum pressure
                    element scalar_field {
                       attribute name { "C" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    },
                    ## exponent a
                    element scalar_field {
                       attribute name { "a" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }}?
               }?,
               ## Immobile volume of fluid phase
               element immobile_fraction {
               ## Immobile fraction
                    element scalar_field {
                       attribute name { "value" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }
                       )
                    }
               }?
            }?
         }+,
         mesh_adaptivity_options?,
         ## Porous Media
         element porous_media {
            ## Specify scalar field Porosity
            element scalar_field {
               attribute name { "Porosity" },
               (
                  element prescribed {
                     material_mesh_choice,
                     prescribed_scalar_field
                  }|
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify field Permeability
            (
               element scalar_field {
                  attribute name { "Permeability" },
                  (
                     element prescribed {
                        material_mesh_choice,
                        prescribed_scalar_field
                     }|
                     element aliased {
                        generic_aliased_field
                     }
                  )
               }|
               element vector_field {
                  attribute name { "Permeability" },
                  element prescribed {
                     material_mesh_choice,
                     prescribed_vector_field
                  }
               }|
               element tensor_field {
                  attribute name { "Permeability" },
                  element prescribed { 
                     material_mesh_choice,
                     prescribed_tensor_field
                  }
               }|
               element Permeability_from_femdem {
                  attribute name { xsd:string },
                  element background_permeability { real }
               }
            ),
            ## Parameters for thermal porous media simulations
            element thermal_porous{
                ## Specify scalar field density of the porous media
                element scalar_field {
                   attribute name { "porous_density" },
                   (
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify scalar field heat capacity of the porous media
                element scalar_field {
                   attribute name { "porous_heat_capacity" },
                   (
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify field Thermal conductivity of the porous media
               element tensor_field {
                  attribute name { "porous_thermal_conductivity" },
                  element prescribed { 
                     material_mesh_choice,
                     prescribed_tensor_field
                  }
               }
             }?
         }?,
         ## Options to specify the wells/pipes
         element wells_and_pipes {
            ## Option to define laterals from diamond
            ## if in doubt set it to 1.
            element scalar_field {
               attribute name { "Pipe" },
               (
                  element prescribed {
                     material_mesh_choice,
                     prescribed_scalar_field
                  }|
                element diagnostic {
                  vector_python_diagnostic_algorithm,
                  diagnostic_scalar_field_no_adapt
                }| 
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify where and how much the well/pipes are opened
            ## It goes from 0 to 1. If completely opened, set it to 1.
            element scalar_field {
               attribute name { "Gamma" },
               (
                  element prescribed {
                     pressure_mesh_choice,
                     prescribed_scalar_field
                  }|
                element diagnostic {
                  vector_python_diagnostic_algorithm,
                  diagnostic_scalar_field_no_adapt
                }| 
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Absorption in the pipes.
            ## If none, set it to 1.
            ##
            ## Recommended. set to 1 and/or use the internal method based on the Moody diagram that can be selected in
            ## /wells_and_pipes/well_options/calculate_sigma_pipe 

            element scalar_field {
               attribute name { "Sigma" },
               (
                  element prescribed {
                     subcv_mesh_choice,
                     prescribed_scalar_field
                  }|
                element diagnostic {
                  vector_python_diagnostic_algorithm,
                  diagnostic_scalar_field_no_adapt
                }| 
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify the diameter of the pipe.
            ## This effectively defines where and where not there is a pipe.
            ## If the diameter is <=0 no pipe, else there is pipe.
            element scalar_field {
               attribute name { "DiameterPipe" },
               (
                  element prescribed {
                     pressure_mesh_choice,
                     prescribed_scalar_field
                  }|
                element diagnostic {
                  vector_python_diagnostic_algorithm,
                  diagnostic_scalar_field_no_adapt
                }| 
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify thermal well-related options
            element thermal_well_properties {
                ## Specify the conductivity of the well/pipe material.
                ## If there are several layers this, it has to be the equivalent conductivity from inside the well/pipe to
                ## the reservoir.
                ## This is only required for heat transport
                element scalar_field {
                   attribute name { "Conductivity" },
                   (
                      element prescribed {
                         pressure_mesh_choice,
                         prescribed_scalar_field
                      }|
                    element diagnostic {
                      vector_python_diagnostic_algorithm,
                      diagnostic_scalar_field_no_adapt
                    }| 
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify the thickness of the well/pipe.
                ## If there are several layers this, it has to be the equivalent thiness from inside the well/pipe to
                ## the reservoir.
                ## This is only required for heat transport
                element scalar_field {
                   attribute name { "well_thickness" },
                   (
                      element prescribed {
                         pressure_mesh_choice,
                         prescribed_scalar_field
                      }|
                    element diagnostic {
                      vector_python_diagnostic_algorithm,
                      diagnostic_scalar_field_no_adapt
                    }| 
                      element aliased {
                         generic_aliased_field
                      }
                   )
                }
            }?,
            ## Specify well-related options
            element well_options {
               ## Calculate the well \sigma field internally
               ## using a non-linear friction factor.
               ## This will over-write the field specified in Sigma1.
               element calculate_sigma_pipe{
                  # Defaults to 1.0e-6.
                  element pipe_roughness{ real }?
               }?,
               ## Factor by which to reduce the pipe eqns time step size e.g. 10^{-3}
               element dt_pipe_factor{ real }?,
               ## Switches wells on and off to optimise production
               element switch_wells_on_and_off{
                  element phase_exclude{ integer }
               }?,
                ## If when using mesh adaptivity the well path is disappearing, this tolerance can probably solve the problem.
                ## .bdf files have only 6 digits precision, therefore for coordinates bigger than 1000 this values might need to be reduced and
                ## the other way round for values below 100.
                ## The default value is 1e-2.
                element wells_bdf_tolerance {
                  real
                 }?
            }?,

            ## When using mesh adaptivity, introduce here the ids of the prisms of the wells to ensure
            ## that the well trajectories are preserved.
            element well_volume_ids {
              integer_vector,
                  (
                    ## Output the ids of the wells
                    element Show_well_volumes_ids{comment}?
                  )
             }?,
             ## Introduce here the relative path to the file defining a 1D well
             ##
             ## Note that the only accepted file format is NASTRAN, i.e. .bdf.
             ## Each file has to describe a continuous well touching an external boundary.
             element well_from_file {
             attribute name { string },
             attribute file_path { string }                  
            }*
         }?,
        ## Fracking options
         element femdem_fracture {
         (
            ## Specify FEMDEM input file
            element femdem_file {
               attribute name { xsd:string }
            }?,
	    element oneway_coupling_only {
	       attribute rank {"0"},
               ("1way"|"p2way")
	    }?,
            element include_pore_pressure {
               empty
	    }?
         )
         }?,
         ## Blasting options
         element blasting {
            ## Specify FEMDEM input file
            element femdem_input_file {
               attribute name { xsd:string }
            },
            element Gidaspow_model {
               attribute rank {"0"},
               ("A"|"B")
            },
            ## =1 treats the solid-fluid coupling implicitly in continuity.
            ## =0 assumes the continuity for the solid is already satified.
            ## Recommended value: [0.5,1.0]. Default =1.
            element theta_cty_solid {
               real
            }?,
            element include_viscous_drag_force {
               empty
            }?
         }?,
         ## Flooding parameters
            element flooding{
             ## This is the term Nm of the manning formula:
             ## b = Nm^2*g * |u|/h^1.33; 
             ## Nm is the manning coefficent. Values between [0.01 and 0.025];
             ## Nm = 0.011 for smooth asphal and Nm = 0.024 to rubble.
             ## For no friction set this to zero or do not activate it.
                 element scalar_field {
                    attribute name { "manning_coef" },
                    (
                       element prescribed {
                          material_mesh_choice,
                          prescribed_scalar_field
              }
                    )
                 },
               ##Perform the mean of the bathymetry when calculating the Manning formula;
               element averaging {
               comment
            }?,
               ##Factor that controls the strenght of the drag introduced in the dry areas;
               ## it has a simmilar effect as the artificial diffusion. Default value = 1e-1.
               element shallow_drag {
               real
            }?
         }?,
         ## numerical_methods options
         element numerical_methods {
            ## Use a method to avoid distortion due to boundaries
            element use_reflect_method {
               empty
            }?,     
            ## Upwinding is used for the parts of the domain where there is no shock-front nor rarefaction.
            ## Elsewhere a high-order advection scheme is used. This should increase the speed of the simulation.
            element local_upwinding {
               empty
            }?,     
            ## Use the diagonal simple version of the mass matrix. M_ii=(Vol/U_NLOC)
            ## This is os by default for the CV pressure formulation 
            element simple_mass_matrix {
               empty
            }?,  
            ## For the CV pressure formulation this controls the homogenisation of the velocity nodes of per element
            ## the bigger it is the more P0DG the element becomes. The default values have been obtained so the results are stable.
            ## The default value for P1DGP1 => 1e4 and disabled for other element types.
            ## To disable it manually, set it to negative values. 
            element CV_press_homogenisation {
               real
            }?,
            ## Look for bad elements to change its anisotropic permeability to improve their quality
            element Bad_element_fix {
          ## Select angle considered too large (degrees) 
	  ## Default is 177
          element Angle{real}?,
          ## What Kv/Kh ratio to use to artifically stretch element
          ## Default is 0.01
          element KvKh_ratio{real}?
	    }?,
            ## Use the fast method to create the pressure matrix. Be aware that some methods only work with the slow method
            element create_P_mat_fast {
               empty
            }?
         }?
      }
   )

prognostic_density_field =
   (
      scalar_equation_choice?,
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Continuous Galerkin formulation.
            element continuous_galerkin {
               advection_stabilisation_options,
               ## Discretisation options for the advection terms.
               element advection_terms {
                  ## Integrate the advection terms of the momentum equation by
                  ## parts.
                  element integrate_advection_by_parts {
                     comment
                  }?
               },
               ## Discretisation options for the mass terms.
               element mass_terms {
                  ## Lump the mass matrix
                  element lump_mass_matrix {
                     empty
                  }?
               },
               comment
            }|
            ## Use a control volume discretisation.
            element control_volumes {
              spatial_control_volume_options
            }
         ),
         ## Conservative discretisation of field advection equation
         ##  TBETA=1. -- conservative (divergence form)
         ##  TBETA=0. -- non-conservative
         ##  0. < TBETA < 1.
         element conservative_advection {
           real
         }
      },
      element temporal_discretisation {
         ## Implicit/explicit control (TTHETA)
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicholson
         ##  =1.  -- implicit
         element theta {
            real
         },
         temporal_control_volume_options?
      },
      (
         ## Solver
         element solver {
            linear_solver_options_asym
         }|
         ## Assume this field is being solved explicitly and skip the solver.
         ##
         ## ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.
         ##
         ## Assumes lhs matrix only has diagonal lumped mass (times
         ## density if appropriate for equation)
         ## and divides the rhs by this.
         element explicit {
            empty
         }
      )?,
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids?,
            input_choice_initial_condition_real
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               ## Apply the dirichlet bc weakly.  Available
               ## automatically with discontinuous_galerkin,
               ## and control_volume spatial_discretisations.
               ## If not selected boundary conditions are applied strongly.
               element apply_weakly {
                  ## If the initial condition and boundary conditions
                  ## differ, setting this option will cause the initial
                  ## condition on the boundary to be overwritten with
                  ## the boundary condition. Since you are applying the
                  ## boundary condition weakly, you probably do *not*
                  ## want this.
                  element boundary_overwrites_initial_condition {
                     empty
                  }?
               },
               input_choice_real
            }
         )
      }*,
      ## source term
      element scalar_field {
         attribute name { "Source" },
         attribute rank { "0" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt,
               recalculation_options?
            }|
            ## This only works for traffic modelling
            element diagnostic {
              internal_algorithm,
              diagnostic_scalar_field_no_adapt
            } 
         )
      }?,
      ## Absorption term
      element scalar_field {
         attribute name { "Absorption" },
         attribute rank { "0" },
         element prescribed {
            prescribed_scalar_field_no_adapt
         }
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?,
      ## Set the priority of this field
      ## This determines the order in which scalar_fields are solved for:
      ##  - higher numbers have the highest priority
      ##  - lower numbers (including negative) have the lowest priority
      ##  - default if not set is 0
      element priority {
         integer
      }?
   )

geometry = 
   (
      ## Options dealing with the specification of geometry
      element geometry {
         ## Dimension of the problem.
         ## <b>This can only be set once</b>
         element dimension {
            element integer_value {
               attribute rank {"0"},
               ("3"|"2"|"1")
            }
         },
         ## The position mesh
         element mesh {
            attribute name { "CoordinateMesh" },
            mesh_info
         },
         ## The velocity mesh
         element mesh {
            attribute name { "VelocityMesh" },
            mesh_info
         }?,
         ## The pressure mesh
         element mesh {
            attribute name { "PressureMesh" },
            mesh_info
         }?,
         element mesh {
            attribute name { xsd:string },
            mesh_info,
            element exclude_from_mesh_adaptivity{empty}?
         }*,
         ## Quadrature
         element quadrature {
            ## Quadrature degree
            ## 
            ## note: this specifies the degree of quadrature,
            ## not the number of gauss points
            element degree {
               integer
            },
#            ## Surface quadrature degree
#            ## 
#            ## note: this specifies the degree of surface
#            ## quadrature not the number of surface gauss points
#            element surface_degree {
#               integer
#            }?,
#            ## Sets the degree of quadrature on each quadrilateral
#            ## face of the control volume. 
#            ##
#            ## Defaults to 1 if
#            ## unselected which is the same as pre-new options
#            ## behaviour.
#            element controlvolume_surface_degree {
#               integer
#            }?,
#            ## Select which family of quadrature rules to use.
#            ## The default is family_cools.
#            ## family_wandzura allows for degree up to 30
#            ## on triangular meshes.
#            ## family_grundmann_moeller allows for degree up to
#            ## 29 on simplicial meshes in arbitrary dimension.
            element quadrature_family {
               element string_value {
                  ( "family_cools" | "family_grundmann_moeller" | "family_wandzura" ) 
               }
            }?
         },
        ## Use Fluidity to overwrite the input .msh file into a binary .msh file. 
        ##
        ## Useful to convert your ASCII msh files into binary to be able to decompose the mesh.
        element create_binary_msh {
           empty
        }? 
      }
   )


# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?,
      interpolation_algorithm_scalar?
   )
   
# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,      
      diagnostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_vector_field,
      recalculation_options?,
      interpolation_algorithm_vector?
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_output_options,
      diagnostic_tensor_stat_options,
      adaptivity_options_tensor_field,
      interpolation_algorithm_vector?
   )

diagnostic_cv_gradient_vector_field =
   (
      ## Choose whether the mass matrix is lumped or not
      element lump_mass_matrix {
            empty
      }?,
      ## Solver options are necessary if you're not lumping your mass or if you're field isn't dg
      element solver {
         linear_solver_options_sym
      }?,
      ## Normalise the gradient by its magnitude
      element normalise {
        empty
      }?,
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_gradient_vector_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_cv_divergence_scalar_field =
   (
      # No solver options because it can be solved directly!
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

diagnostic_fe_divergence_scalar_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

# three optional input vectors for user-specified rotation matrix
rotation_matrix_components =
   (
      ## Select if you want to specify the normal direction
      ## of the rotation matrix.
      ## If off then fluidity computes the normal
      ## If on the tangents vectors must also be specified.
      element normal_direction {
         input_choice_real_dim_vector
      }?,
      ## specify first unit tangent vector to boundary
      element tangent_direction_1 {
         input_choice_real_dim_vector
      }?,
      ## specify second (if exists, i.e. if 3d) unit tangent vector to boundary
      element tangent_direction_2 {
         input_choice_real_dim_vector
      }?
   )

velocity_components_choice =
   (
      (
         element align_bc_with_surface {
            element normal_component {
               input_choice_real
            }?,
            element tangent_component_1 {
               input_choice_real
            }?,
            element tangent_component_2 {
               input_choice_real
            }?,
            rotation_matrix_components,
            ## this will calculate the determinant of the
            ## rotation matrix for every boundary node
            ## and dump a vtu with the node 
            ## normals and tangenials 1/2
            element debugging_mode{empty}?
         }|
         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## NOT USED - choose "dirichlet" instead for the cty bcs
         ##
         ## This applies a Dirichlet condition through the continuity equation
         ## and thus will only apply a normal component of this specified
         ## velocity as the boundary condition.
         element type {
            attribute name { "dirichlet_continuity" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## This applies a Dirichlet condition through the viscous terms in the
         ## momentum equation. It will be applied to each of the components specified.
         element type {
            attribute name { "dirichlet_viscosity" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## This applies a Dirichlet condition for the advection velocity
         ## of the momentum equation.
         element type {
            attribute name { "dirichlet_advection" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         ## Add a bulk formulae boundary condition. Only makes sense
         ## on the Velocity field.
         element type {
            attribute name { "bulk_formulae" },
               empty
         }|
         element type {
           attribute name { "free_surface" },
           (
              ## This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far. 
              ## Note: Once activated, the stabilisation term will occur in all free surface areas in the domain. 
              ## IN DEVELOPMENT
              element surface_stabilisation {
                  ## Scale factor for the surface stabilisation.
                  element scale_factor{
                    real
                  }
              }?
           )
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                ## Use the Manning-Strickler formulation:
                ## n^2*g*|u|*u/H^(1/3)
                ## where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.
                ##
                ## The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)
                element manning-strickler {
                   empty
                }?
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|


         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density 
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air. 
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the 
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the 
                  ## recommended (non-dimensional) value of 1.0 for 
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real},
            ## if not set then Cb=2*h, where h is the element size
            element Cb {real}?
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }|
         ## Dummy BC
         ##
         ## Should be used in combination with the near_wall_treatment condition.
         ## When activated wall treatment is not applied on the wall-outflow edge.
         element type{
            attribute name { "outflow" }
         }|
         ## Momentun BC
         ##
         element type{
            attribute name { "momentum" },
            velocity_components_choice
         }|
         ## Momentun BC
         ##
         element type{
            attribute name { "momentuminout" },
            velocity_components_choice
         }
      )
   )
   
# Output options for prognostic fields
prognostic_scalar_output_options =
   (
      ## Specify what is written to vtu dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Output a file details the convergence (or otherwise) of
         ## this field with every advective nonlinear
         ## iteration.
         ## ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.
         element convergence_file {
            comment
         }?
      }
   )

# Output options for pressure (can't have a convergence file)
pressure_output_options =
   (
      ## Specify what is written to vtu dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Write out some extra debugging vtu files that can be used
         ## to analyse what goes on in the pressure projection steps.
         ## WARNING: this may create a huge amount of vtu files, as 
         ## multiple files are written per nonlinear iteration.
         element debugging_vtus {
            empty
         }?
      }
   )

# Output options for prognostic fields
prognostic_vector_output_options =
   (
      ## Specify what is written to dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?
      }
   )
   
# Field output options for all other fields
field_output_options =
   (
      ## Specify what is written to dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            comment
         }?,
         ## To be used with time-averaged diagnostic fields so that they can be checkpointed.
         element checkpoint {
            empty
         }?
      }
   )
field_output_options_disabled =
   (
      ## Specify what is written to vtu dump files.
      element output {
         (
            ## Exclude this field from dump files.
            element exclude_from_vtu {
               comment
            }|
            ## Include this field in dump files.
            element include_in_vtu {
               comment
            }
         )
      }
   )
   
diagnostic_output_options = field_output_options
prescribed_output_options = field_output_options

# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options = 
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )
  
# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat
         
      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat = 
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )   
   
# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_enabled_default = include_stat
tensor_field_stat_options_enabled_default |= exclude_components_from_stat
tensor_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_disabled_default = exclude_stat
tensor_field_stat_options_disabled_default |= exclude_components_from_stat
tensor_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_velocity_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_velocity_stat_options.stat
         )
      }      
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Diagnostic statistics for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_tensor_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options
prescribed_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_velocity_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_velocity_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         ## Enable to output the pressure and viscous terms separately (as well
         ## as the total force)
         element output_terms {
            comment
         }?,
         integer_vector
      }?,
      ## Compute the divergence of this field at the Gauss points
      ## and return its stats.  This is a direct measure of the
      ## divergence at the gauss points rather than a discrete measure
      ## at the nodes (provided by several other diagnostic fields).
      element divergence_stats {
        empty
      }?,
      ## Calculate the error in the conservation of momentum
      ## IN PROGRESS - Does not include all terms!
      element calculate_momentum_conservation_error {
         empty
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Combining of stat elements for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options.stat =
   (
      tensor_field_stat_options_enabled_default
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields, 
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that FLUIDITY knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.

         ## Salinity
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Salinity" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Temperature" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Background Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BackgroundTemperature" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CopiedField - This field copies the previous timesteps
         ## values from another (specified) field at every iteration
         ## and then solves the field using different (again, specified)
         ## scheme and solution options.
         ## For instance, this field can be used to create a diffused
         ## field to adapt to.
         ## Unless someone requests otherwise this is only currently possible
         ## for fields within the same material_phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopiedField" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  attribute copy_from_field { string },
                  prognostic_scalar_field
               }
            )
         }|
         ## Calculate the stream function of 2D incompressible flow. Note 
         ## that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
         ## Requires a continuous mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "StreamFunction" },
            (
               element prognostic {
                  mesh_choice,
                  prognostic_stream_function_field
               }
            )
         }|
         ## PhaseVolumeFraction
         ## Required in porous_media and multiphase problem types
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt,
                  cap_option?
               }
            )
         }|
         ## ComponentMassFractionPhase1
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         ##
         ## Do not forget to set boundary conditions for the PhaseVolumeFraction
         ## even if the problem is one-phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase1" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  velocity_mesh_choice,
                  equation_of_state,
                  prognostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt,
                  cap_option?
               }
            )
         }|
         ## ComponentMassFractionPhase2
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         ##
         ## Do not forget to set boundary conditions for the PhaseVolumeFraction
         ## even if the problem is one-phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase2" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  velocity_mesh_choice,
                  equation_of_state,
                  prognostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt,
                  cap_option?
               }
            )
         }|
         ## ComponentMassFractionPhase3
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         ##
         ## Do not forget to set boundary conditions for the PhaseVolumeFraction
         ## even if the problem is one-phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase3" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  velocity_mesh_choice,
                  equation_of_state,
                  prognostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt,
                  cap_option?
               }
            )
         }|
         ## ComponentMassFractionPhase4
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase4" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  velocity_mesh_choice,
                  equation_of_state,
                  prognostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt,
                  cap_option?
               }
            )
         }|
         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }
         
# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.

         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|

         ## Finite element interpolation of CV solution
         ## of the PhaseVolumeFraction (which could be saturation).
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFractionFEInterpolation" },
            element diagnostic {
               internal_algorithm,
               mesh_choice, 
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the Density of this phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DensityFEInterpolation" },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the Temperature of this phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "TemperatureFEInterpolation" },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the component mass fraction.
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionFEInterpolationPhase1" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the component mass fraction.
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionFEInterpolationPhase2" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the component mass fraction.
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionFEInterpolationPhase3" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the component mass fraction.
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionFEInterpolationPhase4" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## Finite element interpolation of CV solution
         ## of the component sum concentration.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentSumConcentrationFEInterpolation" },
            element diagnostic {
               internal_algorithm,
               mesh_choice,
               diagnostic_scalar_field
            }
         }|
         ## ControlVolumeDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the control volume C^T matrix.
         ## This assumes that the test space is discontinuous
         ## control volumes.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## FiniteElementDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the finite element C^T matrix.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FiniteElementDivergence" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_fe_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## DG_CourantNumber
         ##
         ## Courant Number as defined on a DG mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DG_CourantNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Grid Reynolds number
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridReynoldsNumber" },
            (element diagnostic {
               internal_algorithm,
               velocity_mesh_choice,
               diagnostic_scalar_field
            }
            | element aliased { generic_aliased_field })
         }|
         ## GridPecletNumber
         ##
         ## Peclet Number Pe = U*dx/2*diffusivity
         ##
         ## Also see the test case 'grid_peclet_number'
         ## if you wish to see the effect of changing the 
         ## diffusivity on a 1D, cg-discretised tracer-field
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridPecletNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  ## Mesh on which to calculate dx
                  mesh_choice,
                  ## This is the name of the scalar field
                  ## to calculate the Peclet number for
                  ## Note this field needs to have a diffusivity
                  element field_name { string },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Horizontal velocity divergence:
         ##
         ## div_H velocity
         ##
         ## Uses the gravity field direction to determine the horizontal plane.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalVelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Velocity divergence:
         ##
         ## div velocity
         ##
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Vorticity for a 2D field:
         ##
         ##  du   dv
         ##  -- - --
         ##  dy   dx
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Vorticity2D" },
            (
               element diagnostic {
                  vorticity_2d_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Gravitational potential energy density:
         ##
         ## -rho*(g dot (r - r_0))
         ##
         ## where rho is the Density scalar field
         ## r_0 is the potential energy zero point
         ## and g is the gravity vector
         ##
         ## BE AWARE OF WHAT IS IN THE DENSITY SCALAR FIELD
         ##
         ## Limitations:
         ##  - Requires a constant gravity direction.
         ##  - The Density and GravitationalPotentialEnergyDensity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GravitationalPotentialEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  ## Coordinate of a point with a potential energy of zero.
                  element zero_point {
                     real_dim_vector
                  }
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Local average mesh edge lengths
         element scalar_field {
          attribute rank { "0" },
            attribute name { "MeshEdgeLengths" },
            (
              element diagnostic {
                  scalar_edge_lengths_algorithm,
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the horizontal stream function psi where:
         ##   \partial_x \psi = -v
         ##   \partial_y \psi = u
         ## where u and v are perpendicular to the gravity direction. Applies a
         ## strong Dirichlet boundary condition of 0 on all boundaries.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalStreamFunction" },
            attribute depends { "Velocity" },
            (
              element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  ## Solver
                  element solver {
                     linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Speed:
         ##
         ##  |u|
         ##
         ## Limitations:
         ##  - The Speed and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Speed" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the nodes of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "NodeOwner" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## An estimate of the edge wieghts whilst adapting using Zoltan
         ## Note: you *must* turn on inteprolation otherwise this field
         ## will be emptied by an adapt.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaxEdgeWeightOnNodes" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## SumVelocityDivergence
         ##
         ## Diagnostic field used in multiphase simulations.
         ## Sums up the divergence of each phase's bulk velocity, i.e. \sum{ div(vfrac*u) }
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SumVelocityDivergence" },
            (
               element diagnostic {
                  velocity_mesh_choice,
                  internal_algorithm,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_scalar_field_no_adapt,
                  element solver {
                     linear_solver_options_sym
                  }
               }
            )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "SolidConcentration" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "Dummy" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "TotalFlux" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "DummyT" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "CV_Pressure" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }
# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prognostic_fields_below___ {
            empty
         }|
#
# -- List of fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|

         ## Projection of the Velocity vector field of this material_phase 
         ## that uses an overlapping formulation to a conventional DG function space. 
         element vector_field {
             attribute rank { "1" },
             attribute name { "VelocityOverlappingProjectedToDG" },
             
             element diagnostic {
                internal_algorithm,
                mesh_choice,
                diagnostic_vector_field
             }
         }|
         ## Gradient of a scalar field evaluated using the C gradient
         ## matrix constructed using finite elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_gradient_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T divergence matrix constructed using finite
         ## elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementDivergenceTransposed" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T matrix constructed using control volumes.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "ControlVolumeDivergenceTransposed" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## LinearMomentum field.
         ##  p = \rho*u 
         ## (where p is the linear momentum, \rho the density and u the velocity)
         element vector_field {
             attribute rank { "1" },
             attribute name { "LinearMomentum" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Calculate the control volume auxiliary gradient for a particular field.
         ## The related field must be a scalar field in this material_phase.
         element vector_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeAuxiliaryGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  attribute gradient_of_field { string },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
         ## The related field must be a scalar field in this material_phase.
         element vector_field {
            attribute rank { "0" },
            attribute name { "DGAuxiliaryGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  attribute gradient_of_field { string },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Coordinate field remapped to the mesh of your choice.
         element vector_field {
             attribute rank { "1" },
             attribute name { "DiagnosticCoordinate" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|

         ## Coordinate field remapped to the mesh of your choice.
         element vector_field {
             attribute rank { "1" },
             attribute name { "DiagnosticCoordinate2" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|

         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,                  
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element vector_field {
             attribute rank { "1" },
             attribute name { "delta_U" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         element vector_field {
             attribute rank { "1" },
             attribute name { "solid_U" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
             element vector_field {
             attribute rank { "1" },
             attribute name { "Darcy_Velocity" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         element vector_field {
             attribute rank { "1" },
             attribute name { "f_x" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
        element vector_field {
            attribute rank { "1" },
            attribute name { "U" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
        }

# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )  

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },
            ##
            ##TO BE DELETED
            ##		
 	    ##THIS OPTION IS USED TO SET TENSOR DIMENSIONS		
            element nphase { integer }?,		
            ## Field type		
            (		
               element prescribed {		
                  mesh_choice,		
                  prescribed_tensor_field		
               }|		
               element aliased {		
                  generic_aliased_field		
               }|		
               element diagnostic {		
                  tensor_diagnostic_algorithms,		
                  velocity_mesh_choice,		
                  diagnostic_tensor_field		
               }		
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
        element tensor_field {
            attribute name { "Dummy" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
        }|
        element tensor_field {
            attribute name { "a_xx" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_tensor_field
               }|
               element aliased {
                  generic_aliased_field
        }
            )
        }|
        ## This is the gradient of the velocity field - calculated in the dynamic core.
        element tensor_field {
            attribute name { "grad_U" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_tensor_field
               }|
               element aliased {
                  generic_aliased_field
        }
            )
        }|
        element tensor_field {
            attribute name { "Viscosity" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
        }     

# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

cap_option =
   (
      ## Cap the min and max values of this field when using
      ## it as a volume fraction to work out bulk material
      ## properties.
      ## No capping used if not selected.
      element cap_values {
         ## Set the upper bound on the field.
         ## Defaults to huge(0.0)*epsilon(0.0) if not set.
         element upper_cap {
            real
         }?,
         ## Set the lower bound on the field.
         ## Defaults to -huge(0.0)*epsilon(0.0) if not set.
         element lower_cap {
            real
         }?
      }
   )

limiter_options =
  (
      (
        ## Limit the face value to satisfy a boundedness criterion.
        element limit_face_value{
          (
            sweby_limiter|
            ultimate_limiter|
	    extrema_limiter|
            compressive_advection_limiter|
            ENO_advection
          )
        }|
        ## Do not limit the face value
        element do_not_limit_face_value{
          empty
        }
      )
  )

sweby_limiter = 
  ## See "High-Resolution Schemes Using Flux Limiters for
  ## Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
  ## Journal on Numerical Analysis, 21, 995-1011
  element limiter {
    attribute name {"Sweby"},
    slope_options?,
    upwind_value_options?
  }

ultimate_limiter =
  ## See "The Ultimate Conservative Difference Scheme Applied
  ## to Unsteady One-Dimensional Advection", B. P. Leonard,
  ## 1991, Computer Methods in Applied Mechanics and
  ## Engineering, 88, 17-74
  element limiter {
    attribute name {"Ultimate"},
    field_based_cfl_number_options,
    upwind_value_options?
  }

extrema_limiter = 
  element limiter {
    attribute name {"Extrema"}
  }

compressive_advection_limiter = 
  element limiter {
    attribute name {"CompressiveAdvection"}
  }

ENO_advection = 
  element limiter {
    attribute name {"ENO"}
  }


slope_options =
   (
      ## Control the upper and lower slopes of the NVD limiter
      element slopes {
         ## Defaults to Sweby, 1984 limiter (= 1.0) if unselected
         element lower {
            real
         }?,
         ## Defaults to Sweby, 1984 limiter (= 2.0) if unselected
         element upper {
            real
         }?
      }
   )

upwind_value_options =
   (
      (
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## This method projects the upwind value from a point in the element just
         ## upwind of the node pair straddling the face.  It is otherwise known as 
         ## anisotropic limiting.
         ## This is only available on simplex meshes as it involes a search around
         ## the donor node to find the upwind element.
         element project_upwind_value_from_point {
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which it was found from.
            element bound_projected_value_locally {
               empty
            }?,
            ## Store the locations of the elements where the upwind values
            ## are projected from for each node pair.
            ## This inserts an integer csr matrix into state so is memory expensive but
            ## saves a significant amount of time (searching around the neighbouring elements).
            ## This is unsafe for moving meshes but should be ok for adaptive meshes.
            element store_upwind_elements {
               ## Store the quadrature locations within the elements
               ## where the upwind values
               ## are projected from for each node pair.
               ## This inserts a real block csr matrix into state so is even more memory
               ## expensive than just storing the upwind elements and
               ## only saves a comparitively
               ## marginal amount of time (as actually searching the
               ## neighbouring elements is the
               ## slowest bit, finding the quadrature is relatively easy).
               element store_upwind_quadrature {
                  empty
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Projects the value of the advected variable from the downwind or donor node
         ## using the interpolated gradient at the donor node in the
         ## direction of the vector
         ## connecting the node pair straddling the face.
         ## This is available on all meshes (except if bounding the values).
         element project_upwind_value_from_gradient {
            (
               ## Select which node to project from:
               ## Project from the downwind node (Jasak et al., 1999) so that:
               ## upwind_value = downwind_value - 2*gradient.vector
               element project_from_downwind_value {
                  comment
               }|
               ## Select which node to project from:
               ## Project from the donor node so that:
               ## upwind_value = donor_value - gradient.vector
               element project_from_donor_value {
                  comment
               }
            ),
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which surround it.
            ## This is only available on simplex meshes as it involes a search around
            ## the donor node to find the upwind element.
            element bound_projected_value_locally {
               ## Store the locations of the elements closest to the project value.
               ## This inserts an integer csr matrix into state so is
               ## memory expensive but
               ## saves a significant amount of time (searching around
               ## the neighbouring elements).
               ## This is unsafe for moving meshes but should be ok for adaptive meshes.
               element store_upwind_elements {
                  comment
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the maximum or minimum of the neighbouring
         ## nodes depending on the local slope of the donor and downwind values.
         ## Otherwise known as isotropic limiting.
         ## This is available on all meshes except periodic domains.
         element locally_bound_upwind_value {
            empty
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the value at the node most directy
         ## upwind from the vector connecting the donor and downwind nodes.
         ## This is available on all meshes.
         element pseudo_structured_upwind_value {
            empty
         }
      )
   )

field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain  
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins 
         ## e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins 
         ## and the fraction of the field in each bin with,
         ## -1.5<=field<0.0, 0.0<=field<1.5, 1.5<=field<2.0, 2.0<=field, 
         ## will be calculated.  
         element mixing_bin_bounds { 
            (
                 ## list of bin bounds
                 element constant { 
                     real_vector
                 }|
                 ## Python function prescribing bin bounds. Functions should be of the form:
                 ##
                 ##  def val(t):
                 ##     # Function code
                 ##     return # Return value that should be an array of reals
                 ##
                 ## 
                 element python {
                     python_code
                   }
              )
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file   
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )

recalculation_options =
   (
      ## Prevent this field from being recalculated at every timestep.
      ## This is cheaper especially if you are enforcing discrete properties on the field.
      element do_not_recalculate {
        empty
      }
   )

discrete_properties_algorithm_scalar =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        ## Update this field using the lagrangian multiplier
        ## calculated in the solenoidal projection of a
        ## scalar field.
        ##
        ## Note this field must be specified as the update field
        ## underneath that vector field too.
        ##
        ## Note also this only really makes sense for coupled
        ## fields like velocity and pressure.
        element solenoidal_lagrange_update {
          empty
        }?
      }
   )

discrete_properties_algorithm_vector =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        solenoidal_options?
      }
   )

solenoidal_options =
    ## Constrained divergence-free projection.
    ## This adds an additional constraint that ensures that the field
    ## is solenoidal, i.e. divergence-free.
    ## This is equivalent in cost to a pressure solve.
    ## This is expensive, and thus best left until
    ## needed.
    ##
    ## Note well: this only makes sense for nondivergent
    ## vector fields, such as incompressible velocity!
    element solenoidal {
      ## Options for the mass matrix of the field being interpolated
      element interpolated_field {
        (
          element continuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            ##
            ## Required when using interpolating continuous fields
            element lump_mass_matrix {
              ## Lump on the submesh.
              ## This only works for simplex meshes and is only
              ## strictly valid on 2d meshes.
              element use_submesh {
                empty
              }?
            }
          }|
          element discontinuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            element lump_mass_matrix {
              empty
            }?
          }
        )
      },
      ## Options for the lagrange multiplier
      ##
      ## Must be on a continuous mesh!
      element lagrange_multiplier {
        pressure_mesh_choice,
        element spatial_discretisation {
          (
            element continuous_galerkin {
              ## Remove the stabilisation term from the projection operator.
              ##
              ## Automatic when not using P1P1.
              element remove_stabilisation_term {
                empty
              }?,
              ## Integrate the divergence operator by parts.
              ##
              ## Automatic when projecting a discontinuous field
              element integrate_divergence_by_parts {
                empty
              }?
            }|
            element control_volumes {
              empty
            }
          )
        },
        element reference_node {
          integer
        }?,
        ## **UNDER DEVELOPMENT**
        ## This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
        ## It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
        ## At a debug level of 2 it also prints out the value and the sum of the row values.
        ## This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.
        element repair_stiff_nodes {
           empty
        }?,
        (
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { "Pressure" },
            empty
          }|
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { string },
            empty
          }
        )?,
        ## Solver options for the linear solve.
        ## This method requires the inversion of a projection matrix.
        element solver {
          linear_solver_options_sym
        }
      }
    }

represcribe_before_interpolation =
    ## Represcribe the field before interpolation.
    ##
    ## This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!
    element represcribe_before_interpolation {
      empty
    } 

equation_of_state =
               (
                  (
## Use this option to specify the density of fluids
element equation_of_state{

                     ## Equations of state
                     element incompressible {
                        (
                           ## Incompressible linear equation of state
                           ## 
                           ## (DEN = EOS_COEFS( 1 ) + EOS_COEFS( 2 ) * P + EOS_COEFS( 3 ) * T + EOS_COEFS( 4 ) * P * T
                           ## + EOS_COEFS( 5 ) * ( P **2 )     + EOS_COEFS( 6 ) * ( T **2 ) + EOS_COEFS( 7 ) * ( P **2 ) * T 
                           ## + EOS_COEFS( 8 ) * P * ( T **2 ) + EOS_COEFS( 9 ) * (( P * T ) **2 )
                           element linear {
                              (
                                 ## All eos_coefficients equal as in most of
                                 ## the test cases (=1)
                                 element all_equal {
                                    real
                                 }|
                                 ## Specify the coefficients separately
                                 ## There should probably be at least 9
                                 ## see multi_eos.F90 lines 132-140
                                 element specify_all {
                                       element number_of_ccefficients{ real },
                                       element coefficients{ real_vector }
                                 }
                              ),
                              ## The reference or background density
                              element reference_density {
                                 real
                              }?,
                              ## Enable to add temperature dependency
                              ## to the equation of state.
                              element temperature_dependency {
                                 ## The reference or background
                                 ## temperature (actual temperature =
                                 ## calculated temperature plus this
                                 ## value).
                                 element reference_temperature {
                                    real
                                 },
                                 ## The thermal expansion coefficient
                                 element thermal_expansion_coefficient {
                                    real
                                 }
                              }?,
                              ## Enable to add salinity dependency to
                              ## the equation of state.
                              element salinity_dependency {
                                 ## The reference or background
                                 ## salinity (actual salinity =
                                 ## calculated salinity plus this
                                 ## value).
                                 element reference_salinity {
                                    real
                                 },
                                 ## The haline contraction coefficient
                                 element saline_contraction_coefficient {
                                    real
                                 }
                              }?,
                              ## Enable this option to subtract out
                              ## the hydrostatic level
                              element subtract_out_hydrostatic_level {
                                 empty
                              }?
                           }
                        )
                     }|
                     ## Equations of state for compressible applications
                     element compressible {
                        ## Stiffened Gas EoS
                        ##
                        ## DEN = ( P + EOS_COEFS( 1 )) * EOS_COEFS( 2 ) / T
                        ##
                        ## Note that setting EOS_COEFS( 1 ) = 0. and EOS_COEFS( 2 ) = 1/gas constant (Rd [J/kg/K])
                        ## The equation for ideal gases is obtained.
                        element stiffened_gas {
                           element eos_option1 { real },
                           element eos_option2 { real },
                           ## reference uncompressed density
                           ##
                           ## if activated then either Liquid EoS or
                           ## full Stiffened Gas EoS
                           element reference_density {
                              real
                           }?,
                           ## Ratio of specific heats at constant
                           ## pressure to that at constant volume
                           ##
                           ## Requires an energy field.
                           ## If activated then a full Stiffened Gas EoS 
                           element ratio_specific_heats {
                              real
                           }?,
                           ## bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density
                           ##
                           ## if activated then either full or partial Liquid EoS or full
                           ## Stiffened Gas EoS
                           element bulk_sound_speed_squared {
                              real
                           }?
                        }|

                  
                        ## Jones-Wilkins-Lee equation of state for explosives (JWL-equation)
                        ##
                        ## Used with compressible simulations
                        ## 
                        ## P=A*(1-w/(R1*V))*exp(-R1*V)+B*(1-w/(R2*V))*exp(-R2/V)+w*E0/V;
                        ##
                        ## The ratio V =roe/ro is defined by using roe = density of the explosive (solid part) and ro = density of the detonation products.

                        element JWL_equation {
                           element density_of_explosive_roe { real },
                           element A { real },
                           element B { real },
                           element R1 { real },
                           element R2 { real },
                           element E0 { real },
                           element w { real }
                        }|


                        ## Exponential EOS (SPE 102542)
                        ##
                        ## DEN = DEN_REF * EXP( COMPRES_FACTOR * ( P_oil * P_oil_ref ))
                        ##
                        element exponential_oil_gas {
                           element compressibility { 
                              real 
                           }?,
                           element reference_density {
                              real
                           }?
                        }|
                        ## Linear in Pressure EOS 
                        ##
                        ## DEN = A * P + B
                        ##
                        ## Use this option for flooding, being A = 1/gravity and B the bathymetry
                        element linear_in_pressure {
                           element coefficient_A { 
                              real 
                           },
                           element coefficient_B {
                            (
                                 ## list of bin bounds
                                 element constant { 
                                     real
                                 }|
                                ## Python function prescribing real input. Functions should be of the form:
                                ##    def val(X, t):
                                ##    # Function code
                                ##    return # Return value
                                ##
                                ##    where X is a tuple of length geometry dimension.
                                 element python {
                                     python_code
                                   }
                              )
                           },
                           ## If chosen: DEN = A * P / T + B
                           element include_internal_energy {
                              empty
                           }?
                        }|
                        ## Exponential in Pressure EOS 
                        ##
                        ## DEN = A * P ^ B
                        ##
                        element exponential_in_pressure {
                           element coefficient_A { 
                              real 
                           },
                           element coefficient_B {
                              real
                           }
                        }|
                        ## Temperature-Pressure correlation for liquids ONLY.
                        ##
                        ## Range of applicability: 0 to 2*10^9 Pa.
                        ##
                        ## rho1 = rho0/(1+Beta(T1-T0))/(1-(P1-P0)/E)
                        ##
                        ## where rho0 is the reference density at temperature T0 and pressure P0;
                        ##
                        ## Beta is volumetric expansion coefficient (m^3/m^3 Celsius);
                        ##                        
                        ## E is the liquid elasticity bulk modulus (N/m^2)
                        ##
                        ## NOTE: if temperature is not defined the temperature is defined as zero.
                        element Temperature_Pressure_correlation {
                           ## Reference density
                           element rho0 { 
                              real 
                           },
                           ## Reference temperature
                           element T0 { 
                              real 
                           },
                           ## Reference Pressure
                           element P0 { 
                              real 
                           },
                           ## volumetric expansion coefficient (m^3/m^3 Celsius)
                           element coefficient_Beta { 
                              real 
                           },
                           ## liquid elasticity bulk modulus (N/m^2)
                           element coefficient_E {
                              real
                           }
                        }
                     }|
                     ## The "Dummy" diagnotic field on the pressure mesh is required for this option
                     element python_state{
                       scalar_python_diagnostic_algorithm
                     }
}
                  )
               )

rheology =
   (
      (
         ## Specify rheologival model for this materal
         element rheology{
	    (
	       ## Newtonian material with single coefficient of viscosity
               element newtonian {
		  element tensor_field {
		     attribute name { "Viscosity" },
		      element prescribed {
		        velocity_mesh_choice,
			prescribed_values_tensor_field,
		        prescribed_output_options
                     }
                  }
	       }  |
	       	  ## Models including power law and Herschel-Bulkley	
               element non_newtonian {
    	          attribute name { "ShearDependent"},
		  element yield_stress { real }?,
		  element exponent { real },
		  element consistency_index { real },
		  element tolerance { real }?,
		  element lower_bound { real }?,
		  element upper_bound { real }?,
		  element tensor_field {
		     attribute name { "Viscosity" },
		     element diagnostic {
		        velocity_mesh_choice,
		        prescribed_output_options
                     }
                  }
	       } |
               element non_newtonian {	
    	          attribute name { "Carreau"},
		  element viscosity_at_zero_shear { real },
		  element viscosity_at_infinite_shear { real }?,
		  element relaxation_time { real },	
		  element exponent { real },
		  element tensor_field {
		     attribute name { "Viscosity" },
		     element diagnostic {
		        velocity_mesh_choice,
		        prescribed_output_options
                     }
                  }

               } 
             )
         }
)
)

		  

	         
	 
