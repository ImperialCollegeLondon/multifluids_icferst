include "spud_base.rnc"

include "adaptivity_options.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "solvers.rnc"
include "stabilisation.rnc"
include "mesh_options.rnc"
include "physical_parameters.rnc"
include "prognostic_field_options.rnc"
include "prescribed_field_options.rnc"
include "spatial_discretisation.rnc"
include "temporal_discretisation.rnc"

start =
   (
      ## IC-FERST is a next generation simulator based on Double-Control-Volume
      ## Finite Element methods and dynamic unstructured mesh optimisation.
      ##
      ## IC-FERST is licensed under the LGPL. For more information
      ## please visit: http://multifluids.github.io/
      element icferst_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
             (
                ## Navier-stokes simulator
                element inertia_dominated_simulator{comment}|
                ## Darcy flow simulator
                element porous_media_simulator{comment}|
                ## Magma flow simulator
                element magma_simulator{comment}|
                ## Poro-elasticity simulator:
                ## This requires to define through diamond the tensor field in phase 1 UAbsorB
                ## as an absorption term and also the RHS that should include the second time-derivative for the solid phase
                ## and also the coupling terms. The first phase is considered the solid phase.
                element poroelasticity{comment}|
                ## Flooding simulator
                element flooding_simulator{comment}
             ),
         geometry,
	     solver_options,
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            },
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                (
                     element constant {
                     real
                   }|
                   ## Python function prescribing real input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ##
                   element python {
                     python_code
                   }
                )
               }|
               ## Dump period, in timesteps.
               ##
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                 (
                     element constant {
                     integer
                   }|
                   ## Python function prescribing integer input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ##
                   element python {
                     python_code
                   }
                )
               }
            ),
            ## Path (without the extension) to the .csv file containing the fluid and porous media properties.
            ## NOTE: Properties in the .csv file will overwrite the input from diamond.
            ##
            ## The information is stored as:
            ##
            ## Property, phase, region_ids(0= if all), value (values separated by _ for region ids and tensors)
            ##
            ## You can find an example in the Proous_media_general test case
            ##
            ## If using this, all the modifiable fields need to have the option to read from a csv file
          element PropertiesFromFile {xsd:string
          }?,

            ## Prints the number of iterations and
            ## the final convergence achieved by the FPI solver
            element Show_Convergence{comment}?,
            ## If porous_media, printout the Courant number every time-step
            element Courant_number {
               comment
            }?,
            ## Surface to Integrate Over
            element dump_boundaryflux {
            empty,
            ## Surface id:
            element surface_ids {
            integer_vector
            }}?,
	    ## Whether to enable dumping of checkpointing output.
            ##
            ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options
            element checkpointing {
               ## Checkpointing period, in dumps. Non-negative value
               ## required. A value of zero indicates that checkpoints
               ## should be created at every dump. If
               ## /io/max_dumpfile_count is exceeded then earlier
               ## checkpoints may be overwritten.
               element checkpoint_period_in_dumps {
                  integer
               },
               ## Enable to checkpoint at simulation start.
               element checkpoint_at_start {
                  comment
               }?,
               ## Enable to force a checkpoint at simulation end.
               element checkpoint_at_end {
                  comment
               }?,
               comment
            }?,

            ## Specification of detectors. Note that when running in parallel the detector output is in binary format even if binary_output is not enabled. When running in serial, although the output is in principle still generated in ascii format if binary_output is not enabled, it is not certain that it is working well. Hence, it is recommended to enable binary_output and work with binary files.
            element detectors {
               (
                  ## A single static detector
                  element static_detector {
                     attribute name { xsd:string },
                     (
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## A single lagrangian detector
                  element lagrangian_detector {
                     attribute name { xsd:string },
                     (
                     ## This is the initial location of a detector that moves with the fluid velocity.
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.
                  element detector_array {
                     attribute name { xsd:string },
                     ## The number of detectors prescribed by the python function.
                     element number_of_detectors {
                        integer
                     },
                     (
                        ## Create fixed detectors.
                        element static {
                           empty
                        }|
                        ## Create detectors which move with the fluid velocity.
                        element lagrangian {
                           empty
                        }
                     ),
                     (
                        ## Python function prescribing dimensional vector input. Functions should be of the form:
                        ##
                        ##  def val(t):
                        ##     # Function code
                        ##     return # Return value
                        ##
                        ## The return value must have length number_of_detectors.
                        ##
                        ## *** IMPORTANT NOTE ***
                        ##
                        ## The t argument is for future use only - currently detector locations are only set at simulation start.
                        element python {
                          python_code
                        }|
                        ## File containing the detectors positions in binary form
                        element from_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                              element string_value {
                                 "binary"
                              }
                           }
                        }
                     )
                  }
               )*,
               ## Enable to write detector output in binary format
               element binary_output {
                  comment
               }?,
               element lagrangian_timestepping {
                  (
                     ## Use explicit runge kutta method with
                     ## binary search
                     element explicit_runge_kutta_guided_search {
                        ## Number of subdivisions of the timestep
                        ## increase this if you are not happy with your
                        ## detector trajectory accuracy, or if particles
                        ## are jumping out of the domain a lot
                        element subcycles {
                           integer
                        },
                        ## Tolerance for deciding if detector is in a given
                        ## element. Recommended value 1.0e-10.
                        element search_tolerance {
                           real
                        },
                        ## Number of RK stages
                        ## For the RK4 method, it should be 4.
                        element n_stages {
                           integer
                        },
                        ## ERK stage array. This is an array
                        ## containing the lower-triangular
                        ## part of the Butcher weight matrix
                        ## A that explains how to compute the
                        ## RK stages.  See
                        ## http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
                        ## for notation.  The array is stored
                        ## in the following order:
                        ## [a_{21},a_{31},a_{32},...,a_{s1},a_{s2},a_{s(s-1)}]
                        ## and so the array has size s(s-1)/2
                        ## where s is the number of stages.
                        ## For the RK4 method, it should be
                        ## [0.5,0,0.5,0,0,1]
                        element stage_weights {
                           real_vector
                        },
                        ## ERK timestep weights. This is the
                        ## b vector that explains how to
                        ## compute the timestep from the RK
                        ## stages.  See
                        ## http://en.wikipedia.org/wiki/Runge–Kutta_methods#Explicit_Runge.E2.80.93Kutta_methods
                        ## for notation.  It should have size
                        ## s where s is the number of stages.
                        ## For the RK4 method, it should be
                        ## [1/6,1/3,1/3,1/6]
                        element timestep_weights {
                           real_vector
                        }
                     }|
                     ## Use binary search algorithm
                     element binary_search {
                        empty
                     }
                  )
               }?
            }?,
            ## Options to create even more output in the logs:
            ##
            ## Note that the main option to control the log output is given on the command line:
            ##
            ## -v0  only output error and warnings
            ##
            ## -v1  also give "navigational information", to indicate where in the code we currently are
            ##
            ## -v2  also give any additional information (mins and maxes of fields, etc.)
            ##
            element log_output {
               ## Log all allocates and deallocates done for meshes, fields, sparsities and matrices.
               ##
               ## NOTE: Requires -v2
               element memory_diagnostics {
                  empty
               }?
            }?,
            ## Printout the number of elements and percentage that contain an angle
            ## equal or bigger than the ones specified here
	    ## Note: This may slow down your simulation should be used as a diagnostic tool
            element Mesh_Diagnostics_Angles {
               real_vector
            }?
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Vary the timestep according to the courant number.
            element adaptive_timestep {
               ## The timestep will be adjusted (within the tolerance
               ## and bounds specified) to target this courant
               ## number. Timestep adapts occur at the end of each
               ## timestep and after a mesh adapt.
               element requested_cfl {
                  real
               },    
               ## Multiplier of the requested CFL based on which the pressure and velocity fields
               ## will be recalculated. Otherwise, the pressure will not be updated.
               element requested_cfl_pressure {
                  integer
               }?,
               timestep_cfl_number_options,
               ## Minimum time step size.
               ## Manual suggests 0.0
               element minimum_timestep {
                  ## If enabled, signals model dump if a timestep less
                  ## than or equal to the minimum_timestep is requested.
                  element dump_vtu_if_reached {
                      ## If enabled, signals model termination if a timestep less
                      ## than or equal to the minimum_timestep is requested. The
                      ## model will stop at the end of the timestep in order to
                      ## allow for the latest output to be written.
                      element terminate {
                         comment
                      }?,
                     comment
                  }?,
                  real
               }?,
               ## Maximum time step size.
               ## Manual suggests 1.E+10
               element maximum_timestep {
                  real
               }?,
               ## The maximum ratio by which the timestep is allowed
               ## to increase in a timestep adapt. e.g., a value of
               ## 1.1 indicates that the timestep may be increased by
               ## at most 10%.
               element increase_tolerance {
                  real
               }?,
               ## Specify whether you want to calculate a new timestep
               ## at the first timestep or not.
               element at_first_timestep {
                  empty
               }?
            }?
         },

         physical_parameter_options?,
         ## The material or phase options
         element material_phase {
            attribute name { xsd:string },
            ## Specify whether this phase is actually a component
            element is_multiphase_component {
               (
                  ## Specify the weighting for the component equation
                  ## between 0 and 1. Test cases have 1.
                  element alpha_beta { real },
                  ## Enable this option to use sigmoid method for finding equilibrium
                  element KComp_Sigmoid {
                     (
                        ## KComp value for this component
                        element K_Comp { real }
                     )
                  }?,
                  ## Enable this option to force component mass fractions
                  ## to sum to 1 by adding constraint into compositional source term.
                  element Comp_Sum2One {
                     (
                        ## Relaxation coefficient to summation constraint [0,1].
                        ## --> 0: under-relaxation ; --> 1: over-relaxation
                        element Relaxation_Coefficient { real },
                        ## Ensure that this constraint acts only as a positive absorption term
                        element Ensure_Positive { empty }?,
                        ## Explicitly enforce components to sum to one
                        element Enforce_Comp_Sum2One { empty }?
                     )
                  }?,
                  ## Surface tension
                  element surface_tension {
                     (
                        ## Surface tension coefficient.
                        element coefficient { real },
                        ## Contact angle.
                        element angle { real } ?,
                        ##  Smoothing.
                       element smooth { empty } ?
                     )
                  }?,
                    ## Linearises a P2 field. Use this if having stability issues with high-order discretisations
                    element linearise_component {empty}?
               )
            }?,
              ## Options to provide properties of the fluid for the given phase.
              phase_properties_options,

            ## Pressure
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Pressure" },
               ## Field type
               (
                  element prognostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prognostic_pressure_field
                  }|
                  element prescribed {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     prescribed_scalar_field
                  }|
                  ## Compute pressure from Density and InternalEnergy
                  ## via a compressible equation of state.
                  element diagnostic {
                     # mesh choice with PressureMesh as first option
                     pressure_mesh_choice,
                     internal_algorithm,
                     diagnostic_scalar_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Pressure" }
                  }
               )
            }?,
            ## Velocity vector and momentum options
            element vector_field {
               attribute rank { "1" },
               attribute name { "Velocity" },
               ## Field type
               (
                  element prognostic {
                     velocity_mesh_choice,
                     prognostic_velocity_field
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_vector_field
                  }|
                  element diagnostic {
                     velocity_mesh_choice,
                     vector_python_diagnostic_algorithm,
                     diagnostic_vector_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Velocity" }
                  }
               )
            },
            scalar_field_choice*,
            vector_field_choice*,
            tensor_field_choice*,
            ## Parameters required to model multiphase flow
            element multiphase_properties {
               ## Option for relperm type in prototype code
                  ## Corey relperm:
                  ##
                  ## relperm = relperm_max * ((Sat-S_immobile)/(1-Sum(Immobile_saturations)))^relperm_exponent
               element Relperm_Corey {
                     ## Relative permeability end point
                     ##
                     ## Value between 0 and 1. Default value 1.0
                    element scalar_field {
                       attribute name { "relperm_max" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }
                       )
                    },
                     ## Relative permeability exponent
                     ##
                     ## Default value 2.0
                     element scalar_field {
                        attribute name { "relperm_exponent" },
                        (
                           element prescribed {
                              material_mesh_choice,
                              prescribed_scalar_field
                  }
                        )
                     }
                }?,
               ## Option for capillary pressure
               element capillary_pressure {
                  ## Brooks-Corey equation
                  ##
                  ## Pc = c * ((S_w-Swir)/(1-Swirr-Sor)) ** -a; here c is the entry pressure
                  ##
                  ## For imbibition swith the formula is:
                  ##
                  ## ## Pc = c * ( ((S_w-Swir)/(1-Swirr-Sor)) ** -a ) - B; here c - B is the entry pressure
                  ##
                  ## You should specify this ONLY for the wetting phase
                  element type_Brooks_Corey {
                    ## Entry pressure of the formula
                    element scalar_field {
                       attribute name { "C" },
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }
                    },
                    ## Imbibition term. if on, entry pressure = C - B;
                    ## By default this value is set to zero.
                    element scalar_field {
                       attribute name { "B" },
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }
                    }?,
                    ## exponent -a
                    element scalar_field {
                       attribute name { "a" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }}?,
	          ## Power Law equation
                  ##
                  ## Pc = c*(1-s_eff)**a
		  ##
		  ## where s_eff = (S_w-Swir)/(1-Swir-Sor)
		  ##
		  ## c = maximum pc pressure; a = pc exponent
		  ##
		  ## (no entry pressure)
                  ##
                  ## ONLY specify for the wetting phase
		  element type_Power_Law {
                    ## Maximum pressure
                    element scalar_field {
                       attribute name { "C" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    },
                    ## exponent a
                    element scalar_field {
                       attribute name { "a" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }}?
               }?,
               ## Immobile volume of fluid phase
               element immobile_fraction {
               ## Immobile fraction
                    element scalar_field {
                       attribute name { "value" },
                       (
                          element prescribed {
                             material_mesh_choice,
                             prescribed_scalar_field
                          }
                       )
                    }
               }?
            }?
         }+,
         mesh_adaptivity_options?,
         ## Porous Media
         element porous_media {
            ## Specify scalar field Porosity
            element scalar_field {
               attribute name { "Porosity" },
               (
                  element prescribed {
                     material_mesh_choice,
                     prescribed_scalar_field
                  }|
                  element aliased {
                     generic_aliased_field
                  }
               )
            },
            ## Specify field Permeability
            (
               element scalar_field {
                  attribute name { "Permeability" },
                  (
                     element prescribed {
                        material_mesh_choice,
                        prescribed_scalar_field
                     }|
                    element diagnostic {
                    material_mesh_choice,
                    scalar_python_diagnostic_algorithm,
                    diagnostic_scalar_field
                  }
                  )
               }|
               element vector_field {
                  attribute name { "Permeability" },
                  (
                  element prescribed {
                     material_mesh_choice,
                     prescribed_vector_field
                  }|
                    element diagnostic {
                    material_mesh_choice,
                    vector_python_diagnostic_algorithm,
                    diagnostic_vector_field
                  }
                  )
               }|
               element tensor_field {
                  attribute name { "Permeability" },
                  (
                  element prescribed {
                     material_mesh_choice,
                     prescribed_tensor_field
                  }|
                    element diagnostic {
                    material_mesh_choice,
                    tensor_python_diagnostic_algorithm,
                    diagnostic_tensor_field
                  }
                  )
               }
            ),
            ## Specify scalar field Longitudinal Dispersivity
            element Dispersion {
               element scalar_field {
                  attribute name { "Longitudinal_Dispersivity" },
                  (
                     element prescribed {
                        material_mesh_choice,
                        prescribed_scalar_field
                     }|
                     element aliased {
                        generic_aliased_field
                     }
                  )
               },
              element scalar_field {
                  attribute name { "Transverse_Dispersivity" },
                  (
                     element prescribed {
                        material_mesh_choice,
                        prescribed_scalar_field
                     }|
                     element aliased {
                        generic_aliased_field
                     }
                  )
               }?
            }?,
            ## Parameters for thermal porous media simulations
            element thermal_porous{
                ## Specify scalar field density of the porous media
                element scalar_field {
                   attribute name { "porous_density" },
                   (
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify scalar field heat capacity of the porous media
                element scalar_field {
                   attribute name { "porous_heat_capacity" },
                   (
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify field Thermal conductivity of the porous media
               element tensor_field {
                  attribute name { "porous_thermal_conductivity" },
                  element prescribed {
                     material_mesh_choice,
                     prescribed_tensor_field
                  }
               }
             }?,

             ## Options to specify the wells/pipes
             element wells_and_pipes {
                ## Option to define laterals from diamond
                ## if in doubt set it to 1.
                element scalar_field {
                   attribute name { "Pipe" },
                   (
                      element prescribed {
                         material_mesh_choice,
                         prescribed_scalar_field
                      }|
                    element diagnostic {
                      vector_python_diagnostic_algorithm,
                      diagnostic_scalar_field_no_adapt
                    }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify where and how much the well/pipes are opened
                ## It goes from 0 to 1. If completely opened, set it to 1.
                element scalar_field {
                   attribute name { "Gamma" },
                   (
                      element prescribed {
                         pressure_mesh_choice,
                         prescribed_scalar_field
                      }|
                    element diagnostic {
                      vector_python_diagnostic_algorithm,
                      diagnostic_scalar_field_no_adapt
                    }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Absorption in the pipes.
                ## If none, set it to 1.
                ##
                ## Recommended. set to 1 and/or use the internal method based on the Moody diagram that can be selected in
                ## /wells_and_pipes/well_options/calculate_sigma_pipe

                element scalar_field {
                   attribute name { "Sigma" },
                   (
                      element prescribed {
                         subcv_mesh_choice,
                         prescribed_scalar_field
                      }|
                    element diagnostic {
                      vector_python_diagnostic_algorithm,
                      diagnostic_scalar_field_no_adapt
                    }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify the diameter of the pipe.
                ## This effectively defines where and where not there is a pipe.
                ## If the diameter is <=0 no pipe, else there is pipe.
                element scalar_field {
                   attribute name { "DiameterPipe" },
                   (
                      element prescribed {
                         pressure_mesh_choice,
                         prescribed_scalar_field
                      }|
                    element diagnostic {
                      vector_python_diagnostic_algorithm,
                      diagnostic_scalar_field_no_adapt
                    }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
                },
                ## Specify thermal well-related options
                element thermal_well_properties {
                    ## Specify the conductivity of the well/pipe material.
                    ## If there are several layers this, it has to be the equivalent conductivity from inside the well/pipe to
                    ## the reservoir.
                    ## This is only required for heat transport
                    element scalar_field {
                       attribute name { "Conductivity" },
                       (
                          element prescribed {
                             pressure_mesh_choice,
                             prescribed_scalar_field
                          }|
                        element diagnostic {
                          vector_python_diagnostic_algorithm,
                          diagnostic_scalar_field_no_adapt
                        }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    },
                    ## Specify the thickness of the well/pipe.
                    ## If there are several layers this, it has to be the equivalent thiness from inside the well/pipe to
                    ## the reservoir.
                    ## This is only required for heat transport
                    element scalar_field {
                       attribute name { "well_thickness" },
                       (
                          element prescribed {
                             pressure_mesh_choice,
                             prescribed_scalar_field
                          }|
                        element diagnostic {
                          vector_python_diagnostic_algorithm,
                          diagnostic_scalar_field_no_adapt
                        }|
                          element aliased {
                             generic_aliased_field
                          }
                       )
                    }
                }?,
                ## Specify well-related options
                element well_options {
                   ## Calculate the well \sigma field internally
                   ## using a non-linear friction factor.
                   ## This will over-write the field specified in Sigma1.
                   element calculate_sigma_pipe{
                      # Defaults to 1.0e-6.
                      element pipe_roughness{ real }?
                   }?,
                   ## (ONLY FOR CONSERVATIVE FORMULATIONS) This term is used to control a combination of implicit/explicit implementation in this way:
                   ## (1 + dumping_well_factor) Implicit - dumping_well_factor (Explicit)
                   ##
                   ## Values above 0 imply that explicit is used to dump the effect of the implicit term (which may be unstable);
                   ##
                   ## A Value of 0 => Fully implicit; A Value of -1 implies only Explicit
                   ##
                   ## Recommended values are 0.0 (Fully implicit), 0.25 or 0.5 (Some dumping but primarily implicit)
                   ## By default this is 0.5                   
                   element dumping_well_factor{ real }?,
                   ## Factor by which to reduce the pipe eqns time step size e.g. 10^{-3}
                   element dt_pipe_factor{ real }?,
                   ## Switches wells on and off to optimise production
                   element switch_wells_on_and_off{
                      element phase_exclude{ integer }
                   }?,
                    ## If when using mesh adaptivity the well path is disappearing, this tolerance can probably solve the problem.
                    ## .bdf files have only 6 digits precision, therefore for coordinates bigger than 1000 this values might need to be reduced and
                    ## the other way round for values below 100.
                    ## The default value is 1e-2.
                    element wells_bdf_tolerance {
                      real
                     }?
                }?,

                ## When using mesh adaptivity, introduce here the ids of the prisms of the wells to ensure
                ## that the well trajectories are preserved.
                ##
                ## ***This is MANDATORY when using files to define wells***
                element well_volume_ids {
                  integer_vector,
                      (
                        ## Output the ids of the wells
                        element Show_well_volumes_ids{comment}?
                      )
                 }?,
                 ## Introduce here the relative path to the file defining a 1D well
                 ## Note that the only accepted file format is NASTRAN, i.e. .bdf.
                 ## Each file has to describe a continuous well touching an external boundary.
                 ##
                 ## ***Well_volume_ids option is MANDATORY when using this method to define wells.***
                 element well_from_file {
                 attribute name { string },
                 attribute file_path { string }
                }*
             }?,
	        ## Multiphase Initialisation: Free water level is the height (m) where Pc=0, water saturation below this will be at residual oil.
	        ##
	        ## This is used to initialise the porous media model, defining the initial saturation and pressure. Currently for two-phase models.
	        ##
	        ## The following must be specified:
	        ##
	        ## - Densities of water (phase 1) and oil (phase 2)
	        ##
	        ## - Gravity
	        ##
	        ## - Capillary pressure curve
	         element FWL {
	         	real
		        }?
         }?,

        ## Fracking options
         element femdem_fracture {
         (
            ## Specify FEMDEM input file
            element femdem_file {
               attribute name { xsd:string }
            }?,
	    element oneway_coupling_only {
	       attribute rank {"0"},
               ("1way"|"p2way")
	    }?,
            element include_pore_pressure {
               empty
	    }?
         )
         }?,
         ## Flooding parameters
            element flooding{
             ## This is the term Nm of the manning formula:
             ## b = Nm^2*g * |u|/h^1.33;
             ## Nm is the manning coefficent. Values between [0.01 and 0.025];
             ## Nm = 0.011 for smooth asphal and Nm = 0.024 to rubble.
             ## For no friction set this to zero or do not activate it.
                 element scalar_field {
                    attribute name { "manning_coef" },
                    (
                       element prescribed {
                          material_mesh_choice,
                          prescribed_scalar_field
              }
                    )
                 },
               ##Perform the mean of the bathymetry when calculating the Manning formula;
               element averaging {
               comment
            }?,
               ##Factor that controls the strenght of the drag introduced in the dry areas;
               ## it has a simmilar effect as the artificial diffusion. Default value = 1e-1.
               element shallow_drag {
               real
            }?
         }?,

         ## Advanced options that are kept for debugging purposes
         element numerical_methods {
            ## Automatically after adapting the mesh and interpolating the fields a method to ensure boundeness of the field 
            ## is run to guarantee physically plausible solutions. Nonetheless this may spread errors occurred during the interpolation 
            ## that otherwise might have been cut off. Enable this option to avoid doing this operation.
            ##
            ## This option is useful if your field is suddenly changing after adapting the mesh.
            element do_not_bound_after_adapt {
               empty
            }?,
            ## Use a method to avoid distortion due to boundaries
            element use_reflect_method {
               empty
            }?,
            ## Upwinding is used for the parts of the domain where there is no shock-front nor rarefaction.
            ## Elsewhere a high-order advection scheme is used. This should increase the speed of the simulation.
            element local_upwinding {
               empty
            }?,
            ## Use the row-sum method to create a lumped mass matrix.
            ## For porous media this will not have an effect.
            ## Also options to convert P1DG into P0DG and introduce the temporal terms into the mass matrix
            element lump_mass_matrix {
                ## For the CV pressure formulation this controls the homogenisation of the velocity nodes of per element
                ## the bigger it is the more P0DG the element becomes. The default values have been obtained so the results are stable.
                ## The default value for P1DGP1 => 1e4 and disabled for other element types.
                ## To disable it manually, set it to negative values.
               element lump_weight{real}?,
            ## Introduce in the pivit matrix the temporal terms
            element get_all_in_mass_matrix {
               empty}?
            }?,
            element no_matrix_store {
              empty
            }?,
            element lump_momentum_inertia {
              empty
            }?,
           ## Impose a maximum number of iterations for the saturation non-linear solver within the non-linear solver
           ## By default this number is 9. Recommended range: 3 to 9.
            element max_sat_its {
               integer
            }?,
           ## Decide to solve for nphases-1. This should be faster. Still in development.
            element solve_nphases_minus_one {
               empty
            }?,
            ## For porous media only the Darcy velocity is outputed as the normal velocity is actually the force density
            ## activate this to also output the force_density
            element porous_output_force_density{
               empty
            }?,
            ## Use the fast method to create the pressure matrix. Be aware that some methods only work with the slow method
            element create_P_mat_fast {
               empty
            }?
         }?
      }
   )


geometry =
   (
      ## Options dealing with the specification of geometry
      element geometry {
         ## Dimension of the problem.
         ## <b>This can only be set once</b>
         element dimension {
            element integer_value {
               attribute rank {"0"},
               ("3"|"2"|"1")
            }
         },
         ## The position mesh
         element mesh {
            attribute name { "CoordinateMesh" },
            mesh_info
         },

           ## Selects the quality configuration of the experiment
           ## For Porous media the P1/P0 stands for P0, for inertia for P1.
           ##
           ## Fast => Element pair = P1/P0DGP1(CV). Upwinding and implicit Euler;
           ##
           ## Balanced (recommended) => Element pair = P1/P0DGP1(CV). High order advection scheme and adaptive theta;
           ##
           ## Precision => Element pair = P1DGP2(CV). High order advection scheme and adaptive theta
           ##
           ## Discontinuous_pressure => P1DG(BL)P1DG(CV). High order advection scheme and adaptive theta
            element simulation_quality {
              element string_value{
                 "fast" | "balanced" | "precision"|"discontinuous_pressure"
              }
            },

        ## Settings to change the values specified in simulation_quality.
        ## Only the activated options will overwrite the values decided in simulation_quality
        element Advance_options{
             ## The velocity mesh
             element mesh {
                attribute name { "VelocityMesh" },
                mesh_info
             }?,
             ## The pressure mesh
             element mesh {
                attribute name { "PressureMesh" },
                mesh_info
             }?,
             element mesh {
                attribute name { xsd:string },
                mesh_info,
                element exclude_from_mesh_adaptivity{empty}?
             }*,
             ## Specify a different time discretisation method for different fields
             ## You can use as inputs here: PhaseVolumeFraction, Velocity or Tracer.
             ## Tracer accounts for Temperature, SoluteMassFraction, etc.
             element Time_Discretisation {
                ##Name of the Field
                attribute name { xsd:string },
                 ## Implicit/explicit control (THETA)
                 ##  =0.  -- explicit
                 ##  =0.5 -- Crank-Nicolson
                 ##  =1.  -- implicit
                 ##  =-1. -- Automatic based on a NVD criterion.
                element Theta{real}
             }*,
             ## Specify a different flux calculation for different fields
             ## You can use as inputs here: PhaseVolumeFraction or Tracer.
             ## Tracer accounts for Temperature, SoluteMassFraction, etc.
             element Space_Discretisation {
                ##Name of the Field
                attribute name { xsd:string },
                element advection_scheme {
                  (
                     ## Straightforward upwinding of the nonlinear velocity.
                     element upwind {
                        empty
                     }|
                     ## High order method based on a TVD criteria to ensure stability.
                     element High_order {
                        limiter_options
                     }
                  )}

             }*,

             ## Conservative discretisation options
             ## Note that non-conservative does NOT mean that we do not conserve mass
             ## For transport equations this is recommended to be zero.
             ## For PhaseVolumeFraction the recommendation is one.
             ##
             ## You can use as inputs here: PhaseVolumeFraction, Velocity or Tracer.
             ## Tracer accounts for Temperature, SoluteMassFraction, etc.
             element Conservative_formulation_settings {
                ##Name of the Field
                attribute name { xsd:string },
                 ##  BETA=1. -- conservative (divergence form)
                 ##  BETA=0. -- non-conservative
                 ##  0. < BETA < 1.
                 element conservative_advection {
                    real
                 }
             }*,
            ## By default ICFERST uses a DCVFEM because it is more robust (Salinas et al. 2018),
            ## nonetheless the classical CVFEM can also be used.
            element FE_Pressure {
               empty
            }?
        }?,



        ## Use Fluidity to overwrite the input .msh file into a binary .msh file.
        ##
        ## Useful to convert your ASCII msh files into binary to be able to decompose the mesh.
        element create_binary_msh {empty}?
      }
   )

solver_options =
   (
    ## Options related to the linear and non-linear solvers.
    element solver_options{
    (
      ## Default Options for all the solvers
      element Linear_solver {
		advanced_solver_options_sym,
		linear_solver_options_sym,
        element Custom_solver_configuration{
(
	## Options for pressure solver
	element Pressure{
		advanced_solver_options_sym,
		linear_solver_options_sym
		}?,
	## Options for velocity solver
	element Velocity{
		advanced_solver_options_asym,
		linear_solver_options_asym
		}?,
	## Options for Transport solver
	element field {
		attribute name { xsd:string },
		advanced_solver_options_sym,
		linear_solver_options_sym
		}*
      )
}
}?,


        ## Maximum number of non-linear iterations for the Fixed-Point iteration solver.
        ##
        ## Manual suggests 2 for problems that are not very non-linear
        ##
        ## If using Fixed_Point_Iteration for multiphase porous media flow the recommendation is ~ 20
        ##
        ## If using Fixed_Point_Iteration/Infinite_norm_tol/adaptive_non_linear_iterations to dynamically control the number of
        ## non-linear iterations or Fixed_Point_Iteration/adaptive_timestep_nonlinear then ~ 15 is recommended.
		element Non_Linear_Solver {
           integer,
           ##NOTE: For multiphase porous media only. Otherwise this value is ignored.
           ##
           ## This is the convergence criterion for the Fixed Point Iteration solver.
           ## The functional to compare is:
           ##
           ## f = L2norm(S*-So)/L2norm(S1-So)
           ##
           ## S* is the latest saturation; So is the saturation at the previous FPI
           ## S1 is the saturation after the first FPI. Hence, the reduction of the difference
           ## of saturation is tested
           ##
           ## Recommended value: 5e-2
           element Fixed_Point_Iteration{
              real,
              (
                ## Tolerance for the infinite norm of the variation of the normalized selected field
                ## between two consecutive non-linear iterations.
                ##
                ## This can be used to control the number of non-linear interations dynamically.
                ##
                ## By default 0.01, 0.03 is a good value to increase the speed of the simulations; Recommended between 0.05 and 0.005
                element Infinite_norm_tol{
                real,
                  (
                    ## Use the infinity norm of the selected field to control the number of non-linear interations dynamically.
                    ##
                    ## A Variable to check has to be chosen:
                    ## 1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature
                    ##
                    ## The field selected in "adaptive_timestep_nonlinear" has preference over this
                    element adaptive_non_linear_iterations{
                    integer
                    }?
                  )
                }?
              ),
              (
                ##
                ## Recommended settings: Non-linear iterations ~ 20
                ## Backtracking_parameter = -10 automatically selection based on the Courant number, the shock-front Courant number and the physics of the problem
                ##
                ## The Backtracking value introduced is used as reference, so it may have a big impact on the convergence
                ##
                ## Recommended settings: Backtracking_parameter = -0.33 or -0.5 or -0.8;
                ## Note: Dynamic dumping loops over the Saturation solver up to 9 times and also uses techniques to accelerate the FPI convergence
                ##
                ## The more complex the problem is (i.e. bigger time-steps, gravity, capillary, etc) the smaller the value should be
                element Backtracking_factor{
                real
                }?
              ),
                ## Introduce over-relaxation in the saturation equation.
                ## This severely HELPS to reduce the number of FPI.
                ##
                ## If positive, the input value is the entry pressure.
                ##
                ## If negative, the input value is Peclet number desired.
                ##
                ## Recommended value for Saturation => -1e2
                ##
                ## Tip: If running with temperature and single phase disable this setting it to 0.
                element Vanishing_relaxation{
                real,
                  (
                    ## This method can also be applied for a transport equation.
                    ##
                    ## Recommended value for Temperature => -1e0
                    element Vanishing_for_transport{
                    real
                    }?
                  )
                }?,
              (
                ## For TEMPERATURE ONLY, if there are no sources nor sinks
                ## the non-linear solver can be accelerated by imposing physical constraints. Recommended to use.
                ##
	            ## This imposes that the temperature has to be between bounds.
                element Impose_min_max{empty}?
              ),
              (
                ## Convergence criterion based on the
                ## conservation of volume of each phase for the non-linear solver
            ##
	    ## By default the tolerance is 1e-2
                element Test_mass_consv{real,
                (
                ## Select this option if you want the simulation to terminate if after reaching the minimum time-step the non-linear solver fails to ensure mass convergence. Only works when adaptive time-step is on.
                element stop_at_min_ts{empty}?
                )}?
              ),
              (
                ## Adaptive timestep based on the number of non-linear iterations performed by the FPI solver.
                ##
                ## A Variable to check has to be chosen:
                ## 1 = Pressure; 2 = Velocity; 3 = PhaseVolumeFraction (default); 4 = Temperature
                element adaptive_timestep_nonlinear{
                    integer,
                  (
                    ## Time-step size controlled using a PID approach.
                    ## By default this method only controls the errors, and based on that increases or decreases the time-step size.
                    ## The default aim of number of FPI is the 20% of the maximum number of non-linear iterations.
                    ## The increase_factor and decrease_factor are multiplied by 1.2 to give more flexibility to the PID controller.
                    ##
                    ## If this is off, a classical method based on the number of FPI performed is used instead.
                    element PID_controller {
                      empty,
                        ## Time-step size is controlled to try to always perform the specified number of FPI introduced here.
                        ## By default this is the 20% of the maximum number of non-linear iterations.
                        element Aim_num_FPI {
                          integer
                        }?
                    }?,
                    ## If any of the solvers failt to achieve convergence the time-step size is
                    ## reduced and the time-level repeated without waiting to reach the maximum number of FPI.
                    ## Note: For the saturation for porous media it allows to diverge inside the saturation FPI.
                    element ensure_solvers_convergence {
                      empty
                    }?,
                    ## Number of FPI below which the time-step size is increased
                    ## by default it is the 25% of the maximum allowed FPIs
                    element increase_threshold{
                    integer
                    }?,
                    ## Multiply present timestep by this factor when increasing it.
                    ## By default 1.1
                    element increase_factor{
                    real
                    }?,
                    ## Multiply present timestep by this factor when decreasing it.
                    ## By default 2.0
                    element decrease_factor{
                    real
                    }?,
                    ## Maximum timestep. Beyond this value the timestep will not be increased.
                    ## By default unlimmited.
                    element max_timestep{
                    real
                    }?,
                    ## Minimum timestep. Beyond this value the timestep will not be decreased.
                    ## By default dt*1e-3.
                    element min_timestep{
                    real
                    }?
                  )
                }?
              )
           }?
        }?
      )}
   )


# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      interpolation_algorithm_scalar?
   )

# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_scalar_stat_options,
      diagnostic_detector_options
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_vector_field,
      interpolation_algorithm_vector?
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_tensor_stat_options,
      adaptivity_options_tensor_field,
      interpolation_algorithm_vector?
   )

diagnostic_cv_gradient_vector_field =
   (
      ## Choose whether the mass matrix is lumped or not
      element lump_mass_matrix {
            empty
      }?,
      ## Solver options are necessary if you're not lumping your mass or if you're field isn't dg
      element solver {
         linear_solver_options_sym
      }?,
      ## Normalise the gradient by its magnitude
      element normalise {
        empty
      }?,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field
   )

diagnostic_gradient_vector_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field
   )

diagnostic_cv_divergence_scalar_field =
   (
      # No solver options because it can be solved directly!
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field
   )

diagnostic_fe_divergence_scalar_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field
   )

# three optional input vectors for user-specified rotation matrix
rotation_matrix_components =
   (
      ## Select if you want to specify the normal direction
      ## of the rotation matrix.
      ## If off then fluidity computes the normal
      ## If on the tangents vectors must also be specified.
      element normal_direction {
         input_choice_real_dim_vector
      }?,
      ## specify first unit tangent vector to boundary
      element tangent_direction_1 {
         input_choice_real_dim_vector
      }?,
      ## specify second (if exists, i.e. if 3d) unit tangent vector to boundary
      element tangent_direction_2 {
         input_choice_real_dim_vector
      }?
   )

velocity_components_choice =
   (
      (

         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## NOT USED - choose "dirichlet" instead for the cty bcs
         ##
         ## This applies a Dirichlet condition through the continuity equation
         ## and thus will only apply a normal component of this specified
         ## velocity as the boundary condition.
         element type {
            attribute name { "dirichlet_continuity" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## This applies a Dirichlet condition through the viscous terms in the
         ## momentum equation. It will be applied to each of the components specified.
         element type {
            attribute name { "dirichlet_viscosity" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         ## This applies a Dirichlet condition for the advection velocity
         ## of the momentum equation.
         element type {
            attribute name { "dirichlet_advection" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            },
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         ## Add a bulk formulae boundary condition. Only makes sense
         ## on the Velocity field.
         element type {
            attribute name { "bulk_formulae" },
               empty
         }|
         element type {
           attribute name { "free_surface" },
           (
              ## This options adds a surface stabilisation term to the free surface. Works only for cg velocity so far.
              ## Note: Once activated, the stabilisation term will occur in all free surface areas in the domain.
              ## IN DEVELOPMENT
              element surface_stabilisation {
                  ## Scale factor for the surface stabilisation.
                  element scale_factor{
                    real
                  }
              }?
           )
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                ## Use the Manning-Strickler formulation:
                ## n^2*g*|u|*u/H^(1/3)
                ## where n is the Manning coefficient, g is gravity, u is the velocity vector and H is the water heigth at that point.
                ##
                ## The coefficient given above defines the Manning coefficient [s/m^(1/3)] (a typical value for sand is 0.02)
                element manning-strickler {
                   empty
                }?
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|


         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air.
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the
                  ## recommended (non-dimensional) value of 1.0 for
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition.
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real},
            ## if not set then Cb=2*h, where h is the element size
            element Cb {real}?
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition.
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }|
         ## Dummy BC
         ##
         ## Should be used in combination with the near_wall_treatment condition.
         ## When activated wall treatment is not applied on the wall-outflow edge.
         element type{
            attribute name { "outflow" }
         }|
         ## Momentun BC
         ##
         element type{
            attribute name { "momentum" },
            velocity_components_choice
         }|
         ## Momentun BC
         ##
         element type{
            attribute name { "momentuminout" },
            velocity_components_choice
         }
      )
   )


# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )

# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat

      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat =
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_enabled_default = include_stat
tensor_field_stat_options_enabled_default |= exclude_components_from_stat
tensor_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for tensor fields, with enabled by default
tensor_field_stat_options_disabled_default = exclude_stat
tensor_field_stat_options_disabled_default |= exclude_components_from_stat
tensor_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_velocity_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_velocity_stat_options.stat
         )
      }
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Diagnostic statistics for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_tensor_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options
prescribed_tensor_stat_options = prognostic_tensor_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_velocity_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_velocity_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         ## Enable to output the pressure and viscous terms separately (as well
         ## as the total force)
         element output_terms {
            comment
         }?,
         integer_vector
      }?,
      ## Compute the divergence of this field at the Gauss points
      ## and return its stats.  This is a direct measure of the
      ## divergence at the gauss points rather than a discrete measure
      ## at the nodes (provided by several other diagnostic fields).
      element divergence_stats {
        empty
      }?,
      ## Calculate the error in the conservation of momentum
      ## IN PROGRESS - Does not include all terms!
      element calculate_momentum_conservation_error {
         empty
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Combining of stat elements for tensor fields
prognostic_tensor_stat_no_old_or_nonlinear_options.stat =
   (
      tensor_field_stat_options_enabled_default
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default =
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default =
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields,
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  pressure_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  pressure_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that FLUIDITY knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.

         ## Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Temperature" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CopiedField - This field copies the previous timesteps
         ## values from another (specified) field at every iteration
         ## and then solves the field using different (again, specified)
         ## scheme and solution options.
         ## For instance, this field can be used to create a diffused
         ## field to adapt to.
         ## Unless someone requests otherwise this is only currently possible
         ## for fields within the same material_phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopiedField" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  attribute copy_from_field { string },
                  prognostic_scalar_field
               }
            )
         }|
         ## Mass Fraction of Solute
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SoluteMassFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## PhaseVolumeFraction
         ## Required in porous_media and multiphase problem types
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFraction" },
            (
               element prognostic {
                  pressure_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  pressure_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt
               }
            )
         }|
         ## ComponentMassFractionPhase1
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         ##
         ## Do not forget to set boundary conditions for the PhaseVolumeFraction
         ## even if the problem is one-phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase1" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  pressure_mesh_choice,
                  phase_properties_options,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  pressure_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt
               }
            )
         }|
         ## ComponentMassFractionPhase2
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         ##
         ## Do not forget to set boundary conditions for the PhaseVolumeFraction
         ## even if the problem is one-phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase2" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  pressure_mesh_choice,
                  phase_properties_options,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  pressure_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt
               }
            )
         }|
         ## ComponentMassFractionPhase3
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         ##
         ## Do not forget to set boundary conditions for the PhaseVolumeFraction
         ## even if the problem is one-phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase3" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  pressure_mesh_choice,
                  phase_properties_options,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  pressure_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt
               }
            )
         }|
         ## ComponentMassFractionPhase4
         ## Optional in multiphase problem types
         ##
         ## attribute material_phase_name associates this
         ## mass fraction with a particular phase
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ComponentMassFractionPhase4" },
            ## Specify the phase to which this component fraction relates
            attribute material_phase_name { xsd:string },
            (
               element prognostic {
                  pressure_mesh_choice,
                  phase_properties_options,
                  prognostic_scalar_field
               }|
               element prescribed {
                  pressure_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  pressure_mesh_choice,
                  internal_algorithm,
                  diagnostic_scalar_field_no_adapt
               }
            )
         }|
         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }

# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.
#
#         ## Prescribed scalar fields below this
#         element ___Prescribed_fields_below___ {
#            empty
#         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ##
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
             attribute rank { "0" },
             attribute name { "Dummy" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_scalar_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }
# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
#         ## Prescribed vector fields below this
#         element ___Prognostic_fields_below___ {
#            empty
#         }|

# -- List of fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
#         ## Prescribed vector fields below this
#         element ___Prescribed_fields_below___ {
#            empty
#         }|

#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Coordinate field remapped to the mesh of your choice.
         element vector_field {
             attribute rank { "1" },
             attribute name { "DiagnosticCoordinate" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ##
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  legacy_internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }


# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },	
 	        ## This option is used to specify a dimension different to ndim (typically number of phases), which is the default.
 	        ## To be used only with the tensor name UAbsorB. Which is a tensor type used
 	        ## to impose an absorption term for the momentum equation using a diagnostic tensor using python.
            element nphase { integer }?,            
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  tensor_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_tensor_field
               }
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }

# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

limiter_options =
  (
      (
        ## Limit the face value to satisfy a boundedness criterion.
        ## Only for tracer-type fields
        element Limiter_options{
          (
            sweby_limiter|
            compressive_advection_limiter|
            ENO_advection
          )
        }|
        ## Do not limit the face value
        element do_not_limit_face_value{
          empty
        }
      )
  )

sweby_limiter =
  ## See "High-Resolution Schemes Using Flux Limiters for
  ## Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
  ## Journal on Numerical Analysis, 21, 995-1011
  element limiter {
    attribute name {"Sweby"},
    slope_options?,
    upwind_value_options?
  }

compressive_advection_limiter =
  element limiter {
    attribute name {"CompressiveAdvection"},
    InterfaceCapturing_options?
  }

ENO_advection =
  element limiter {
    attribute name {"ENO"}
  }

InterfaceCapturing_options =
   (
     ## Controls the negative diffusion added to the interface
     ## Defaults to full negative diffusion (= 1.0) if unselected
     element value {
        real
     }?
   )

slope_options =
   (
      ## Control the upper and lower slopes of the NVD limiter
      element slopes {
         ## Defaults to Sweby, 1984 limiter (= 1.0) if unselected
         element lower {
            real
         }?,
         ## Defaults to Sweby, 1984 limiter (= 2.0) if unselected
         element upper {
            real
         }?
      }
   )

upwind_value_options =
   (
      (
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## This method projects the upwind value from a point in the element just
         ## upwind of the node pair straddling the face.  It is otherwise known as
         ## anisotropic limiting.
         ## This is only available on simplex meshes as it involes a search around
         ## the donor node to find the upwind element.
         element project_upwind_value_from_point {
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which it was found from.
            element bound_projected_value_locally {
               empty
            }?,
            ## Store the locations of the elements where the upwind values
            ## are projected from for each node pair.
            ## This inserts an integer csr matrix into state so is memory expensive but
            ## saves a significant amount of time (searching around the neighbouring elements).
            ## This is unsafe for moving meshes but should be ok for adaptive meshes.
            element store_upwind_elements {
               ## Store the quadrature locations within the elements
               ## where the upwind values
               ## are projected from for each node pair.
               ## This inserts a real block csr matrix into state so is even more memory
               ## expensive than just storing the upwind elements and
               ## only saves a comparitively
               ## marginal amount of time (as actually searching the
               ## neighbouring elements is the
               ## slowest bit, finding the quadrature is relatively easy).
               element store_upwind_quadrature {
                  empty
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Projects the value of the advected variable from the downwind or donor node
         ## using the interpolated gradient at the donor node in the
         ## direction of the vector
         ## connecting the node pair straddling the face.
         ## This is available on all meshes (except if bounding the values).
         element project_upwind_value_from_gradient {
            (
               ## Select which node to project from:
               ## Project from the downwind node (Jasak et al., 1999) so that:
               ## upwind_value = downwind_value - 2*gradient.vector
               element project_from_downwind_value {
                  comment
               }|
               ## Select which node to project from:
               ## Project from the donor node so that:
               ## upwind_value = donor_value - gradient.vector
               element project_from_donor_value {
                  comment
               }
            ),
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which surround it.
            ## This is only available on simplex meshes as it involes a search around
            ## the donor node to find the upwind element.
            element bound_projected_value_locally {
               ## Store the locations of the elements closest to the project value.
               ## This inserts an integer csr matrix into state so is
               ## memory expensive but
               ## saves a significant amount of time (searching around
               ## the neighbouring elements).
               ## This is unsafe for moving meshes but should be ok for adaptive meshes.
               element store_upwind_elements {
                  comment
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the maximum or minimum of the neighbouring
         ## nodes depending on the local slope of the donor and downwind values.
         ## Otherwise known as isotropic limiting.
         ## This is available on all meshes except periodic domains.
         element locally_bound_upwind_value {
            empty
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the value at the node most directy
         ## upwind from the vector connecting the donor and downwind nodes.
         ## This is available on all meshes.
         element pseudo_structured_upwind_value {
            empty
         }
      )
   )

field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins
         ## e.g. the values -1.5 0.0 1.5 2.0 will return 4 bins
         ## and the fraction of the field in each bin with,
         ## -1.5<=field<0.0, 0.0<=field<1.5, 1.5<=field<2.0, 2.0<=field,
         ## will be calculated.
         element mixing_bin_bounds {
            (
                 ## list of bin bounds
                 element constant {
                     real_vector
                 }|
                 ## Python function prescribing bin bounds. Functions should be of the form:
                 ##
                 ##  def val(t):
                 ##     # Function code
                 ##     return # Return value that should be an array of reals
                 ##
                 ##
                 element python {
                     python_code
                   }
              )
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )

phase_viscosity =(
                  element tensor_field {
                     attribute name { "Viscosity" },
                     attribute rank { "2" },
                     (
                        element prescribed {
                            velocity_mesh_choice?,
                            prescribed_tensor_field_no_adapt
                        }|
                        ## For electrical modelling only - holds electrical conductivity
                        element diagnostic {
                           (
                              tensor_python_diagnostic_algorithm |
                              internal_algorithm
                           ),
                           velocity_mesh_choice,
                           diagnostic_tensor_field
                        }
                     )
                  }
)


phase_density =
               (
                  (
## Use this option to specify the density of fluids
element Density{(

                     ## Equations of state
                     element incompressible {
                        real}|
                     ## Equations of state for compressible applications
                     element compressible {(
                        ## Linear in Pressure EOS
                        ##
                        ## DEN = A * P + B
                        ##
                        ## Use this option for flooding, being A = 1/gravity and B the bathymetry
                        element linear_in_pressure {
                           element coefficient_A {
                              real
                           },
                           element coefficient_B {
                            (
                                 ## list of bin bounds
                                 element constant {
                                     real
                                 }|
                                ## Python function prescribing real input. Functions should be of the form:
                                ##    def val(X, t):
                                ##    # Function code
                                ##    return # Return value
                                ##
                                ##    where X is a tuple of length geometry dimension.
                                 element python {
                                     python_code
                                   }
                              )
                           },
                           ## If chosen: DEN = A * P / T + B
                           element include_internal_energy {
                              empty
                           }?
                        }|
                        ## Stiffened Gas EoS
                        ##
                        ## DEN = ( P + EOS_COEFS( 1 )) * EOS_COEFS( 2 ) / T
                        ##
                        ## Note that setting EOS_COEFS( 1 ) = 0. and EOS_COEFS( 2 ) = 1/gas constant (Rd [J/kg/K])
                        ## The equation for ideal gases is obtained.
                        element stiffened_gas {
                           element eos_option1 { real },
                           element eos_option2 { real },
                           ## reference uncompressed density
                           ##
                           ## if activated then either Liquid EoS or
                           ## full Stiffened Gas EoS
                           element reference_density {
                              real
                           }?,
                           ## Ratio of specific heats at constant
                           ## pressure to that at constant volume
                           ##
                           ## Requires an energy field.
                           ## If activated then a full Stiffened Gas EoS
                           element ratio_specific_heats {
                              real
                           }?,
                           ## bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density
                           ##
                           ## if activated then either full or partial Liquid EoS or full
                           ## Stiffened Gas EoS
                           element bulk_sound_speed_squared {
                              real
                           }?
                        }|
                        ## Exponential in Pressure EOS
                        ##
                        ## DEN = A * P ^ B
                        ##
                        element exponential_in_pressure {
                           element coefficient_A {
                              real
                           },
                           element coefficient_B {
                              real
                           }
                        }|
                        ## Concentration-dependant EOS
                        ##
			## Temperature and concentration can be considered simultaneously with this equation which is the recommended for the Boussinesq approximation.
                        ##
                        ## DEN = DEN0 * ( 1 + Alpha * C - Beta * (Temp -T0))
                        ##
                        ## C is the solute mass concentration and DEN0 is the reference density corresponding to C = 0
                        ##
                        ## Beta is the thermal expansion and a reference Temperature needs to be set.
                        ##
                        ## Note: this equation can be used only with concentration, temperature or both simultaneously.
                        element concentration_dependant {
                           element reference_density {
                              real
                           },
                           element alpha {
                              real
                           }?,
                           ## Reference temperature (default 298)
                           element T0 {
                              real
                           }?,
                           ## Thermal expansion (Kelvin^-1)
                           element beta {
                              real
                           }?
                        }|
                        ## Temperature-Pressure correlation for liquids ONLY. With the Boussinesq approximation, only temperature
                        ## variation is considered.
                        ##
                        ## Range of applicability: 0 to 2*10^9 Pa.
                        ##
                        ## rho1 = rho0/(1+Beta(T1-T0))/(1-(P1-P0)/E)
                        ##
                        ## where rho0 is the reference density at temperature T0 and pressure P0;
                        ##
                        ## Beta is volumetric expansion coefficient (m^3/m^3 Celsius);
                        ##
                        ## E is the liquid elasticity bulk modulus (N/m^2);
                        ##
                        ## NOTE: if temperature is not defined the temperature is defined as zero.
                        element Temperature_Pressure_correlation {
                           ## Reference density
                           element rho0 {
                              real
                           },
                           ## Reference temperature
                           element T0 {
                              real
                           },
                           ## Reference Pressure
                           element P0 {
                              real
                           },
                           ## volumetric expansion coefficient (m^3/m^3 Celsius)
                           element coefficient_Beta {
                              real
                           },
                           ## liquid elasticity bulk modulus (N/m^2)
                           element coefficient_E {
                              real
                           }
                        }
                      ),      ## Use the boussinesq approximation. Useful for small variations of density.
                        element Boussinesq_approximation { empty }?}|
                     ## The "Dummy" diagnotic field on the pressure mesh is required for this option
                     element python_state{
                       scalar_python_diagnostic_algorithm
                     }
                    ),
                    ## Linearises a P2 field. Use this if having stability issues with high-order discretisations
                    element linearise_density {empty}?}

                  )
               )

phase_properties_options =
               (
              ## Options to provide properties of the fluid for the given phase.
              ## Component properties overwrite the ones given for a phase and are mandatory for all the components.
              element phase_properties{
                (
                ## Phase density
                phase_density,


                ## Viscosity of the current phase (tensor field)
                element Viscosity {
                phase_viscosity,
                    ## Linearises a P2 field. Use this if having stability issues with high-order discretisations
                    element linearise_viscosity {empty}?,
               element viscosity_scheme {
                  (
                     ## Tensor form
                     element tensor_form {
                        empty
                     }|
                     ## Stress form
                     element stress_form {
                        empty
                     }|
                     ## Compact discontinuous Galerkin scheme.
                     ## (Peraire and Persson SIAM J. Sci. Comput. 30, p1806)
                     element compact_discontinuous_galerkin {
                        ## Penalty_parameter
                        ## Add penalty term Int [u][v] dS on element boundaries
                        ## scaled by C_0
                        element penalty_parameter {
                           real
                        }?
                     }|
                     ## Classical scheme from Bassi and Rebay
                     ## (JCP 131 267-179 1997)
                     element bassi_rebay {
                        empty
                     }|
                     ## Scheme in which upwinding is applied in
                     ## alternating directions. Devised by C.Pain.
                     element arbitrary_upwind {
                        empty
                     }

                  ),
                  (
                     ## Non-linear scheme
                     element nonlinear_scheme {
                        element beta_viscosity_min{ real }?,
                        element beta_viscosity_max{ real }?
                     }|
                     ## Linear scheme
                     element linear_scheme {
                        element high_order { empty } ?
                     }
                  ),
                  ## defaults to 0.
                  element zero_or_two_thirds {
                     real
                  }?
               }
                },
              ## Thermal conductivity (in S.I. watts per meter-kelvin => W/(m·K) ).
              element tensor_field {
                 attribute name { "Thermal_Conductivity" },
                 attribute rank { "2" },
                 (
                    element prescribed {
                        mesh_choice?,
                        prescribed_tensor_field_no_adapt
                    }|
                    ## For electrical modelling only - holds electrical conductivity
                    element diagnostic {
                       (
                          tensor_python_diagnostic_algorithm |
                          internal_algorithm
                       ),
                       diagnostic_tensor_field
                    }
                 )
              }?,
              ## Specific heat capacity for field
              element scalar_field {
                 attribute name { "HeatCapacity" },
                 attribute rank { "0" },
                 (
                    element prescribed {
                       prescribed_scalar_field_no_adapt
                    }|
                    ## This only works for traffic modelling
                    element diagnostic {
                       (
                          scalar_python_diagnostic_algorithm |
                          internal_algorithm
                       ),
                       diagnostic_scalar_field_no_adapt
                    }
                 )
              }?,
              ## Solute diffusivity (in S.I. m^2/s ).
              element tensor_field {
                 attribute name { "Solute_Diffusivity" },
                 attribute rank { "2" },
                 (
                    element prescribed {
                        mesh_choice?,
                        prescribed_tensor_field_no_adapt
                    }|
                    ## For electrical modelling only - holds electrical conductivity
                    element diagnostic {
                       (
                          tensor_python_diagnostic_algorithm |
                          internal_algorithm
                       ),
                       diagnostic_tensor_field
                    }
                 )
              }?,
                ## Stabilisation for Inertia dominated flow.
                ## LES and Petrov-Galerkin stabilisation are available.
                element Stabilisation{(
                   ## Usual LES modeling
                   element les_model {
                      ## =0 No LES,
                      ## =1 Anisotropic element length scale,
                      ## =2 Take the average length scale h,
                      ## =3 Take the min length scale h,
                      ## =4 Take the max length scale h
                      element model {
                         integer
                      },
                      ## literature sybol: Cs
                      ##
                      ## defaults to 0.1
                      element smagorinsky_coefficient {
                         real
                      }?,
                      (
                         ## Tensor form
                         element tensor_form {
                            empty
                         }|
                         ## Stress form
                         element stress_form {
                            empty
                         }
                      ),
                      ## defaults to 1.0
                      element les_theta { real }?
                   }?,
                   ## This applies a non-linear shock capturing scheme which
                   ## may be used to reduce oscillations in velocity or
                   ## perform implicit LES modelling of turbulence.
                   element Petrov_Galerkin_stabilisation {
                      ## What type of Petrov-Galerkin method to use:
                      ## =1 is the residual squared approach,
                      ## =2 is max(0, A . grad U * residual ),
                      ## =3 is the max of 1 and 2 (the most dissipative).
                      element method {
                         integer
                      },
                      ## [0,1] is the magnitude of the non-linear dissipation.
                      ## =0.25 is small,
                      ## =1.0 is large.
                      ## Defaults to 1.
                      element nonlinear_velocity_coefficient {
                         real
                      }?,
                      ## [0,1] decides if we include the pressure term in A . grad soln if
                      ## =0.0 don't include pressure term,
                      ## =1.0 include the pressure term.
                      ## Defaults to 1.
                      element  include_pressure{
                         real
                      }?,
                      (
                         ## Tensor form
                         element tensor_form {
                            empty
                         }|
                         ## Stress form
                         element stress_form {
                            empty
                         }
                   )
                   }?


                )}?
               )
              }
            )
