\hypertarget{namespacecopy__outof__state}{}\doxysection{copy\+\_\+outof\+\_\+state Module Reference}
\label{namespacecopy__outof__state}\index{copy\_outof\_state@{copy\_outof\_state}}


This module enables the multiphase prototype code to interact with state by copying everything required from state to I\+C\+F\+E\+R\+ST, adaptive time-\/stepping, outfluxes computation, tunneled B\+Cs and Darcy velocity.  


\doxysubsection*{Functions/\+Subroutines}
\begin{DoxyCompactItemize}
\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_ab5c876f8f241119d1dedc0bffa8fa159}{get\+\_\+primary\+\_\+scalars\+\_\+new}} (state, Mdims)
\begin{DoxyCompactList}\small\item\em This subroutine extracts all primary variables associated with the mesh from state, and associated them with the variables used in the Multi\+Fluids model. \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_abba0b467480d0b56c11d18f70e8c680e}{compute\+\_\+node\+\_\+global\+\_\+numbers}} (state, ndgln)
\begin{DoxyCompactList}\small\item\em This subroutine calculates the global node numbers requested to operates in I\+C\+F\+E\+R\+ST. \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a25e9236f15044530da105400e0e3e3f4}{get\+\_\+ele\+\_\+type}} (x\+\_\+nloc, cv\+\_\+ele\+\_\+type, p\+\_\+ele\+\_\+type, u\+\_\+ele\+\_\+type, mat\+\_\+ele\+\_\+type, u\+\_\+sele\+\_\+type, cv\+\_\+sele\+\_\+type)
\begin{DoxyCompactList}\small\item\em \+: Obtain the type of element u\+\_\+ele\+\_\+type = cv\+\_\+ele\+\_\+type = p\+\_\+ele\+\_\+type will flag the dimension and type of element\+: = 1 or 2\+: 1D (linear and quadratic, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 3 or 4\+: triangle (linear or quadratic, respectively) = 5 or 6\+: quadrilateral (bi-\/linear or tri-\/linear, respectively)-\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 7 or 8\+: tetrahedron (linear or quadratic, respectively) = 9 or 10\+: hexahedron (bi-\/linear or tri-\/linear, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_aed2618045311aa635b4b0bd2599ab609}{get\+\_\+ele\+\_\+type\+\_\+new}} (Mdims, Mdisopt)
\begin{DoxyCompactList}\small\item\em \+: Obtains the element type Mdisoptu\+\_\+ele\+\_\+type = Mdisoptcv\+\_\+ele\+\_\+type = Mdisoptp\+\_\+ele\+\_\+type will flag the dimension and type of element\+: = 1 or 2\+: 1D (linear and quadratic, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 3 or 4\+: triangle (linear or quadratic, respectively) = 5 or 6\+: quadrilateral (bi-\/linear or tri-\/linear, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 7 or 8\+: tetrahedron (linear or quadratic, respectively) = 9 or 10\+: hexahedron (bi-\/linear or tri-\/linear, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_add060a0a644c1d8db9c718a82d89c852}{get\+\_\+discretisation\+\_\+options}} (state, Mdims, Mdisopt)
\begin{DoxyCompactList}\small\item\em \+: This subroutine extract all discretisation options from the schema D\+I\+S\+O\+PT Options\+: =0 1st order in space Theta=specified U\+N\+I\+V\+E\+R\+S\+AL =1 1st order in space Theta=non-\/linear U\+N\+I\+V\+E\+R\+S\+AL =2 Trapezoidal rule in space Theta=specified U\+N\+I\+V\+E\+R\+S\+AL =2 if isotropic limiter then F\+E\+M-\/quadratic \& stratification adjust. Theta=non-\/linear =3 Trapezoidal rule in space Theta=non-\/linear U\+N\+I\+V\+E\+R\+S\+AL =4 Finite elements in space Theta=specified U\+N\+I\+V\+E\+R\+S\+AL =5 Finite elements in space Theta=non-\/linear U\+N\+I\+V\+E\+R\+S\+AL =6 Finite elements in space Theta=specified N\+O\+NE =7 Finite elements in space Theta=non-\/linear N\+O\+NE =8 Finite elements in space Theta=specified D\+O\+W\+N\+W\+I\+N\+D+\+I\+N\+T\+E\+R\+F\+A\+CE T\+R\+A\+C\+K\+I\+NG =9 Finite elements in space Theta=non-\/linear D\+O\+W\+N\+W\+I\+N\+D+\+I\+N\+T\+E\+R\+F\+A\+CE T\+R\+A\+C\+K\+I\+NG \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_ab4280b302a2f45375be2df118ed6d100}{update\+\_\+boundary\+\_\+conditions}} (state, stotel, cv\+\_\+snloc, nphase, suf\+\_\+t\+\_\+bc, suf\+\_\+t\+\_\+bc\+\_\+rob1, suf\+\_\+t\+\_\+bc\+\_\+rob2, tracer)
\begin{DoxyCompactList}\small\item\em \+: Sets the boundary condition, if the time has advanced and the B\+Cs changed, here they are set to the new time-\/level \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_afca89971343f6586b89f1cddda00b2c8}{pack\+\_\+multistate}} (npres, state, packed\+\_\+state, multiphase\+\_\+state, multicomponent\+\_\+state, pmulti\+\_\+state)
\begin{DoxyCompactList}\small\item\em \+: This subroutine creates packed\+\_\+state from state(\+:) and links the appropiate memory so it is acessible from both states. This subroutine also introduces fields not used by fludity but required by I\+C-\/\+F\+E\+R\+ST \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_adba75f9a3f64d519ecf58b2b9159d629}{prepare\+\_\+absorptions}} (state, Mdims, multi\+\_\+absorp)
\begin{DoxyCompactList}\small\item\em \+: Prepares the memory to compute absorption fields \end{DoxyCompactList}\item 
type(vector\+\_\+field) function, public \mbox{\hyperlink{namespacecopy__outof__state_abfa3817b7e0890e5009c4905376a5688}{as\+\_\+vector}} (tfield, dim, slice)
\begin{DoxyCompactList}\small\item\em \+: This function points a tensor field as a vector field type This is necessary when solving for tensor fields that are actually multiphase vector fields. \end{DoxyCompactList}\item 
type(vector\+\_\+field) function, public \mbox{\hyperlink{namespacecopy__outof__state_a6bc946977b60a10ae77f86013eb499e7}{as\+\_\+packed\+\_\+vector}} (tfield)
\begin{DoxyCompactList}\small\item\em \+: This function points a tensor field as a vector field type This is necessary when solving for tensor fields that are actually multiphase vector fields. \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a60ec84623fb582762f2139794470ba13}{finalise\+\_\+multistate}} (packed\+\_\+state, multiphase\+\_\+state, multicomponent\+\_\+state)
\begin{DoxyCompactList}\small\item\em \+: Destrys packed\+\_\+state and the passed down states \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a577c504f5230ff200ee711334eebe54a}{adaptive\+\_\+nonlinear}} (Mdims, packed\+\_\+state, reference\+\_\+field, its, Repeat\+\_\+time\+\_\+step, Exit\+Non\+Linear\+Loop, non\+Linear\+Adapt\+Ts, old\+\_\+acctim, order, calculate\+\_\+mass\+\_\+delta, adapt\+\_\+mesh\+\_\+in\+\_\+\+F\+PI, Accum\+\_\+\+Courant, Courant\+\_\+tol, Current\+\_\+\+Courant, first\+\_\+time\+\_\+step)
\begin{DoxyCompactList}\small\item\em \+: This subroutine either store variables before the nonlinear timeloop starts, or checks how the nonlinear iterations are going and depending on that increase the timestep or decreases the timestep and repeats that timestep \end{DoxyCompactList}\item 
real function, public \mbox{\hyperlink{namespacecopy__outof__state_ad775c010bade229fba0416002e6928a6}{inf\+\_\+norm\+\_\+scalar\+\_\+normalised}} (tracer, reference\+\_\+tracer, dumping, totally\+\_\+min\+\_\+max)
\begin{DoxyCompactList}\small\item\em Calculate the inf norm of the normalised field, so the field goes from 0 to 1 It requires as inputs the tracer to be used and the reference tracer to normallise, the dumping to be set to 1.\+0 and totally\+\_\+min\+\_\+max which includes the min max values of the field across all processors also for normalisation. \end{DoxyCompactList}\item 
real function, public \mbox{\hyperlink{namespacecopy__outof__state_a7d6957a54cc1cc0a38a4a7a90bca1f89}{get\+\_\+convergence\+\_\+functional}} (phasevolumefraction, reference\+\_\+sat, dumping, its)
\begin{DoxyCompactList}\small\item\em \+: We create a potential to optimize F = sum (f$\ast$$\ast$2), so the solution is when this potential reaches a minimum. Typically the value to consider convergence is the sqrt(epsilon of the machine), i.\+e. 10$^\wedge$-\/8 f = (New\+Sat-\/\+Old\+Sat)/\+Number of nodes; this is the typical approach for algebraic non linear systems \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a0520a99d915a669f52eadab9a438194b}{get\+\_\+var\+\_\+from\+\_\+packed\+\_\+state}} (packed\+\_\+state, F\+E\+Density, Old\+F\+E\+Density, Iterated\+F\+E\+Density, Density, Old\+Density, Iterated\+Density, Phase\+Volume\+Fraction, Old\+Phase\+Volume\+Fraction, Iterated\+Phase\+Volume\+Fraction, Velocity, Old\+Velocity, Iterated\+Velocity, F\+E\+Phase\+Volume\+Fraction, Old\+F\+E\+Phase\+Volume\+Fraction, Iterated\+F\+E\+Phase\+Volume\+Fraction, Nonlinear\+Velocity, Old\+Nonlinear\+Velocity, Iterated\+Nonlinear\+Velocity, Component\+Density, Old\+Component\+Density, Iterated\+Component\+Density, Component\+Mass\+Fraction, Old\+Component\+Mass\+Fraction, Temperature, Old\+Temperature, Iterated\+Temperature, F\+E\+Temperature, Old\+F\+E\+Temperature, Iterated\+F\+E\+Temperature, Iterated\+Component\+Mass\+Fraction, F\+E\+Component\+Density, Old\+F\+E\+Component\+Density, Iterated\+F\+E\+Component\+Density, F\+E\+Component\+Mass\+Fraction, Old\+F\+E\+Component\+Mass\+Fraction, Iterated\+F\+E\+Component\+Mass\+Fraction, Pressure, F\+E\+Pressure, Old\+F\+E\+Pressure, C\+V\+Pressure, Old\+C\+V\+Pressure, C\+V\+\_\+\+Immobile\+\_\+\+Fraction, Coordinate, Velocity\+Coordinate, Pressure\+Coordinate, Material\+Coordinate, Cap\+Pressure, Immobile\+\_\+fraction, End\+Point\+Relperm, Relperm\+Exponent, Cap\+\_\+entry\+\_\+pressure, Cap\+\_\+exponent, Imbibition\+\_\+term, Concentration, Old\+Concentration, Iterated\+Concentration, F\+E\+Concentration, Old\+F\+E\+Concentration, Iterated\+F\+E\+Concentration, Enthalpy, Old\+Enthalpy, Iterated\+Enthalpy, F\+E\+Enthalpy, Old\+F\+E\+Enthalpy, Iterated\+F\+E\+Enthalpy)
\begin{DoxyCompactList}\small\item\em @\+D\+E\+P\+R\+E\+C\+A\+T\+ED\+: Gets memory from packed state This subroutine returns a pointer to the desired values of a variable stored in packed state All the input variables (but packed\+\_\+stated) are pointers following the structure of the $\ast$\+\_\+\+A\+LL variables and also all of them are optional, hence you can obtaine whichever you want \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a5fa62e07eab3607bcf414b67abe1148a}{printcsrmatrix}} (Matrix, find, col, dim\+\_\+same\+\_\+row)
\begin{DoxyCompactList}\small\item\em \+: Subroutine to print C\+SR matrix by (row, column) Dimensions and phases are printed in different rows So for example Matrix(2,2,10) with two rows would be presented as a matrix ( 8 x 10) \end{DoxyCompactList}\item 
logical function, public \mbox{\hyperlink{namespacecopy__outof__state_ab7c981b328d9950b1c375aaacaa3cda0}{is\+\_\+constant}} (tfield)
\begin{DoxyCompactList}\small\item\em \+: Checks whether a field is constant or not \end{DoxyCompactList}\item 
character(len=field\+\_\+name\+\_\+len) function, public \mbox{\hyperlink{namespacecopy__outof__state_abc850cced2fb9b525f015e758e4b45da}{getoldname}} (tfield)
\begin{DoxyCompactList}\small\item\em \+: For a given field, retrieve the associated old field name \end{DoxyCompactList}\item 
character(len=field\+\_\+name\+\_\+len) function, public \mbox{\hyperlink{namespacecopy__outof__state_ac1305d6f3dc1c1ec92a4135ea55947b9}{getfemname}} (tfield)
\begin{DoxyCompactList}\small\item\em \+: For a given field, retrieve the associated finite element field name \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a1394fdd5e9adcc149eb319739c07f854}{calculate\+\_\+internal\+\_\+volume}} (packed\+\_\+state, Mdims, mass\+\_\+ele, calculate\+\_\+mass, cv\+\_\+ndgln, D\+E\+N\+\_\+\+A\+LL, eles\+\_\+with\+\_\+pipe)
\begin{DoxyCompactList}\small\item\em \+: Subroutine to calculate the integrated mass inside the domain \end{DoxyCompactList}\item 
logical function, public \mbox{\hyperlink{namespacecopy__outof__state_acea2acdccf9091776be013ade24bcd97}{have\+\_\+option\+\_\+for\+\_\+any\+\_\+phase}} (path, nphase)
\begin{DoxyCompactList}\small\item\em \+: Subroutine to check whether an option is true for any phase in diamond, if any is true it returns true. The path must be the part of the path inside the phase, i.\+e. /multiphase\+\_\+properties/capillary\+\_\+pressure \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a2a2f72be9cad756d2151473988566c8d}{get\+\_\+darcyvelocity}} (Mdims, ndgln, state, packed\+\_\+state, upwnd)
\begin{DoxyCompactList}\small\item\em \+: This subroutine calculates the actual Darcy velocity, but with P0\+DG precision only! \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_adbfe914b0d919d92535a188ab7c0e384}{dump\+\_\+outflux}} (current\+\_\+time, itime, outfluxes)
\begin{DoxyCompactList}\small\item\em \+: Subroutine that dumps the total flux at a given timestep across all specified boundaries to a file called \textquotesingle{}simulation\+\_\+name\+\_\+outfluxes.\+csv\textquotesingle{}. In addition, the time integrated flux up to the current timestep is also outputted to this file. Integration boundaries are specified in diamond via surface\+\_\+ids. (In diamond this option can be found under \char`\"{}/io/dump\+\_\+boundaryflux/surface\+\_\+ids\char`\"{} and the user should specify an integer array containing the I\+Ds of every boundary they wish to integrate over). \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a3e466dfb76c8c3e30de12d2f7d36d3bb}{update\+\_\+outfluxes}} (bcs\+\_\+outfluxes, outfluxes, sele, cv\+\_\+nodi, suf\+\_\+area, Vol\+\_\+flux, Mass\+\_\+flux, tracer, outfluxes\+\_\+fields, start\+\_\+phase, end\+\_\+phase)
\begin{DoxyCompactList}\small\item\em \+: Updates the outfluxes information based on N\+D\+O\+T\+Q\+N\+EW, shape functions and transported fields for a given GI point in a certain element This subroutine should only be called if S\+E\+LE is on the B\+O\+U\+N\+D\+A\+RY Example of Mass\+\_\+flux\+: ndotq(iphase) $\ast$ Sdev\+FunsD\+E\+T\+W\+EI(gi) $\ast$ L\+I\+M\+T(iphase) Example of Vol\+\_\+flux\+: ndotq(iphase) $\ast$ Sdev\+FunsD\+E\+T\+W\+EI(gi) $\ast$ L\+I\+M\+D\+T(iphase) \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a6c5000c06758c4e42744252542c849cb}{enterforcebalanceequation}} (Enter\+Solve, its, itime, acctim, t\+\_\+adapt\+\_\+threshold, after\+\_\+adapt, after\+\_\+adapt\+\_\+itime, P\+V\+F\+\_\+cfl)
\begin{DoxyCompactList}\small\item\em \+:--A Subroutine that returns a Logical, either to Enter the Force Balance Eqs or Not = given a requested\+\_\+cfl\+\_\+pressure it will skip the Force\+Balance\+Equation that many times = while if I have adaptive mesh it will solve the Force\+Balance\+Equation after each adapt\+\_\+time\+\_\+steps = The Subroutive also account for delaying adaptivity and swich between cfl\+\_\+pressure and after\+\_\+adapt= \end{DoxyCompactList}\item 
subroutine, public \mbox{\hyperlink{namespacecopy__outof__state_a52b4659aa8636bb70d12b05923bc58b8}{impose\+\_\+connected\+\_\+bcs}} (outfluxes, packed\+\_\+state, Mdims, acctime)
\begin{DoxyCompactList}\small\item\em \+: Using the outfluxes values, it imposes as BC the averaged value of another B\+C(from within the domain) It is a basic method to get this functionality but it will work in parallel. However, it does not guarantee mass conservation as it uses the value from the previous time-\/step although it can still be used for many cases such as A\+T\+ES, or ventilation. Overwrites the dirichlet BC values. Currently it uses the information from outfluxes so it is M\+A\+N\+D\+A\+T\+O\+RY to use and request outfluxes for those B\+Cs \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This module enables the multiphase prototype code to interact with state by copying everything required from state to I\+C\+F\+E\+R\+ST, adaptive time-\/stepping, outfluxes computation, tunneled B\+Cs and Darcy velocity. 

\doxysubsection{Function/\+Subroutine Documentation}
\mbox{\Hypertarget{namespacecopy__outof__state_a577c504f5230ff200ee711334eebe54a}\label{namespacecopy__outof__state_a577c504f5230ff200ee711334eebe54a}} 
\index{copy\_outof\_state@{copy\_outof\_state}!adaptive\_nonlinear@{adaptive\_nonlinear}}
\index{adaptive\_nonlinear@{adaptive\_nonlinear}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{adaptive\_nonlinear()}{adaptive\_nonlinear()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::adaptive\+\_\+nonlinear (\begin{DoxyParamCaption}\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{type(state\+\_\+type), intent(inout)}]{packed\+\_\+state,  }\item[{real, dimension(\+:,\+:,\+:), intent(inout), allocatable}]{reference\+\_\+field,  }\item[{integer, intent(inout)}]{its,  }\item[{logical, intent(inout)}]{Repeat\+\_\+time\+\_\+step,  }\item[{logical, intent(inout)}]{Exit\+Non\+Linear\+Loop,  }\item[{logical, intent(in)}]{non\+Linear\+Adapt\+Ts,  }\item[{real, intent(in)}]{old\+\_\+acctim,  }\item[{integer, intent(in)}]{order,  }\item[{real, dimension(\+:,\+:), optional}]{calculate\+\_\+mass\+\_\+delta,  }\item[{logical, intent(in), optional}]{adapt\+\_\+mesh\+\_\+in\+\_\+\+F\+PI,  }\item[{real, intent(in), optional}]{Accum\+\_\+\+Courant,  }\item[{real, intent(in), optional}]{Courant\+\_\+tol,  }\item[{real, intent(in), optional}]{Current\+\_\+\+Courant,  }\item[{logical, intent(in), optional}]{first\+\_\+time\+\_\+step }\end{DoxyParamCaption})}



\+: This subroutine either store variables before the nonlinear timeloop starts, or checks how the nonlinear iterations are going and depending on that increase the timestep or decreases the timestep and repeats that timestep 

\begin{DoxyAuthor}{Author}
\+: Pablo Salinas 
\end{DoxyAuthor}

\begin{DoxyParams}{Parameters}
{\em Mdims} & Data type storing all the dimensions describing the mesh, fields, nodes, etc \\
\hline
{\em packed\+\_\+state} & Linked list with the fields for I\+C\+F\+E\+R\+ST \\
\hline
{\em reference\+\_\+field} & Field stored at the beginning of the non-\/linear loop to check convergence \\
\hline
{\em old\+\_\+acctim} & Previous actual time \\
\hline
{\em Repeat\+\_\+time\+\_\+step,Exit\+Non\+Linear\+Loop} & \\
\hline
{\em its} & Non-\/linear time iteration W\+A\+R\+N\+I\+NG\+: not to be modified unless V\+E\+RY sure \\
\hline
{\em non\+Linear\+Adapt\+Ts} & Flag controlling if we have adaptive time-\/step or not \\
\hline
{\em order} & Flag controlling what are we doing. 1)Store or get from backup; 2)Calculate and store reference\+\_\+field; \\
\hline
{\em adapt\+\_\+mesh\+\_\+in\+\_\+\+F\+PI,first\+\_\+time\+\_\+step} & \\
\hline
{\em Accum\+\_\+\+Courant,Courant\+\_\+tol,Current\+\_\+\+Courant} & \\
\hline
{\em calculate\+\_\+mass\+\_\+delta} & 1st item holds the mass at previous Linear time step, 2nd item is the delta between mass at the current F\+PI and 1st item \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a577c504f5230ff200ee711334eebe54a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a577c504f5230ff200ee711334eebe54a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a6bc946977b60a10ae77f86013eb499e7}\label{namespacecopy__outof__state_a6bc946977b60a10ae77f86013eb499e7}} 
\index{copy\_outof\_state@{copy\_outof\_state}!as\_packed\_vector@{as\_packed\_vector}}
\index{as\_packed\_vector@{as\_packed\_vector}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{as\_packed\_vector()}{as\_packed\_vector()}}
{\footnotesize\ttfamily type(vector\+\_\+field) function, public copy\+\_\+outof\+\_\+state\+::as\+\_\+packed\+\_\+vector (\begin{DoxyParamCaption}\item[{type(tensor\+\_\+field), intent(inout)}]{tfield }\end{DoxyParamCaption})}



\+: This function points a tensor field as a vector field type This is necessary when solving for tensor fields that are actually multiphase vector fields. 

\mbox{\Hypertarget{namespacecopy__outof__state_abfa3817b7e0890e5009c4905376a5688}\label{namespacecopy__outof__state_abfa3817b7e0890e5009c4905376a5688}} 
\index{copy\_outof\_state@{copy\_outof\_state}!as\_vector@{as\_vector}}
\index{as\_vector@{as\_vector}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{as\_vector()}{as\_vector()}}
{\footnotesize\ttfamily type(vector\+\_\+field) function, public copy\+\_\+outof\+\_\+state\+::as\+\_\+vector (\begin{DoxyParamCaption}\item[{type(tensor\+\_\+field), intent(inout)}]{tfield,  }\item[{integer, intent(in)}]{dim,  }\item[{integer, intent(in), optional}]{slice }\end{DoxyParamCaption})}



\+: This function points a tensor field as a vector field type This is necessary when solving for tensor fields that are actually multiphase vector fields. 

\mbox{\Hypertarget{namespacecopy__outof__state_a1394fdd5e9adcc149eb319739c07f854}\label{namespacecopy__outof__state_a1394fdd5e9adcc149eb319739c07f854}} 
\index{copy\_outof\_state@{copy\_outof\_state}!calculate\_internal\_volume@{calculate\_internal\_volume}}
\index{calculate\_internal\_volume@{calculate\_internal\_volume}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{calculate\_internal\_volume()}{calculate\_internal\_volume()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::calculate\+\_\+internal\+\_\+volume (\begin{DoxyParamCaption}\item[{type(state\+\_\+type), intent(inout)}]{packed\+\_\+state,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{real, dimension( \+: ), intent(in)}]{mass\+\_\+ele,  }\item[{real, dimension(\+:), intent(inout)}]{calculate\+\_\+mass,  }\item[{integer, dimension(\+:), intent(in)}]{cv\+\_\+ndgln,  }\item[{real, dimension( \+:, \+: ), intent(in)}]{D\+E\+N\+\_\+\+A\+LL,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1pipe__coords}{pipe\+\_\+coords}}), dimension(\+:), intent(in), optional}]{eles\+\_\+with\+\_\+pipe }\end{DoxyParamCaption})}



\+: Subroutine to calculate the integrated mass inside the domain 


\begin{DoxyParams}{Parameters}
{\em packed\+\_\+state} & \\
\hline
{\em Mdims} & \\
\hline
{\em mass\+\_\+ele} & volume of the element, split into cv\+\_\+nloc equally sized pieces (barycenter) \\
\hline
{\em cv\+\_\+ndgln} & local to global of the CV mesh only \\
\hline
{\em D\+E\+N\+\_\+\+A\+LL} & density of the field \\
\hline
{\em eles\+\_\+with\+\_\+pipe} & list of element that contain a well/pipe \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em calculate\+\_\+mass} & Output field containing all the mass within the domain \\
\hline
\end{DoxyRetVals}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a1394fdd5e9adcc149eb319739c07f854_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_abba0b467480d0b56c11d18f70e8c680e}\label{namespacecopy__outof__state_abba0b467480d0b56c11d18f70e8c680e}} 
\index{copy\_outof\_state@{copy\_outof\_state}!compute\_node\_global\_numbers@{compute\_node\_global\_numbers}}
\index{compute\_node\_global\_numbers@{compute\_node\_global\_numbers}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{compute\_node\_global\_numbers()}{compute\_node\_global\_numbers()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::compute\+\_\+node\+\_\+global\+\_\+numbers (\begin{DoxyParamCaption}\item[{type( state\+\_\+type ), dimension( \+: ), intent(in)}]{state,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__ndgln}{multi\+\_\+ndgln}}), intent(inout)}]{ndgln }\end{DoxyParamCaption})}



This subroutine calculates the global node numbers requested to operates in I\+C\+F\+E\+R\+ST. 

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_abba0b467480d0b56c11d18f70e8c680e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_abba0b467480d0b56c11d18f70e8c680e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_adbfe914b0d919d92535a188ab7c0e384}\label{namespacecopy__outof__state_adbfe914b0d919d92535a188ab7c0e384}} 
\index{copy\_outof\_state@{copy\_outof\_state}!dump\_outflux@{dump\_outflux}}
\index{dump\_outflux@{dump\_outflux}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{dump\_outflux()}{dump\_outflux()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::dump\+\_\+outflux (\begin{DoxyParamCaption}\item[{real, intent(in)}]{current\+\_\+time,  }\item[{integer, intent(in)}]{itime,  }\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1multi__outfluxes}{multi\+\_\+outfluxes}}), intent(inout)}]{outfluxes }\end{DoxyParamCaption})}



\+: Subroutine that dumps the total flux at a given timestep across all specified boundaries to a file called \textquotesingle{}simulation\+\_\+name\+\_\+outfluxes.\+csv\textquotesingle{}. In addition, the time integrated flux up to the current timestep is also outputted to this file. Integration boundaries are specified in diamond via surface\+\_\+ids. (In diamond this option can be found under \char`\"{}/io/dump\+\_\+boundaryflux/surface\+\_\+ids\char`\"{} and the user should specify an integer array containing the I\+Ds of every boundary they wish to integrate over). 


\begin{DoxyParams}{Parameters}
{\em current\+\_\+time} & actual time \\
\hline
{\em itime} & time-\/level in integer format \\
\hline
{\em outfluxes} & multi\+\_\+outfluxes field containing the data required to create the output csv file \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_adbfe914b0d919d92535a188ab7c0e384_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a6c5000c06758c4e42744252542c849cb}\label{namespacecopy__outof__state_a6c5000c06758c4e42744252542c849cb}} 
\index{copy\_outof\_state@{copy\_outof\_state}!enterforcebalanceequation@{enterforcebalanceequation}}
\index{enterforcebalanceequation@{enterforcebalanceequation}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{enterforcebalanceequation()}{enterforcebalanceequation()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::enterforcebalanceequation (\begin{DoxyParamCaption}\item[{logical, intent(inout)}]{Enter\+Solve,  }\item[{integer, intent(in)}]{its,  }\item[{integer, intent(in)}]{itime,  }\item[{real, intent(in)}]{acctim,  }\item[{real, intent(in)}]{t\+\_\+adapt\+\_\+threshold,  }\item[{logical, intent(in)}]{after\+\_\+adapt,  }\item[{logical, intent(inout)}]{after\+\_\+adapt\+\_\+itime,  }\item[{real, intent(in)}]{P\+V\+F\+\_\+cfl }\end{DoxyParamCaption})}



\+:--A Subroutine that returns a Logical, either to Enter the Force Balance Eqs or Not = given a requested\+\_\+cfl\+\_\+pressure it will skip the Force\+Balance\+Equation that many times = while if I have adaptive mesh it will solve the Force\+Balance\+Equation after each adapt\+\_\+time\+\_\+steps = The Subroutive also account for delaying adaptivity and swich between cfl\+\_\+pressure and after\+\_\+adapt= 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a6c5000c06758c4e42744252542c849cb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a60ec84623fb582762f2139794470ba13}\label{namespacecopy__outof__state_a60ec84623fb582762f2139794470ba13}} 
\index{copy\_outof\_state@{copy\_outof\_state}!finalise\_multistate@{finalise\_multistate}}
\index{finalise\_multistate@{finalise\_multistate}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{finalise\_multistate()}{finalise\_multistate()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::finalise\+\_\+multistate (\begin{DoxyParamCaption}\item[{type(state\+\_\+type)}]{packed\+\_\+state,  }\item[{type(state\+\_\+type), dimension(\+:), pointer}]{multiphase\+\_\+state,  }\item[{type(state\+\_\+type), dimension(\+:), pointer}]{multicomponent\+\_\+state }\end{DoxyParamCaption})}



\+: Destrys packed\+\_\+state and the passed down states 

\mbox{\Hypertarget{namespacecopy__outof__state_a7d6957a54cc1cc0a38a4a7a90bca1f89}\label{namespacecopy__outof__state_a7d6957a54cc1cc0a38a4a7a90bca1f89}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_convergence\_functional@{get\_convergence\_functional}}
\index{get\_convergence\_functional@{get\_convergence\_functional}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_convergence\_functional()}{get\_convergence\_functional()}}
{\footnotesize\ttfamily real function, public copy\+\_\+outof\+\_\+state\+::get\+\_\+convergence\+\_\+functional (\begin{DoxyParamCaption}\item[{real, dimension(\+:,\+:), intent(in)}]{phasevolumefraction,  }\item[{real, dimension(\+:,\+:), intent(in)}]{reference\+\_\+sat,  }\item[{real, intent(in)}]{dumping,  }\item[{integer, intent(in), optional}]{its }\end{DoxyParamCaption})}



\+: We create a potential to optimize F = sum (f$\ast$$\ast$2), so the solution is when this potential reaches a minimum. Typically the value to consider convergence is the sqrt(epsilon of the machine), i.\+e. 10$^\wedge$-\/8 f = (New\+Sat-\/\+Old\+Sat)/\+Number of nodes; this is the typical approach for algebraic non linear systems 

The convergence is independent of the dumping parameter and measures how the previous iteration (i.\+e. using the previous dumping parameter) performed Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a7d6957a54cc1cc0a38a4a7a90bca1f89_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a2a2f72be9cad756d2151473988566c8d}\label{namespacecopy__outof__state_a2a2f72be9cad756d2151473988566c8d}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_darcyvelocity@{get\_darcyvelocity}}
\index{get\_darcyvelocity@{get\_darcyvelocity}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_darcyvelocity()}{get\_darcyvelocity()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::get\+\_\+darcyvelocity (\begin{DoxyParamCaption}\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__ndgln}{multi\+\_\+ndgln}}), intent(in)}]{ndgln,  }\item[{type( state\+\_\+type ), dimension( \+: ), intent(inout)}]{state,  }\item[{type(state\+\_\+type), intent(in)}]{packed\+\_\+state,  }\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1porous__adv__coefs}{porous\+\_\+adv\+\_\+coefs}}), intent(inout)}]{upwnd }\end{DoxyParamCaption})}



\+: This subroutine calculates the actual Darcy velocity, but with P0\+DG precision only! 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a2a2f72be9cad756d2151473988566c8d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_add060a0a644c1d8db9c718a82d89c852}\label{namespacecopy__outof__state_add060a0a644c1d8db9c718a82d89c852}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_discretisation\_options@{get\_discretisation\_options}}
\index{get\_discretisation\_options@{get\_discretisation\_options}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_discretisation\_options()}{get\_discretisation\_options()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::get\+\_\+discretisation\+\_\+options (\begin{DoxyParamCaption}\item[{type( state\+\_\+type ), dimension( \+: ), intent(in)}]{state,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1multi__discretization__opts}{multi\+\_\+discretization\+\_\+opts}})}]{Mdisopt }\end{DoxyParamCaption})}



\+: This subroutine extract all discretisation options from the schema D\+I\+S\+O\+PT Options\+: =0 1st order in space Theta=specified U\+N\+I\+V\+E\+R\+S\+AL =1 1st order in space Theta=non-\/linear U\+N\+I\+V\+E\+R\+S\+AL =2 Trapezoidal rule in space Theta=specified U\+N\+I\+V\+E\+R\+S\+AL =2 if isotropic limiter then F\+E\+M-\/quadratic \& stratification adjust. Theta=non-\/linear =3 Trapezoidal rule in space Theta=non-\/linear U\+N\+I\+V\+E\+R\+S\+AL =4 Finite elements in space Theta=specified U\+N\+I\+V\+E\+R\+S\+AL =5 Finite elements in space Theta=non-\/linear U\+N\+I\+V\+E\+R\+S\+AL =6 Finite elements in space Theta=specified N\+O\+NE =7 Finite elements in space Theta=non-\/linear N\+O\+NE =8 Finite elements in space Theta=specified D\+O\+W\+N\+W\+I\+N\+D+\+I\+N\+T\+E\+R\+F\+A\+CE T\+R\+A\+C\+K\+I\+NG =9 Finite elements in space Theta=non-\/linear D\+O\+W\+N\+W\+I\+N\+D+\+I\+N\+T\+E\+R\+F\+A\+CE T\+R\+A\+C\+K\+I\+NG 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_add060a0a644c1d8db9c718a82d89c852_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a25e9236f15044530da105400e0e3e3f4}\label{namespacecopy__outof__state_a25e9236f15044530da105400e0e3e3f4}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_ele\_type@{get\_ele\_type}}
\index{get\_ele\_type@{get\_ele\_type}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_ele\_type()}{get\_ele\_type()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::get\+\_\+ele\+\_\+type (\begin{DoxyParamCaption}\item[{integer, intent(in)}]{x\+\_\+nloc,  }\item[{integer, intent(inout)}]{cv\+\_\+ele\+\_\+type,  }\item[{integer, intent(inout)}]{p\+\_\+ele\+\_\+type,  }\item[{integer, intent(inout)}]{u\+\_\+ele\+\_\+type,  }\item[{integer, intent(inout), optional}]{mat\+\_\+ele\+\_\+type,  }\item[{integer, intent(inout), optional}]{u\+\_\+sele\+\_\+type,  }\item[{integer, intent(inout), optional}]{cv\+\_\+sele\+\_\+type }\end{DoxyParamCaption})}



\+: Obtain the type of element u\+\_\+ele\+\_\+type = cv\+\_\+ele\+\_\+type = p\+\_\+ele\+\_\+type will flag the dimension and type of element\+: = 1 or 2\+: 1D (linear and quadratic, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 3 or 4\+: triangle (linear or quadratic, respectively) = 5 or 6\+: quadrilateral (bi-\/linear or tri-\/linear, respectively)-\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 7 or 8\+: tetrahedron (linear or quadratic, respectively) = 9 or 10\+: hexahedron (bi-\/linear or tri-\/linear, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a25e9236f15044530da105400e0e3e3f4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_aed2618045311aa635b4b0bd2599ab609}\label{namespacecopy__outof__state_aed2618045311aa635b4b0bd2599ab609}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_ele\_type\_new@{get\_ele\_type\_new}}
\index{get\_ele\_type\_new@{get\_ele\_type\_new}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_ele\_type\_new()}{get\_ele\_type\_new()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::get\+\_\+ele\+\_\+type\+\_\+new (\begin{DoxyParamCaption}\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1multi__discretization__opts}{multi\+\_\+discretization\+\_\+opts}})}]{Mdisopt }\end{DoxyParamCaption})}



\+: Obtains the element type Mdisoptu\+\_\+ele\+\_\+type = Mdisoptcv\+\_\+ele\+\_\+type = Mdisoptp\+\_\+ele\+\_\+type will flag the dimension and type of element\+: = 1 or 2\+: 1D (linear and quadratic, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 3 or 4\+: triangle (linear or quadratic, respectively) = 5 or 6\+: quadrilateral (bi-\/linear or tri-\/linear, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ = 7 or 8\+: tetrahedron (linear or quadratic, respectively) = 9 or 10\+: hexahedron (bi-\/linear or tri-\/linear, respectively) -\/N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D-\/ 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_aed2618045311aa635b4b0bd2599ab609_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_ab5c876f8f241119d1dedc0bffa8fa159}\label{namespacecopy__outof__state_ab5c876f8f241119d1dedc0bffa8fa159}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_primary\_scalars\_new@{get\_primary\_scalars\_new}}
\index{get\_primary\_scalars\_new@{get\_primary\_scalars\_new}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_primary\_scalars\_new()}{get\_primary\_scalars\_new()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::get\+\_\+primary\+\_\+scalars\+\_\+new (\begin{DoxyParamCaption}\item[{type( state\+\_\+type ), dimension( \+: ), intent(in)}]{state,  }\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}})}]{Mdims }\end{DoxyParamCaption})}



This subroutine extracts all primary variables associated with the mesh from state, and associated them with the variables used in the Multi\+Fluids model. 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_ab5c876f8f241119d1dedc0bffa8fa159_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a0520a99d915a669f52eadab9a438194b}\label{namespacecopy__outof__state_a0520a99d915a669f52eadab9a438194b}} 
\index{copy\_outof\_state@{copy\_outof\_state}!get\_var\_from\_packed\_state@{get\_var\_from\_packed\_state}}
\index{get\_var\_from\_packed\_state@{get\_var\_from\_packed\_state}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{get\_var\_from\_packed\_state()}{get\_var\_from\_packed\_state()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::get\+\_\+var\+\_\+from\+\_\+packed\+\_\+state (\begin{DoxyParamCaption}\item[{type(state\+\_\+type), intent(inout)}]{packed\+\_\+state,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{F\+E\+Density,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+F\+E\+Density,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Density,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Density,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+Density,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+Density,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Phase\+Volume\+Fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+Phase\+Volume\+Fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+Phase\+Volume\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Velocity,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+Velocity,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Iterated\+Velocity,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{F\+E\+Phase\+Volume\+Fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+F\+E\+Phase\+Volume\+Fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Phase\+Volume\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Nonlinear\+Velocity,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+Nonlinear\+Velocity,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Iterated\+Nonlinear\+Velocity,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Component\+Density,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+Component\+Density,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Iterated\+Component\+Density,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Component\+Mass\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+Component\+Mass\+Fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Temperature,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+Temperature,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+Temperature,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{F\+E\+Temperature,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+F\+E\+Temperature,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Temperature,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Iterated\+Component\+Mass\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{F\+E\+Component\+Density,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+F\+E\+Component\+Density,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Component\+Density,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{F\+E\+Component\+Mass\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+F\+E\+Component\+Mass\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Component\+Mass\+Fraction,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Pressure,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{F\+E\+Pressure,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+F\+E\+Pressure,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{C\+V\+Pressure,  }\item[{real, dimension(\+:,\+:,\+:), optional, pointer}]{Old\+C\+V\+Pressure,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{C\+V\+\_\+\+Immobile\+\_\+\+Fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Coordinate,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Velocity\+Coordinate,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Pressure\+Coordinate,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Material\+Coordinate,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Cap\+Pressure,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Immobile\+\_\+fraction,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{End\+Point\+Relperm,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Relperm\+Exponent,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Cap\+\_\+entry\+\_\+pressure,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Cap\+\_\+exponent,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Imbibition\+\_\+term,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Concentration,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+Concentration,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+Concentration,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{F\+E\+Concentration,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+F\+E\+Concentration,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Concentration,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Enthalpy,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+Enthalpy,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+Enthalpy,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{F\+E\+Enthalpy,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Old\+F\+E\+Enthalpy,  }\item[{real, dimension(\+:,\+:), optional, pointer}]{Iterated\+F\+E\+Enthalpy }\end{DoxyParamCaption})}



@\+D\+E\+P\+R\+E\+C\+A\+T\+ED\+: Gets memory from packed state This subroutine returns a pointer to the desired values of a variable stored in packed state All the input variables (but packed\+\_\+stated) are pointers following the structure of the $\ast$\+\_\+\+A\+LL variables and also all of them are optional, hence you can obtaine whichever you want 

\doxysubparagraph*{\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\+E\+X\+A\+M\+P\+LE OF U\+S\+A\+GE OF T\+H\+IS S\+U\+B\+R\+O\+U\+T\+I\+NE\+:}

If we want to get the velocity and the phasevolumefraction one should proceed this way\+: Define variables\+: real, dimension(\+:,\+:,\+:), pointer \+:: Velocity\+\_\+pointer real, dimension(\+:,\+:), pointer \+:: Phase\+Volume\+Fraction\+\_\+pointer Assign the pointers call get\+\_\+var\+\_\+from\+\_\+packed\+\_\+state(packed\+\_\+state, Velocity = Velocity\+\_\+pointer, Phase\+Volume\+Fraction = Phase\+Volume\+Fraction\+\_\+pointer)

In this way we only have to introduce the name of the variables we want to get from packed\+\_\+state Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a0520a99d915a669f52eadab9a438194b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_ac1305d6f3dc1c1ec92a4135ea55947b9}\label{namespacecopy__outof__state_ac1305d6f3dc1c1ec92a4135ea55947b9}} 
\index{copy\_outof\_state@{copy\_outof\_state}!getfemname@{getfemname}}
\index{getfemname@{getfemname}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{getfemname()}{getfemname()}}
{\footnotesize\ttfamily character (len=field\+\_\+name\+\_\+len) function, public copy\+\_\+outof\+\_\+state\+::getfemname (\begin{DoxyParamCaption}\item[{type(tensor\+\_\+field), intent(in)}]{tfield }\end{DoxyParamCaption})}



\+: For a given field, retrieve the associated finite element field name 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_ac1305d6f3dc1c1ec92a4135ea55947b9_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_abc850cced2fb9b525f015e758e4b45da}\label{namespacecopy__outof__state_abc850cced2fb9b525f015e758e4b45da}} 
\index{copy\_outof\_state@{copy\_outof\_state}!getoldname@{getoldname}}
\index{getoldname@{getoldname}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{getoldname()}{getoldname()}}
{\footnotesize\ttfamily character (len=field\+\_\+name\+\_\+len) function, public copy\+\_\+outof\+\_\+state\+::getoldname (\begin{DoxyParamCaption}\item[{type(tensor\+\_\+field), intent(in)}]{tfield }\end{DoxyParamCaption})}



\+: For a given field, retrieve the associated old field name 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_abc850cced2fb9b525f015e758e4b45da_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_acea2acdccf9091776be013ade24bcd97}\label{namespacecopy__outof__state_acea2acdccf9091776be013ade24bcd97}} 
\index{copy\_outof\_state@{copy\_outof\_state}!have\_option\_for\_any\_phase@{have\_option\_for\_any\_phase}}
\index{have\_option\_for\_any\_phase@{have\_option\_for\_any\_phase}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{have\_option\_for\_any\_phase()}{have\_option\_for\_any\_phase()}}
{\footnotesize\ttfamily logical function, public copy\+\_\+outof\+\_\+state\+::have\+\_\+option\+\_\+for\+\_\+any\+\_\+phase (\begin{DoxyParamCaption}\item[{character (len=$\ast$), intent(in)}]{path,  }\item[{integer, intent(in)}]{nphase }\end{DoxyParamCaption})}



\+: Subroutine to check whether an option is true for any phase in diamond, if any is true it returns true. The path must be the part of the path inside the phase, i.\+e. /multiphase\+\_\+properties/capillary\+\_\+pressure 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_acea2acdccf9091776be013ade24bcd97_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a52b4659aa8636bb70d12b05923bc58b8}\label{namespacecopy__outof__state_a52b4659aa8636bb70d12b05923bc58b8}} 
\index{copy\_outof\_state@{copy\_outof\_state}!impose\_connected\_bcs@{impose\_connected\_bcs}}
\index{impose\_connected\_bcs@{impose\_connected\_bcs}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{impose\_connected\_bcs()}{impose\_connected\_bcs()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::impose\+\_\+connected\+\_\+bcs (\begin{DoxyParamCaption}\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1multi__outfluxes}{multi\+\_\+outfluxes}}), intent(inout)}]{outfluxes,  }\item[{type(state\+\_\+type), intent(in)}]{packed\+\_\+state,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{real, intent(in)}]{acctime }\end{DoxyParamCaption})}



\+: Using the outfluxes values, it imposes as BC the averaged value of another B\+C(from within the domain) It is a basic method to get this functionality but it will work in parallel. However, it does not guarantee mass conservation as it uses the value from the previous time-\/step although it can still be used for many cases such as A\+T\+ES, or ventilation. Overwrites the dirichlet BC values. Currently it uses the information from outfluxes so it is M\+A\+N\+D\+A\+T\+O\+RY to use and request outfluxes for those B\+Cs 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a52b4659aa8636bb70d12b05923bc58b8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_ad775c010bade229fba0416002e6928a6}\label{namespacecopy__outof__state_ad775c010bade229fba0416002e6928a6}} 
\index{copy\_outof\_state@{copy\_outof\_state}!inf\_norm\_scalar\_normalised@{inf\_norm\_scalar\_normalised}}
\index{inf\_norm\_scalar\_normalised@{inf\_norm\_scalar\_normalised}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{inf\_norm\_scalar\_normalised()}{inf\_norm\_scalar\_normalised()}}
{\footnotesize\ttfamily real function, public copy\+\_\+outof\+\_\+state\+::inf\+\_\+norm\+\_\+scalar\+\_\+normalised (\begin{DoxyParamCaption}\item[{real, dimension(\+:,\+:), intent(in)}]{tracer,  }\item[{real, dimension(\+:,\+:), intent(in)}]{reference\+\_\+tracer,  }\item[{real, intent(in)}]{dumping,  }\item[{real, dimension(2), intent(in)}]{totally\+\_\+min\+\_\+max }\end{DoxyParamCaption})}



Calculate the inf norm of the normalised field, so the field goes from 0 to 1 It requires as inputs the tracer to be used and the reference tracer to normallise, the dumping to be set to 1.\+0 and totally\+\_\+min\+\_\+max which includes the min max values of the field across all processors also for normalisation. 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_ad775c010bade229fba0416002e6928a6_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_ab7c981b328d9950b1c375aaacaa3cda0}\label{namespacecopy__outof__state_ab7c981b328d9950b1c375aaacaa3cda0}} 
\index{copy\_outof\_state@{copy\_outof\_state}!is\_constant@{is\_constant}}
\index{is\_constant@{is\_constant}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{is\_constant()}{is\_constant()}}
{\footnotesize\ttfamily logical function, public copy\+\_\+outof\+\_\+state\+::is\+\_\+constant (\begin{DoxyParamCaption}\item[{type(tensor\+\_\+field), intent(in)}]{tfield }\end{DoxyParamCaption})}



\+: Checks whether a field is constant or not 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_ab7c981b328d9950b1c375aaacaa3cda0_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_afca89971343f6586b89f1cddda00b2c8}\label{namespacecopy__outof__state_afca89971343f6586b89f1cddda00b2c8}} 
\index{copy\_outof\_state@{copy\_outof\_state}!pack\_multistate@{pack\_multistate}}
\index{pack\_multistate@{pack\_multistate}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{pack\_multistate()}{pack\_multistate()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::pack\+\_\+multistate (\begin{DoxyParamCaption}\item[{integer, intent(in)}]{npres,  }\item[{type(state\+\_\+type), dimension(\+:), intent(inout)}]{state,  }\item[{type(state\+\_\+type), intent(inout)}]{packed\+\_\+state,  }\item[{type(state\+\_\+type), dimension(\+:), intent(inout), pointer}]{multiphase\+\_\+state,  }\item[{type(state\+\_\+type), dimension(\+:), intent(inout), pointer}]{multicomponent\+\_\+state,  }\item[{type(state\+\_\+type), dimension(\+:,\+:), optional, pointer}]{pmulti\+\_\+state }\end{DoxyParamCaption})}



\+: This subroutine creates packed\+\_\+state from state(\+:) and links the appropiate memory so it is acessible from both states. This subroutine also introduces fields not used by fludity but required by I\+C-\/\+F\+E\+R\+ST 

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_afca89971343f6586b89f1cddda00b2c8_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_afca89971343f6586b89f1cddda00b2c8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_adba75f9a3f64d519ecf58b2b9159d629}\label{namespacecopy__outof__state_adba75f9a3f64d519ecf58b2b9159d629}} 
\index{copy\_outof\_state@{copy\_outof\_state}!prepare\_absorptions@{prepare\_absorptions}}
\index{prepare\_absorptions@{prepare\_absorptions}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{prepare\_absorptions()}{prepare\_absorptions()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::prepare\+\_\+absorptions (\begin{DoxyParamCaption}\item[{type(state\+\_\+type), dimension(\+:), intent(inout)}]{state,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__dimensions}{multi\+\_\+dimensions}}), intent(in)}]{Mdims,  }\item[{type(\mbox{\hyperlink{structmulti__data__types_1_1multi__absorption}{multi\+\_\+absorption}}), intent(inout)}]{multi\+\_\+absorp }\end{DoxyParamCaption})}



\+: Prepares the memory to compute absorption fields 

Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_adba75f9a3f64d519ecf58b2b9159d629_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_adba75f9a3f64d519ecf58b2b9159d629_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a5fa62e07eab3607bcf414b67abe1148a}\label{namespacecopy__outof__state_a5fa62e07eab3607bcf414b67abe1148a}} 
\index{copy\_outof\_state@{copy\_outof\_state}!printcsrmatrix@{printcsrmatrix}}
\index{printcsrmatrix@{printcsrmatrix}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{printcsrmatrix()}{printcsrmatrix()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::printcsrmatrix (\begin{DoxyParamCaption}\item[{real, dimension(\+:,\+:,\+:), intent(in)}]{Matrix,  }\item[{integer, dimension(\+:), intent(in)}]{find,  }\item[{integer, dimension(\+:), intent(in)}]{col,  }\item[{logical, intent(in), optional}]{dim\+\_\+same\+\_\+row }\end{DoxyParamCaption})}



\+: Subroutine to print C\+SR matrix by (row, column) Dimensions and phases are printed in different rows So for example Matrix(2,2,10) with two rows would be presented as a matrix ( 8 x 10) 

\mbox{\Hypertarget{namespacecopy__outof__state_ab4280b302a2f45375be2df118ed6d100}\label{namespacecopy__outof__state_ab4280b302a2f45375be2df118ed6d100}} 
\index{copy\_outof\_state@{copy\_outof\_state}!update\_boundary\_conditions@{update\_boundary\_conditions}}
\index{update\_boundary\_conditions@{update\_boundary\_conditions}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{update\_boundary\_conditions()}{update\_boundary\_conditions()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::update\+\_\+boundary\+\_\+conditions (\begin{DoxyParamCaption}\item[{type( state\+\_\+type ), dimension( \+: ), intent(in)}]{state,  }\item[{integer, intent(in)}]{stotel,  }\item[{integer, intent(in)}]{cv\+\_\+snloc,  }\item[{integer, intent(in)}]{nphase,  }\item[{real, dimension( 1, nphase, stotel $\ast$ cv\+\_\+snloc ), intent(inout)}]{suf\+\_\+t\+\_\+bc,  }\item[{real, dimension( 1, nphase, stotel $\ast$ cv\+\_\+snloc ), intent(inout)}]{suf\+\_\+t\+\_\+bc\+\_\+rob1,  }\item[{real, dimension( 1, nphase, stotel $\ast$ cv\+\_\+snloc ), intent(inout)}]{suf\+\_\+t\+\_\+bc\+\_\+rob2,  }\item[{type(tensor\+\_\+field), intent(inout), target}]{tracer }\end{DoxyParamCaption})}



\+: Sets the boundary condition, if the time has advanced and the B\+Cs changed, here they are set to the new time-\/level 

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_ab4280b302a2f45375be2df118ed6d100_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacecopy__outof__state_a3e466dfb76c8c3e30de12d2f7d36d3bb}\label{namespacecopy__outof__state_a3e466dfb76c8c3e30de12d2f7d36d3bb}} 
\index{copy\_outof\_state@{copy\_outof\_state}!update\_outfluxes@{update\_outfluxes}}
\index{update\_outfluxes@{update\_outfluxes}!copy\_outof\_state@{copy\_outof\_state}}
\doxysubsubsection{\texorpdfstring{update\_outfluxes()}{update\_outfluxes()}}
{\footnotesize\ttfamily subroutine, public copy\+\_\+outof\+\_\+state\+::update\+\_\+outfluxes (\begin{DoxyParamCaption}\item[{real, dimension(\+:, \+:,0\+:), intent(inout)}]{bcs\+\_\+outfluxes,  }\item[{type (\mbox{\hyperlink{structmulti__data__types_1_1multi__outfluxes}{multi\+\_\+outfluxes}}), intent(inout)}]{outfluxes,  }\item[{integer, intent(in)}]{sele,  }\item[{integer, intent(in)}]{cv\+\_\+nodi,  }\item[{real, intent(in)}]{suf\+\_\+area,  }\item[{real, dimension(\+:), intent(in)}]{Vol\+\_\+flux,  }\item[{real, dimension(\+:), intent(in)}]{Mass\+\_\+flux,  }\item[{type (tensor\+\_\+field), intent(in), pointer}]{tracer,  }\item[{type (tensor\+\_\+field\+\_\+pointer), dimension(\+:)}]{outfluxes\+\_\+fields,  }\item[{integer, intent(in)}]{start\+\_\+phase,  }\item[{integer, intent(in)}]{end\+\_\+phase }\end{DoxyParamCaption})}



\+: Updates the outfluxes information based on N\+D\+O\+T\+Q\+N\+EW, shape functions and transported fields for a given GI point in a certain element This subroutine should only be called if S\+E\+LE is on the B\+O\+U\+N\+D\+A\+RY Example of Mass\+\_\+flux\+: ndotq(iphase) $\ast$ Sdev\+FunsD\+E\+T\+W\+EI(gi) $\ast$ L\+I\+M\+T(iphase) Example of Vol\+\_\+flux\+: ndotq(iphase) $\ast$ Sdev\+FunsD\+E\+T\+W\+EI(gi) $\ast$ L\+I\+M\+D\+T(iphase) 


\begin{DoxyParams}{Parameters}
{\em bcs\+\_\+outfluxes} & the total mass entering the domain is captured by \textquotesingle{}bcs\+\_\+outfluxes\textquotesingle{} \\
\hline
{\em outfluxes} & multi\+\_\+outfluxes field containing the data required to create the output csv file \\
\hline
{\em sele} & current surface element \\
\hline
{\em cv\+\_\+nodi} & current control volume \\
\hline
{\em suf\+\_\+area} & surface area \\
\hline
{\em Vol\+\_\+flux} & ndotq(iphase) $\ast$ Sdev\+FunsD\+E\+T\+W\+EI(gi) $\ast$ L\+I\+M\+T(iphase) \\
\hline
{\em Mass\+\_\+flux} & ndotq(iphase) $\ast$ Sdev\+FunsD\+E\+T\+W\+EI(gi) $\ast$ L\+I\+M\+D\+T(iphase) (includes tracer and density!) \\
\hline
{\em tracer} & field being transported/computed \\
\hline
{\em outfluxes\+\_\+fields} & to extract also from active/passive tracers \\
\hline
{\em start\+\_\+phase,end\+\_\+phase} & Initial and final phase to be considered here \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacecopy__outof__state_a3e466dfb76c8c3e30de12d2f7d36d3bb_icgraph}
\end{center}
\end{figure}
