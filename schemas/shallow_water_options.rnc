include "spud_base.rnc"

include "adaptivity_options.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "solvers.rnc"
include "stabilisation.rnc"
include "adjoint_options.rnc"
include "physical_parameters.rnc"
include "mesh_options.rnc"

start =
   (
      ## The root node of the options dictionary.
      element shallow_water_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Options dealing with the specification of geometry
         element geometry {
            ## Dimension of the problem.
            ## <b>This can only be set once</b>
            element dimension {
               element integer_value {
                  attribute rank {"0"},
                  ("3")
               }
            },
            ## The position mesh
            element mesh {
               attribute name { "CoordinateMesh" },
               mesh_info
            },
            ## The velocity mesh
            element mesh {
               attribute name { "VelocityMesh" },
               mesh_info
            },
            ## The pressure mesh
            element mesh {
               attribute name { "PressureMesh" },
               mesh_info
            },
            element mesh {
               attribute name { xsd:string },
               mesh_info,
               element exclude_from_mesh_adaptivity{empty}?
            }*,
            ## Quadrature
            element quadrature {
               ## Quadrature degree
               ## 
               ## note: this specifies the degree of quadrature,
               ## not the number of gauss points
               element degree {
                  integer
               },
               ## Surface quadrature degree
               ## 
               ## note: this specifies the degree of surface
               ## quadrature not the number of surface gauss points
               element surface_degree {
                  integer
               }?,
               ## Select which family of quadrature rules to use.
               ## The default is family_cools.
               ## family_wandzura allows for degree up to 30
               ## on triangular meshes.
               ## family_grundmann_moeller allows for degree up to
               ## 29 on simplicial meshes in arbitrary dimension.
               element quadrature_family {
                 ( "family_cools" | "family_grundmann_moeller" | "family_wandzura" ) 
               }?
            }
         },
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            },
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                (
                     element constant {
                     real
                   }|
                   ## Python function prescribing real input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )  
               }|                 
               ## Dump period, in timesteps.
               ## 
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                 (
                     element constant {
                     integer
                   }|
                   ## Python function prescribing integer input. Functions should be of the form:
                   ##
                   ##  def val(t):
                   ##     # Function code
                   ##     return # Return value
                   ##
                   ## 
                   element python {
                     python_code
                   }
                )   
               }
            ),
            # every CPUDUM seconds write results to disc.
            ## This is usually disabled.
            element cpu_dump_period {
               real
            }?,
            ## The period between dumps in walltime seconds. This is usually disabled.
            element wall_time_dump_period {
               real
            }?,
            (
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "VelocityMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "PressureMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "CoordinateMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { xsd:string }
               }
            )
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real,
               ## The following excerpt from the Udunits
               ## documentation explains the time unit encoding by
               ## example:
               ##
               ## The specification:
               ##
               ## seconds since 1992-10-8 15:15:42.5 -6:00
               ##
               ## indicates seconds since October 8th, 1992 at 3
               ## hours, 15 minutes and 42.5 seconds in the afternoon
               ## in the time zone which is six hours to the west of
               ## Coordinated Universal Time (i.e.  Mountain Daylight
               ## Time). The time zone specification can also be
               ## written without a colon using one or two-digits
               ## (indicating hours) or three or four digits
               ## (indicating hours and minutes).
               ##
               ## Time units are particularly required in situations
               ## where the problem (time-varying) boundary conditions
               ## and/ initial conditions are a function of time as
               ## defined by a calendar.  Examples include atmospheric
               ## forcing and climatology. The current time, specified
               ## above, is zero at the reference data/time.
               element time_units{attribute date { xsd:string }}?
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## How many nonlinear iterations in the timestepping loop
            element nonlinear_iterations {
               integer
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Timestep after which the simulation should end.
            element final_timestep {
               integer
            }?,
            ## Maximum CPU time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## Manual suggests 1.E+20
            element cpu_time_limit {
               real
            }?,
            ## Maximum wall time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## This is usually disabled.
            element wall_time_limit {
               real
            }?
         },
         ## The physical parameters
         element physical_parameters {
            gravity_options,
            element coriolis {
               python_code
            }?
         },
         ## The material or phase options
         element material_phase {
            attribute name { "Fluid" },
            (
               ## Velocity vector and momentum options
               element vector_field {
                  attribute rank { "1" },
                  attribute name { "Velocity" },
                  ## Field type
                  (
                     element prognostic {
                        element mesh {
                           attribute name { "VelocityMesh" }
                        },
                        prognostic_velocity_field
                     }|
                     element prescribed {
                        element mesh {
                           attribute name { "VelocityMesh" }
                        },
                        prescribed_vector_field
                     }|
                     element aliased {
                        attribute material_phase_name { xsd:string },
                        attribute field_name {"Velocity" }
                     }
                  )
               },
               ## Free surface elevation
               element scalar_field {
                  attribute rank { "0" },
                  attribute name { "LayerThickness" },
                  element prognostic {
                     pressure_mesh_choice,
                     prognostic_layerthickness_field
                  }
               }?,
               scalar_field_choice*,
               vector_field_choice*
            )
         },
        element mesh_adaptivity {
          (
             hr_adaptivity|
             prescribed_adaptivity
          )
        }?,
         ## Debugging options
         element debug {
            element check_inverse_coriolis_matrix {
               empty
            }?,
            element check_wave_matrix {
               empty
            }?,
            element check_solution {
               empty
            }?
         }?,
         adjoint_options?
      }
   )      

scalar_field_choice = 
   (
      # The first is a generic field, which may be used for any user-defined field
      # that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            element prognostic {
               velocity_mesh_choice,
               prognostic_scalar_field
            }
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  adjoint_storage
               }
            )
         }
      )
   )

# Choice of input method, e.g. for boundary conditions
input_choice_real =
   (
      input_choice_real_contents
   )

input_choice_real_plus_boundary_forcing =
   (
      input_choice_real_contents|
        element from_file {
           element tidal {
                attribute file_name { string },
                attribute variable_name_amplitude { string },
                attribute variable_name_phase { string },
                ## See E.W. Schwiderski - Rev. Geophys. Space
                ## Phys. Vol. 18 No. 1 pp. 243--268, 1980
                ## for details of these constituent.
                attribute name {"M2"|"S2"|"N2"|"K2"|"K1"|"O1"|"P1"|"Q1"|"Mf"|"Mm"|"Ssa"}
           }+
         }
   )

input_choice_real_plus_file =
   (
      input_choice_real_contents|
      ## Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      ##
      ## THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase
      element from_file {
         attribute file_name { xsd:string },
         vtu_input_format,
         comment
      }
   )

input_choice_real_contents =
   ## Constant value
   element constant {
      real
   }|
   ## Python function prescribing real input. Functions should be of the form:
   ##
   ##  def val(X, t):
   ##     # Function code
   ##     return # Return value
   ##
   ## where X is a tuple of length geometry dimension.
   element python {
      python_code
   }

# Choice of input method, e.g. for boundary conditions
input_choice_real_dim_vector =
   (
      input_choice_real_dim_vector_contents
   )

# Choice of input method, e.g. for prescribed fields
input_choice_real_dim_vector_plus_file =
   (
      input_choice_real_dim_vector_contents|
      ## Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      ##
      ## THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase
      element from_file {
         attribute file_name { xsd:string },
         vtu_input_format,
         comment
      }
   )

input_choice_real_dim_vector_contents =
   ## Constant value
   element constant {
      real_dim_vector
   }|
   ## Python function prescribing dimensional vector input. Functions should be of the form:
   ##
   ##  def val(X, t):
   ##     # Function code
   ##     return # Return value
   ##
   ## where X and the return value are tuples of length geometry dimension.
   element python {
      python_code
   }

# Choice of input method, e.g. for boundary conditions
# this one specifies a vector field of dim minus one
input_choice_real_dim_minus_one_vector =
   (
      ## Constant value
      element constant {
         real_dim_minus_one_vector
      }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }
   )

## Import data from NetCDF CF-1.x file.
input_choice_netcdf =
   (
      element from_file {
         ## The format of this file should conform to NetCDF CF 1.x
         ## (http://cf-pcmdi.llnl.gov/)
         attribute file_name { xsd:string },
         comment
      }
   )

# Choice of input method for initial conditions
# Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
input_choice_initial_condition_vector =
   (
      ## Constant value
      element constant {
         real_dim_vector
      }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }|
      ## Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      element from_file {
         attribute file_name { xsd:string },
         vtu_input_format,
         comment
      }|
      ## Set balanced velocity from height field
      element balanced {
               ## Solver
         element solver {
            linear_solver_options_sym
         }?
      }|
      ## project velocity from a DG field
      element dg_projection {
         ## Field to project from
         attribute source_field { xsd:string }
      }         
   )

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_symmetric_tensor
      }|
      ## Python command prescribing symmetric tensor input.
      ##
      ## Note that it is for the python function to determine 
      ## that the results it produces are, in fact, symmetric.
      ##
      ## An example that returns the three-dimensional identity:
      ##
      ##  def val(X, t):
      ##    return [[1, 0, 0],
      ##                [0, 1, 0],
      ##                [0, 0, 1]]
      element python {
         python_code
      }
   )

# Choice of input method for initial/boundary conditions
# version for real tensor
input_choice_real_dim_tensor =
   (
      ## Constant tensor
      element constant {
         real_dim_tensor
      }|
      ## Python command prescribing tensor input.
      ##
      ## An example that returns the three-dimensional identity:
      ##
      ##  def val(X, t):
      ##    return [[1, 0, 0],
      ##                [0, 1, 0],
      ##                [0, 0, 1]]
      element python {
         python_code
      }
   )

prognostic_velocity_field =
   (
      velocity_equation_choice,
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## A new version of continuous galerkin assembly.
            element continuous_galerkin {
               ## Stabilisation options for the galerkin discretisation
               element stabilisation{
                  (
                     no_stabilisation|
                     su_stabilisation|
                     supg_stabilisation
                  )
               },
               ## Discretisation options for the mass terms in the velocity equation.
               element mass_terms{
                  ## Lump the mass matrix - currently required if solving for pressure
                  element lump_mass_matrix {
                     ## Lump on the submesh.
                     ## This only works for simplex meshes and is only
                     ## strictly valid on 2d meshes.
                     element use_submesh {
                       empty
                     }?
                  }?,
                  ## Remove the mass terms from the equation.
                  element exclude_mass_terms {
                     empty
                  }?
               },
               ## Discretisation options for the advection terms in the velocity equation.
               element advection_terms {
                  ## Integrate the advection terms of the momentum equation by parts.
                  ## This allows for the imposition of weak boundary conditions.
                  ## If activated the element advection matrix takes the form:
                  ##    /                                            /
                  ##  - | (grad N_A dot nu) N_B rho dV - (1. - beta) | N_A ( div nu ) N_B rho dV
                  ##    /                                            /
                  ## otherwise it takes the standard form:
                  ##    /                                     /
                  ##    | N_A (nu dot grad N_B) rho dV + beta | N_A ( div nu ) N_B rho dV
                  ##    /                                     /
                  ## where beta is set in conservative_advection, N is
                  ## a shape function and nu is the relative nonlinear
                  ## velocity.
                  element integrate_advection_by_parts {
                     empty
                  }?,
                  ## Remove the advection terms (u.grad u rho + beta
                  ## div u rho u) from the equation.
                  ## This overrides any other advection term options
                  ## (including conservative_advection below).
                  element exclude_advection_terms {
                     empty
                  }?
               }
            }|
            ## Discontinuous galerkin formulation. This causes Momentum_DG to be
            ## called instead of diff3d. Confusingly it is not necessary to provide
            ## a discontinuous velocity field for this to work!
            element discontinuous_galerkin {
               element advection_scheme {
                  (
                     ## Disable advection
                     element none {
                        empty
                     }| 
                     ## Straightforward upwinding of the nonlinear velocity
                     element upwind {
                        empty
                     }
                  )
               }
            }
         ),
         ## Conservative discretisation of field advection equation
         ##  TBETA=1. -- conservative (divergence form)
         ##  TBETA=0. -- non-conservative
         ##  0. < TBETA < 1.
         element conservative_advection {
            real
         }         
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_vector
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_vector
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         velocity_boundary_conditions
      }*,
      ## Source
      element vector_field {
         attribute name { "Source" },
         attribute rank { "1" },
         (
            element prescribed {
               prescribed_vector_field_no_adapt
            }
         )
      }?,  
      prognostic_vector_output_options,
      prognostic_vector_stat_options,
      vector_convergence_options,
      prognostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_prognostic_vector_field,
      interpolation_algorithm_vector,
      discrete_properties_algorithm_vector?
   )

prognostic_layerthickness_field =
   (
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Development continuous Galerkin formulation. This causes
            ## Advection_Diffusion_CG to be used instead of hart3d.
            element continuous_galerkin {
               ## Discretisation options for the advection terms.
               element advection_terms {
                  ## Remove the advection terms from the equation.
                  ## This overrides any other advection term options (including
                  ## conservative_advection below).
                  element exclude_advection_terms {
                     comment
                  }?
               },
               comment
            },
            ## Conservative discretisation of field advection equation
            ##  TBETA=1. -- conservative (divergence form)
            ##  TBETA=0. -- non-conservative
            ##  0. < TBETA < 1.
            element conservative_advection {
               real
            }
       )
      },
      ## Temporal discretisation options
      element temporal_discretisation {
         ## Implicit/explicit control (THETA)
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicolson
         ##  =1.  -- implicit
         element theta {
            real
         },
         ## Non-linear relaxation term
         ##  =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
         ##  =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
         ##  0. < ITHETA < 1.
         element relaxation {
            real
         }
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      ),      
      ## Mean value of thickness to use in wave equation solver
      ## Will be replaced by a field in due course
      element mean_layer_thickness {
         real
      },
      ## Source
      element scalar_field {
         attribute name { "Source" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }
         )
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar
   )

prognostic_lagrangemultiplier_field =
   (
      ## Spatial discretisation options
      element spatial_discretisation {
         empty
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Initial condition is not used for shallow water or Helmholtz 
      ## solves but is required for test_trace_space.
      element initial_condition {
         attribute name { string },
         region_ids,
         input_choice_initial_condition_real
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar
   )

prognostic_scalar_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      ),
      ## Diffusivity for field
      element tensor_field {
         attribute name { "Diffusivity" },
         attribute rank { "2" },
         element prescribed {
            mesh_choice?,
            prescribed_values_tensor_field
         }
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      adjoint_storage
   )

# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?,
      adjoint_storage
   )
   
# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options,
      adjoint_storage
   )

# Default child of diagnostic scalar field
diagnostic_scalar_field_tidal_range =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      (
          element spin_up_time {
             real
          }
      ),
      adjoint_storage
   )

# Default child of prescribed scalar field
# This is a choice of ways of inputing the prescribed field
prescribed_scalar_field =
   (
      prescribed_scalar_field_no_adapt,
      adaptivity_options_scalar_field,
      interpolation_algorithm_scalar?,
      discrete_properties_algorithm_scalar?,
      recalculation_options?
   )

# Default child of prescribed scalar field without adaptivity options
# This is a choice of ways of inputing the prescribed field
prescribed_scalar_field_no_adapt =
   (
      prescribed_values_scalar_field,
      prescribed_output_options,
      prescribed_scalar_stat_options,
      prescribed_detector_options,
      adjoint_storage
   )
   
prescribed_values_scalar_field =
   (
      (
         ## Value for WholeMesh
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_real_plus_file
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_real_plus_file
         }
      )+
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,      
      diagnostic_detector_options,
      vector_steady_state_options,      
      adaptivity_options_vector_field,
      recalculation_options?,
      adjoint_storage
   )


diagnostic_vector_field_bed_shear_stress =
   (
      (
          element density {
             real
          }
      ),       
      (
          element drag_coefficient {
             real
          }
      ),   
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field,
      adjoint_storage
   )



# Default child of prescribed vector field
# This is a choice of ways of inputing the prescribed field
prescribed_vector_field =
   (
      prescribed_vector_field_no_adapt,
      adaptivity_options_vector_field,
      interpolation_algorithm_vector?,
      discrete_properties_algorithm_vector?,
      recalculation_options?
   )
   
# Default child of prescribed vector field without adaptivity options
# This is a choice of ways of inputing the prescribed field
prescribed_vector_field_no_adapt =
   (
      prescribed_values_vector_field,
      prescribed_output_options,
      prescribed_vector_stat_options,
      prescribed_detector_options,
      adjoint_storage
   )

prescribed_values_vector_field =
   (
      (
         ## Value for WholeMesh
         ##
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_real_dim_vector_plus_file
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_real_dim_vector_plus_file
         }
      )+
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_output_options,
      adaptivity_options_tensor_field
   )

# Default child of prescribed vector field
# This is a choice of ways of inputing the prescribed tensor field
# If the field is constant then a symmetric, or asymmetric tensor may be entered
prescribed_tensor_field =
   (
      prescribed_values_tensor_field,
      adaptivity_options_tensor_field
   )

prescribed_values_tensor_field =
   (
      (
         ## Value for WholeMesh
         ##
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_tensor_field
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_tensor_field
         }
      )+
   )


velocity_components_choice =
   (
      (
# rotated bcs are not implemented... this is where they should go when they are
#         element align_bc_with_surface {
#            element normal_component {
#               input_choice_real
#            }?,
#            element tangent_component_1 {
#               input_choice_real
#            }?,
#            element tangent_component_2 {
#               input_choice_real
#            }?,
#            rotation_matrix_components
#         }|
         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )
   
input_choice_real_bc_component = 
   (
      input_choice_real|
      element synthetic_eddy_method {
         ## use a large number to ensure Gaussian 
         ## behaviour of the fluctuating component
         element number_of_eddies {
           integer
         },
         element turbulence_lengthscale {
            input_choice_real
         },
         ## mean profile
         ##
         ## usually a function of height,
         ## for ABL simulations use a log profile
         element mean_profile {
            input_choice_real
         },
         ## Reynolds stresses profile
         ##
         ## usually a function of height,
         ## assumes that the remaining stresses are negligible 
         element Re_stresses_profile {
           input_choice_real
         }
      }
   )

# and again for robin b.c.s
robin_velocity_components_choice =
   (
      (
#         element align_bc_with_surface {
#            element normal_component {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            element tangent_component_1 {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            element tangent_component_2 {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            rotation_matrix_components
#         }|
         element align_bc_with_cartesian {
            element x_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?,
            element y_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?,
            element z_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            }?,
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         element type {
            attribute name { "robin" },
            robin_velocity_components_choice
         }|
         element type {
            attribute name { "free_surface" }
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                empty
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|

         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density 
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air. 
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the 
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the 
                  ## recommended (non-dimensional) value of 1.0 for 
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real}
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }
      )
   )
   
# Output options for prognostic fields
prognostic_scalar_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Output a file details the convergence (or otherwise) of
         ## this field with every advective nonlinear
         ## iteration.
         ## ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.
         element convergence_file {
            comment
         }?
      }
   )

# Output options for pressure (can't have a convergence file)
pressure_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Write out some extra debugging vtu files that can be used
         ## to analyse what goes on in the pressure projection steps.
         ## WARNING: this may create a huge amount of vtu files, as 
         ## multiple files are written per nonlinear iteration.
         element debugging_vtus {
            empty
         }?
      }
   )

# Output options for prognostic fields
prognostic_vector_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?
      }
   )
   
# Output options for all other fields
field_output_options =
   (
      ## Specify what is written to vtu dump files
      element output {
         ## By default each field in the options file is written to vtu.
         ## Select this option to exclude this field.
         element exclude_from_vtu {
            empty
         }?
      }
   )
   
diagnostic_output_options = field_output_options
prescribed_output_options = field_output_options

# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options = 
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )
  
# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat
         
      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat = 
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )   
   
# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_vector_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_vector_stat_options.stat
         )
      }      
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_vector_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_vector_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         integer_vector
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields, 
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

adaptivity_preprocessing =
      ## Occasionally, it is desirable to apply operations or filters
      ## to fields before using them for the purposes of adaptivity.
      element preprocessing {
        (
            ## Invert a helmholtz operator to smooth out the field
            ## before using it to adapt. This can help with noisy
            ## fields.
            element helmholtz_smoother {
                 element smoothing_length_scale {
                     real_dim_symmetric_tensor
                 },
                 element solver {
                   linear_solver_options_sym
                 }
            }
        )
      }?

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# Most common mesh choices
mesh_choice = 
   (
      element mesh {
         attribute name { xsd:string }
      }|
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "PressureMesh" }
      }
   )

# Not really a choice, for fields that have to be on the velocity mesh
# currently that's all scalar fields, except pressure
# and of course velocity itself
# If you want to implement scalar fields on other meshes, feel free to do so
# but bare in mind you need to make sure the field stays outside RMEM.
# Currently all scalar fields are packed in RMEM with length nonods
velocity_mesh_choice =
   (
      (
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

pressure_mesh_choice =
   (
      (
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that FLUIDITY knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.

         ## Salinity
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Salinity" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Temperature" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Background Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BackgroundTemperature" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Free Surface
         ## NOTE: the prognostic FreeSurface field only works with the
         ## legacy_continuous_galerkin code path
         ## NOTE: if you are using the free_surface boundary condition
         ## applied to the Velocity field (recommended), you should not 
         ## use the prognostic FreeSurface field. In this case you may 
         ## (optionally) add a diagnostic FreeSurface field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FreeSurface" },
            (
               ## Free Surface
               ## NOTE: the prognostic FreeSurface field only works with the
               ## legacy_continuous_galerkin code path
               element prognostic {
                  ## Note that this is not the quadratic mesh balance pressure is
                  ## actually calculated on, but the linear mesh it is projected back
                  ## on for output purposes.
                  element mesh {
                     attribute name { "VelocityMesh" }
                  },
                  prognostic_free_surface_field
               }|
               ## Free Surface
               ## NOTE: the diagnostic FreeSurface field only works in combination
               ## with the free_surface boundary condition applied to the Velocity
               ## field. It gives you a 3D field (constant over the vertical)
               ## of the free surface elevation.
               element diagnostic {
                  internal_algorithm,
                  # this is hard-coded on the PressureMesh as long as the Pressure is
                  # if this is no longer true, it should be option-checked to be on the
                  # same mesh as Pressure
                  ## Must be on the same mesh as Pressure
                  element mesh {
                     attribute name { "PressureMesh" }
                  },
                  diagnostic_scalar_field
               }
               
            )
         }|
         ## Second Fluid
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SecondFluid" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Diffuse Interface
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DiffuseInterface" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## If enabled, decomposes Pressure by solving for the balanced part of 
         ## Pressure using a "geopressure" solver:
         ## 
         ##   f = - grad p_gp + g
         ##
         ## By choosing an appropriate mesh (typically velocity mesh order + 1)
         ## for the balanced part of pressure, physical balance can be
         ## represented to a higher degree of accuracy.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GeostrophicPressure" },
            (
               element prognostic {
                  ## The GeostrophicPressure mesh
                  ## 
                  ## <b>WARNING: It is usual for this to be a higher degree
                  ## mesh than the velocity mesh</b>
                  element mesh {
                     attribute name { xsd:string },
                     comment
                  },
                  prognostic_geostrophic_pressure_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VerticalBalancePressure" },
            (
               element prognostic {
                  ## This needs to be a quadratic DG mesh
                  mesh_choice,
                  prognostic_vertical_balance_pressure_field
               }
            )
         }|
         ## MaterialVolumeFraction field:
         ##
         ## Volume fraction of this material.
         ## Required in multimaterial simulations.
         ##  - if prognostic solves for the volume fraction
         ##  - if prescribed uses a specified volume fraction
         ##  - if diagnostic solves for the final material volume fraction
         ## Only 1 diagnostic MaterialVolumeFraction field allowed per
         ## simulation or solves for all the volume fractions based on
         ## the SumMaterialVolumeFractions field.
         ## 
         ## A diagnostic MaterialVolumeFraction field is currently required for
         ## compressible multimaterial simulations (even if only 1 material).
         ## Generally also requires a MaterialDensity field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialVolumeFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field,
                  cap_option?,
                  surface_tension_option?
               }|
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field,
                  cap_option?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## MaterialDensity field:
         ##
         ## Field for the density of this material.
         ## Required in multimaterial simulations.
         ##  - prescribed if an incompressible simulation
         ##  - diagnostic if using a linear equation of state
         ##  - prognostic if a compressible simulation
         ## (note that if you set a multimaterial
         ## equation of state and this field is
         ## prognostic then its initial condition
         ## will be overwritten by the density that
         ## satisfies the initial pressure and
         ## the equation of state)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialDensity" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## MaterialInternalEnergy field:
         ##
         ## Field for the internal energy of this material.
         ## Required in multimaterial compressible simulations
         ## with full stiffened_gas (perfect gas) eos.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialInternalEnergy" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## SumMaterialVolumeFractions field:
         ##
         ## Sums the prognostic MaterialVolumeFraction fields.
         ## - diagnostic: sums all the volume fractions in the other
         ##   material phases
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SumMaterialVolumeFractions" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CopiedField - This field copies the previous timesteps
         ## values from another (specified) field at every iteration
         ## and then solves the field using different (again, specified)
         ## scheme and solution options.
         ## For instance, this field can be used to create a diffused
         ## field to adapt to.
         ## Unless someone requests otherwise this is only currently possible
         ## for fields within the same material_phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopiedField" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  attribute copy_from_field { string },
                  prognostic_scalar_field
               }
            )
         }|
         ## Calculate the stream function of 2D incompressible flow. Note 
         ## that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
         ## Requires a continuous mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "StreamFunction" },
            (
               element prognostic {
                  mesh_choice,
                  prognostic_stream_function_field
               }
            )
         }|
         ## Phytoplankton
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Phytoplankton" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Zooplankton
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Zooplankton" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Nutrient
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Nutrient" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Detritus
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Detritus" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|

         ## PhaseVolumeFraction:
         ## Required in porous_media problem type
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|

         ## Electrical Potential:
         ## Required in electrokinetic, electrothermal
         ## and electrochemical problems
         ## (sub-option of porous_media problem type)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ElectricalPotential" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }
            )
         }|

         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }
         
# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.

         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DistanceToSideBoundaries" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## MaterialFrictionAngle for multimaterial
         ## plasticity problems
         ##
         ## Requires a diagnostic bulk FrictionAngle field
         ## - not tested yet
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialFrictionAngle" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## MaterialCohesion for multimaterial
         ## plasticity problems
         ##
         ## Requires a diagnostic bulk Cohesion field
         ## - not tested yet
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialCohesion" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PerturbationDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the control volume C^T matrix.
         ## This assumes that the test space is discontinuous
         ## control volumes.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Diffusive dissipation
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DiffusiveDissipation" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Viscous dissipation
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ViscousDissipation" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Richardson Number:
         ##
         ##  Ri = \frac{N^2}{(\frac{\partial u}{\partial z})^2 + (\frac{\partial u}{\partial z})^2}
         ## with 
         ##  N^2 = -\frac{g}{\rho_0}\frac{\partial \rho}{\partial z}
         ##
         ## Limitations:
         ##  - Gravity must be constant.
         ##  - Assumes gravity is in -ve final coordinate direction.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "RichardsonNumber" },
            attribute depends { "Velocity,PerturbationDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_richardson_number_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## DG_CourantNumber
         ##
         ## Courant Number as defined on a DG mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DG_CourantNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CVMaterialDensityCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh and
         ## incorporating the MaterialDensity.
         ## Requires a MaterialDensity field!
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CVMaterialDensityCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SolidConcentration" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## This scalar field is meant to replace DENTRAF.
         ## Basically, if you use new options, DENTRAF is no longer needed
         ## No repointing is done from this field to DENTRAF.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopyofDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Solid_configuration to 
         ## Visualize the solids and MaterialVolumeFraction together
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VisualizeSolidFluid" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Solid_configuration to 
         ## Visualize the solid_Concentration
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VisualizeSolid" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Solid_configuration to 
         ## map  the solid_Concentration from particle mesh to 
         ## the fluid mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ParticleScalar" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Explicit_ALE to 
         ## visualize functional values before iterations start.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FunctionalBegin" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Explicit_ALE to 
         ## visualize functional values at each iteration.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FunctionalIter" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## add a MaterialVolume scalar_field to calculate the spatially varying 
         ## volume of a material (requires a MaterialVolumeFraction)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialVolume" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## add a MaterialMass scalar_field to calculate the spatially varying 
         ## mass of a material (requires a MaterialVolumeFraction and a MaterialDensity)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialMass" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculates the MaterialDensity based on the bulk Pressure
         ## (and MaterialInternalEnergy if appropriate) for the equation
         ## of state of this material.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialEOSDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculates the MaterialPressure based on the MaterialDensity
         ## (and MaterialInternalEnergy if appropriate) for the equation
         ## of state of this material.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialPressure" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculates the BulkMaterialPressure based on the MaterialDensity
         ## and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate) 
         ## for the equation of state of all materials.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BulkMaterialPressure" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Grid Reynolds number
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridReynoldsNumber" },
            (element diagnostic {
               internal_algorithm,
               element mesh {
                  attribute name { "VelocityMesh" }
               },
               diagnostic_scalar_field
            }
            | element aliased { generic_aliased_field })
         }|
         ## GridPecletNumber
         ##
         ## Peclet Number Pe = U*dx/2*diffusivity
         ##
         ## Also see the test case 'grid_peclet_number'
         ## if you wish to see the effect of changing the 
         ## diffusivity on a 1D, cg-discretised tracer-field
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridPecletNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  ## Mesh on which to calculate dx
                  mesh_choice,
                  ## This is the name of the scalar field
                  ## to calculate the Peclet number for
                  ## Note this field needs to have a diffusivity
                  element field_name { string },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Horizontal velocity divergence:
         ##
         ## div_H velocity
         ##
         ## Uses the gravity field direction to determine the horizontal plane.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalVelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Velocity divergence:
         ##
         ## div velocity
         ##
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Kinetic energy density:
         ##
         ##  1/2 rho_0*|u|^2
         ##
         ## where rho_0 is the (reference) density 
         ##
         ## Limitations:
         ##  - The Density, PerturbationDensity, KineticEnergyDensity and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "KineticEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Gravitational potential energy density:
         ##
         ## rho_0*(1.0 + rho')*(g dot (r - r_0))
         ##
         ## where rho_0 is the (reference) density, rho' is the perturbation density and r_0 is the potential energy zero point.
         ##
         ## Limitations:
         ##  - Requires a constant gravity direction.
         ##  - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GravitationalPotentialEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  ## Coordinate of a point with a potential energy of zero.
                  element zero_point {
                     real_dim_vector
                  }
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Isopycnal coordinate
         ##
         ##  z_star(x,t) = 1/A int_V' H(rho(x',t)-rho(x,t)) dV'
         ##
         ## where rho is the density, A is the width/area of the domain
         ##
         ## Limitations:
         ##  - You need to specify a (fine) mesh to redistribute the PerturbationDensity onto
         ##  - Requires a constant gravity direction.
         ##  - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "IsopycnalCoordinate" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  ## This is the mesh onto which we redistribute the PerturbationDensity
                  element fine_mesh {
                     attribute name { string }
                  },
                  diagnostic_scalar_field                 
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Background potential energy density:
         ##
         ## PE_b = rho*z_star
         ##
         ## where rho is the density, z_star is the isopycnal coordinate
         ##
         ## Limitations:
         ##  - Requires a constant gravity direction.
         ##  - The Density, PerturbationDensity and
         ##  GravitationalPotentialEnergyDensity fields must be on the
         ##  same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BackgroundPotentialEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field                 
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Ertel potential vorticity:
         ##
         ##  (f + curl u) dot grad rho'
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PotentialVorticity" },
            attribute depends { "Velocity,PerturbationDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Relative potential vorticity:
         ##
         ##   curl u dot grad rho'
         element scalar_field {
            attribute rank { "0" },
            attribute name { "RelativePotentialVorticity" },
            attribute depends { "Velocity,PerturbationDensity" },
            (
              element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the horizontal stream function psi where:
         ##   \partial_x \psi = -v
         ##   \partial_y \psi = u
         ## where u and v are perpendicular to the gravity direction. Applies a
         ## strong Dirichlet boundary condition of 0 on all boundaries.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalStreamFunction" },
            attribute depends { "Velocity" },
            (
              element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  ## Solver
                  element solver {
                     linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Speed:
         ##
         ##  |u|
         ##
         ## Limitations:
         ##  - The Speed and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Speed" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Volume of the vehicles
         ##
         ## used in Traffic Modelling
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SolidPhase" },
            attribute raplaces { "IDENT = -42"},
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  }?,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Primary production of Phytoplankton. This is calculated by
         ## the ocean biology module and will not be calculated unless
         ## ocean biology is being simulated.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PrimaryProduction" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Grazing of Phytoplankton by Zooplankton. This is calculated by
         ## the ocean biology module and will not be calculated unless
         ## ocean biology is being simulated.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhytoplanktonGrazing" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )

         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "TidalRange" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field_tidal_range
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeM2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseM2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeS2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseS2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeN2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseN2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeK2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseK2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeK1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseK1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeO1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseO1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeP1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseP1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeQ1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseQ1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeMf" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseMf" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeMm" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseMm" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeSSa" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the universal numbering of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "UniversalNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the nodes of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "NodeOwner" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the elements of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ElementOwner" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }
                  
# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## If this is not set, the dimension of the vector field is
            ## that set by /geometry/dimension
            element dimension {
               integer
            }?,
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prognostic_fields_below___ {
            empty
         }|

#
# -- List of fields that are primarily prescribed,
#    but can be aliased. An example is Maximum bed shear stress.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|

         ## Gradient of a scalar field evaluated using the C gradient
         ## matrix constructed using finite elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_gradient_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T divergence matrix constructed using finite
         ## elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementDivergenceTransposed" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Relative vorticity field - curl of the velocity field
         element vector_field {
            attribute rank { "1" },
            attribute name { "Vorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  ### Relative vorticity
                  #element algorithm {
                  #   attribute name { "curl" },
                  #   attribute material_phase_support { "single" },
                  #   attribute source_field_name { "Velocity" }
                  #},
                  element mesh {
                     attribute name { "VelocityMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|        
         ## Planetary vorticity
         ##
         ## Limitations:
         ##  - Requires geometry dimension of 3.
         element vector_field {
            attribute rank { "1" },
            attribute name { "PlanetaryVorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Absolute vorticity:
         ##
         ##   f + curl u
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteVorticity" },
            attribute depends { "Velocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T matrix constructed using control volumes.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "ControlVolumeDivergenceTransposed" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Full velocity in an
         ## inner element SGS treatment of momentum
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         ##  - Requires inner element active for momentum
         element vector_field {
            attribute rank { "1" },
            attribute name { "InnerElementFullVelocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "InnerElementMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Vorticity of the full velocity in an
         ## inner element SGS treatment of momentum
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         ##  - Requires inner element active for momentum
         element vector_field {
            attribute rank { "1" },
            attribute name { "InnerElementFullVorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "InnerElementMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Vorticity of the SGS velocity in an
         ## inner element SGS treatment of momentum
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         ##  - Requires inner element active for momentum
         element vector_field {
            attribute rank { "1" },
            attribute name { "InnerElementVorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "InnerElementMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## The continuous solution mapped to a discontinuous mesh
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         ##  - Requires inner element active for momentum
         element vector_field {
            attribute rank { "1" },
            attribute name { "DgMappedVelocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "InnerElementMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Vorticity of the DG mapped Velocity
         ## Note vorticity is actually calculated over a DG field
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         ##  - Requires inner element active for momentum
         element vector_field {
            attribute rank { "1" },
            attribute name { "DgMappedVorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "InnerElementMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Solid Velocity field.  Used to generate the momentum source 
         element vector_field {
            attribute rank { "1" },
            attribute name { "SolidVelocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "ParticleVector" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "ParticleForce" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|

         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "SolidForce" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         element vector_field {
            attribute rank { "1" },
            attribute name { "VelocityPlotForSolids" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "FunctionalGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## LinearMomentum field.
         ##  p = \rho*u 
         ## (where p is the linear momentum, \rho the density and u the velocity)
         element vector_field {
             attribute rank { "1" },
             attribute name { "LinearMomentum" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Experimental geostrophic source field to be used in combination with
         ## a free surface. Does not solve a vertical balance yet.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GeostrophicSource" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Bed Shear Stress = density*drag_coeff*|u|*u
         ##
         ## at the moment this assumes the density and drag coefficients are constants.
         ## This diagnostic vector field is only calculated over surface elements/nodes, 
         ## interior nodes will have zero value.
         element vector_field {
             attribute rank { "1" },
             attribute name { "BedShearStress" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field_bed_shear_stress
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Max Bed Shear Stress.
         ##
         ## Note that you need BedShearStress turned on for this to work.
         element vector_field {
             attribute rank { "1" },
             attribute name { "MaxBedShearStress" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice
                   #diagnostic_vector_field_max_bed_shear_stress
                }|
                element aliased {
                   generic_aliased_field
                }
             ),
            ## This is the time after which the max operator is
            ## applied to the bed shear stress.
            element spin_up_time {
               real
            }
         }|

         ## Displacement
         element vector_field {
             attribute rank { "1" },
             attribute name { "Displacement" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,                  
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Projects the Coriolis term onto the mesh of this diagnostic field.
         ## Note that multiple projection methods are available (under the
         ## algorithm option).
         element vector_field {
            attribute rank { "1" },
            attribute name { "Coriolis" },
            (
               element diagnostic {
                  coriolis_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }

# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )  

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  tensor_diagnostic_algorithms,
                  velocity_mesh_choice,
                  python_diagnostic_field_code?,
                  diagnostic_tensor_field
               }
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

         ## MaterialViscosity field:
         ##
         ## Field for the viscosity of this material.
         ## Required if using a diagnostic bulk viscosity
         ## in a multimaterial simulation.
         element tensor_field {
            attribute rank { "2" },
            attribute name { "MaterialViscosity" },
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         element tensor_field {
            attribute rank { "2" },
            attribute name { "MaterialElasticity" },
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## From a field on a mesh, diagnose the anisotropic
         ## interpolation weight that would give the mesh back.
         ## It is computed as:
         ## \Eps = M^-1 |H|
         element tensor_field {
            attribute rank { "2" },
            attribute name { "FieldTolerance" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  velocity_mesh_choice,
                  diagnostic_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }

# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# Diagnostic statistics options for meshed, with enabled by default
mesh_stat_options_enabled_default = include_mesh_in_stat
mesh_stat_options_enabled_default |= exclude_mesh_from_stat

# Diagnostic statistics options for meshed, with disabled by default
mesh_stat_options_disabled_default = exclude_mesh_from_stat
mesh_stat_options_disabled_default |= include_mesh_in_stat

from_file_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_enabled_default
      }
   )
derived_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_disabled_default
      }
   )

input_choice_tensor_field =
   (
      (
         ## An isotropic tensor, i.e.
         ## one with no directional variation.
         ## Can be represented as a scalar real.
         element isotropic {
            input_choice_real
         }|
         ## A symmetric tensor, i.e.
         ## A^T = A
         element anisotropic_symmetric {
            input_choice_real_dim_symmetric_tensor
         }|
         ## A general asymmetric tensor.
         element anisotropic_asymmetric {
            input_choice_real_dim_tensor
         }
      )
   )

constitutive_laws =
   (
      (
         ## Constitutive laws for fluids
         element constitutive_law {
            attribute name { "fluid" }
         }|
         ## Constitutive laws for solids
         element constitutive_law {
            attribute name { "solid" }
         }
      )
   )
   
region_ids = 
   ( 
      ## Optional region ids to associate different values
      ## to different regions of the mesh.
      ## Leave unselected if you`re not using multiple regions or
      ## region_ids.
      ## Currently only works with triangle files created by gmsh2triangle.
      element region_ids {
         integer_vector
      }?
   )

temporal_control_volume_options =
   (
      ## Temporal discretisation options that are only relevant if a control volume or mixed control volume - continuous galerkin spatial discretisation is selected for this field.
      element control_volumes {
         ## Number of iterations within an advection solve.
         ## This increases the accuracy of the face values and ensures that
         ## the pivoted solution is cancelled out.
         ## Defaults to 1 if unselected.
         element number_advection_iterations {
            integer,
            ## Cut short advection_iterations if the specified tolerance
            ## is reached.
            ## This only works for pure control volume discretisations.
            element tolerance {
               real,
               (
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The infinity norm.
                  element infinity_norm {
                    empty
                  }|
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The l2 norm.
                  element l2_norm {
                    empty
                  }|
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The l2 norm evaluated on a control volume mesh.
                  element cv_l2_norm {
                    empty
                  }
               )               
            }?
         }?,
         (
            ## Use timestep subcycling to solve this equation.
            ## Specify the maximum courant number per subcycle.
            ## This only works for pure control volume discretisations.
            element maximum_courant_number_per_subcycle {
               real,
               field_based_cfl_number_options
            }|
            ## Use timestep subcycling to solve this equation.
            ## Specify the number of subcycles.
            ## This only works for pure control volume discretisations.
            element number_advection_subcycles {
               integer
            }
         )?,
         ## Only works if a control volume or mixed control volume -
         ## continuous galerkin spatial discretisation is selected.
         ## If not active then the theta specified above will be used.
         ## Otherwise use variable limited theta on individual faces.
         element limit_theta {
            empty
         }?,
         ## Only works if a control volume or mixed control volume -
         ## continuous galerkin spatial discretisation is selected.
         ## Time discretisation of upwind discretisation off which the
         ## higher order solution is pivotted.
         ##  - pivot_theta = 1 - implicit pivot (default if not set and 
         ##                      best choice if not intentionally modifying
         ##                      scheme to be explicit)
         ##  - pivot_theta = 0 - explicit pivot
         element pivot_theta {
            real
         }?
      }
   )

temporal_discontinuous_galerkin_options = 
   (
      ## This enables DG-specific timestepping options, such as
      ## explicit advection subcycling. 
      element discontinuous_galerkin {
         (
            ## Use timestep subcycling to solve this equation.
            ## Specify the maximum courant number per subcycle.
            element maximum_courant_number_per_subcycle {
               real
            }|
            ## Use timestep subcycling to solve this equation.
            ## Specify the number of subcycles.
            element number_advection_subcycles {
               integer
            }
         )?
      }
   )

pure_cv_options = 
   (
      ## Use a pure control volume discretisations.
      ## Follows a new control volume code path.
      element control_volumes {
         spatial_control_volume_options,
         (
            ## Use the gradient of the field constructed using the
            ## basis functions of the parent finite element mesh to
            ## form the divergence.
            ##
            ## DOES NOT CURRENTLY WORK WITH ROBIN OR WEAK DIRICHLET BOUNDARY CONDITIONS!
            ##
            ## Based on schemes in Handbook of Numerical Analysis,
            ## P.G. Ciarlet, J.L. Lions eds, vol 7, pp 713-1020
            element diffusion_scheme {
              attribute name{"ElementGradient"}
            }|
            ## Use an auxiliary gradient equation to find the gradient of the field.
            ##
            ## DOES NOT CURRENTLY WORK WITH ROBIN BOUNDARY CONDITIONS!
            ##
            ## Based on scheme proposed in Bassi, F. & Rebay, S., A
            ## high-order accurate discontinuous finite element method
            ## for the numerical solution of the compressible
            ## Navier-Stokes equations, Journal Of Computational
            ## Physics, 1997, 131, 267-279
            element diffusion_scheme {
              attribute name{"BassiRebay"}
            }
         )
      }
   )

spatial_control_volume_options = standard_control_volume_options
spatial_control_volume_options |= compressive_control_volume_options

standard_control_volume_options = 
   (
      ## First Order Upwind face value discretisation
      ##  face_value = donor_value, 
      ## where
      ##  donor_value = income*val_1 + (1.-income)*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order upwinding is monotonic so no limiting is ever required
      element face_value {
        attribute name { "FirstOrderUpwind" },
        empty
      }|
      ## Trapezoidal face value discretisation
      ##  face_value = 0.5*(val_1 + val_2), 
      ## where
      ##  val_i is the value on the ith node neighbouring the face
      ##
      ## Trapezoidal discretisation is unbounded so limiting is compulsory
      element face_value {
        attribute name { "Trapezoidal" },
        limiter_options
      }|
      ## Finite Element face value discretisation
      ##  face_value = finite element interpolation from surrounding nodes
      ##
      ## Finite element discretisation may become unbounded so limiting is often necessary.
      element face_value {
        attribute name { "FiniteElement" },
        limiter_options?
      }
   )
   
coupled_spatial_control_volume_options = coupled_control_volume_options
coupled_spatial_control_volume_options |= compressive_control_volume_options

# coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
# except that firstorderupwind gets limiter options
coupled_control_volume_options = 
   (
      ## First Order Upwind face value discretisation
      ##  face_value = donor_value, 
      ## where
      ##  donor_value = income*val_1 + (1.-income)*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order upwinding is monotonic so no limiting is ever required
      element face_value {
        attribute name { "FirstOrderUpwind" },
        limiter_options?
      }|
      ## Trapezoidal face value discretisation
      ##  face_value = 0.5*(val_1 + val_2), 
      ## where
      ##  val_i is the value on the ith node neighbouring the face
      ##
      ## Trapezoidal discretisation is unbounded so limiting is compulsory
      element face_value {
        attribute name { "Trapezoidal" },
        limiter_options
      }|
      ## Finite Element face value discretisation
      ##  face_value = finite element interpolation from surrounding nodes
      ##
      ## Finite element discretisation may become unbounded so limiting is often necessary.
      element face_value {
        attribute name { "FiniteElement" },
        limiter_options?
      }
   )
   
compressive_control_volume_options = 
   (
      ## HyperC face value discretisation
      ##
      ## face_value calculated from upper bound of explicit TVD zone of NVD diagram
      ## Normally used for MaterialVolumeFraction fields
      element face_value {
        attribute name { "HyperC" },
        upwind_value_options?,
        cv_face_cfl_number_options
      }|
      ## UltraC face value discretisation
      ##
      ## face_value calculated from extended upper bound of
      ## explicit TVD zone of NVD diagram assuming
      ## values bounded by target_maximum and target_minimum.
      element face_value {
        attribute name { "UltraC" },
        ## Specifiy the upper bound which UltraC will use to
        ## calculate the maximum flux.
        element target_maximum {
            real
        },
        ## Specifiy the lower bound which UltraC will use to
        ## calculate the minimum flux.
        element target_minimum {
            real
        },
        upwind_value_options?,
        cv_face_cfl_number_options
      }|
      ## **UNDER TESTING**
      ##
      ## PotentialUltraC face value discretisation
      ##
      ## face_value calculated from extended upper bound of
      ## explicit TVD zone of NVD diagram if potential
      ## value of field is sufficient (as specified by
      ## target_maximum) to ensure the correct front advection
      ## velocity.
      ##
      ## If not then either switch to HyperC or use a modified flux
      ## based on the potential function.
      element face_value {
        attribute name { "PotentialUltraC" },
        ## Specifiy the upper bound which PotentialUltraC will use
        ## to calculate the maximum flux if the potential function
        ## value is sufficient to maintain the correct front
        ## advection velocity.
        element target_maximum {
            real
        },
        ## Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.
        element target_minimum {
            real
        },
        (
            ## Select what PotentialUltraC should do if the
            ## potential function value does not reach the required
            ## value specified by the target_maximum.
            ##
            ## Switch to using HyperC face values.  This ensures
            ## that the advection velocity is correct however may
            ## create isolated regions beneath the target_maximum.
            element switch_to_hyperc {
              empty
            }|
            ## Select what PotentialUltraC should do if the
            ## potential function value does not reach the required
            ## value specified by the target_maximum.
            ##
            ## Modify the maximum nodal values (both downwind and
            ## upwind) so that the fluxes are at their maximum
            ## possible without affecting the front advection
            ## velocity.
            element use_potential_flux {
              empty
            }
        ),
        upwind_value_options?,
        cv_face_cfl_number_options
      }
   )

#Select the type of dynamic control to be used
#Note: DEM and FEMDEM require the respective libraries
#to be compiled.
input_solid_dynamics_choice =         
   (
      ## Obtain values from point and radius file.
      ##
      ## First line of file is free to use (for comments)
      ## Second line must contain the number of particles
      ## Third and fourth line are again for comments. 
      ## Following lines include 10 columns, corresponding to 
      ## the particle's x, y, and z positions, followed by the radius, then
      ## velocities in x, y, and z directions, followed by angular velocities
      ## in the x, y, and z directions.
      element dynamic_type {
         attribute name {"from_input_file"},
         attribute file_name {xsd:string}
      }|
      ## Two python scripts must be provided. The script is cycled over each particle.
      ## One script for particle position (output is tuple of position coords)
      ## Second script is for particle radius (output is tuple of position coords)
      ## Third script is for particle translational velocity.
      ## Fourth script is for particle angular velocity. (Note: particles 
      ## have a no slip boundary condition at the surface, so this angular velocity
      ## WILL matter to the flow.)
      ## Python functions should be of the form:
      ##  def val(X, t):
      ##    Function code
      ##    return # Return value
      ## where X is a tuple of length geometry dimension.
      ##    X[0] contains the number of the particle (in real format)
      element dynamic_type {
         attribute name {"python_script"}
      }|
      element dynamic_type {
         attribute name {"use_simple_dynamics"},
         element set_bottom{real},
         element set_xmin{real},
         element set_ymin{real},
         element set_zmin{real},
         element set_xmax{real},
         element set_ymax{real},
         element set_zmax{real}
      }|
      ## Using y3D to model dynamics. Filename of input file for y3D must
      ## be specified.
      element dynamic_type {
         attribute name {"use_y3D"},
         attribute file_name {xsd:string}
      }|
      ## Using femdem 2D to model dynamics. Filename of input file must
      ## be specified.
      element dynamic_type {
         attribute name {"use_2Dfemdem"},
         attribute file_name {xsd:string}
      }|
      ## Using femdem 3D to model dynamics. Filename of input file must
      ## be specified.
      element dynamic_type {
         attribute name {"use_3Dfemdem"},
         attribute file_name {xsd:string},
         element quad2lin {
            attribute file_name {xsd:string}
         }
      }         
   )

cap_option =
   (
      ## Cap the min and max values of this field when using
      ## it as a volume fraction to work out bulk material
      ## properties.
      ## No capping used if not selected.
      element cap_values {
         ## Set the upper bound on the field.
         ## Defaults to huge(0.0)*epsilon(0.0) if not set.
         element upper_cap {
            real
         }?,
         ## Set the lower bound on the field.
         ## Defaults to -huge(0.0)*epsilon(0.0) if not set.
         element lower_cap {
            real
         }?
      }
   )

surface_tension_option =
   (
      element surface_tension {
        ## Surface tension coefficient
        element surface_tension_coefficient {
          real
        },
        ## The equilibrium contact angle (in radians) with the boundaries identified by the surface ids
        element equilibrium_contact_angle {
          real,
          ## Surface ids:
          element surface_ids {
              integer_vector
          }
        }?
      }
   )

limiter_options =
  (
      ## Limit the face value to satisfy a boundedness criterion.
      element limit_face_value{
        (
          sweby_limiter|
          ultimate_limiter
        )
      }
  )

sweby_limiter = 
  ## See "High-Resolution Schemes Using Flux Limiters for
  ## Hyperblic Conservation-Laws", P. K. Sweby, 1984, Siam
  ## Journal on Numerical Analysis, 21, 995-1011
  element limiter {
    attribute name {"Sweby"},
    slope_options?,
    upwind_value_options?
  }

ultimate_limiter =
  ## See "The Ultimate Conservative Difference Scheme Applied
  ## to Unsteady One-Dimensional Advection", B. P. Leonard,
  ## 1991, Computer Methods in Applied Mechanics and
  ## Engineering, 88, 17-74
  element limiter {
    attribute name {"Ultimate"},
    field_based_cfl_number_options,
    upwind_value_options?
  }

slope_options =
   (
      ## Control the upper and lower slopes of the NVD limiter
      element slopes {
         ## Defaults to Sweby, 1984 limiter (= 1.0) if unselected
         element lower {
            real
         }?,
         ## Defaults to Sweby, 1984 limiter (= 2.0) if unselected
         element upper {
            real
         }?
      }
   )

upwind_value_options =
   (
      (
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## This method projects the upwind value from a point in the element just
         ## upwind of the node pair straddling the face.  It is otherwise known as 
         ## anisotropic limiting.
         ## This is only available on simplex meshes as it involes a search around
         ## the donor node to find the upwind element.
         element project_upwind_value_from_point {
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which it was found from.
            element bound_projected_value_locally {
               empty
            }?,
            ## Store the locations of the elements where the upwind values
            ## are projected from for each node pair.
            ## This inserts an integer csr matrix into state so is memory expensive but
            ## saves a significant amount of time (searching around the neighbouring elements).
            ## This is unsafe for moving meshes but should be ok for adaptive meshes.
            element store_upwind_elements {
               ## Store the quadrature locations within the elements
               ## where the upwind values
               ## are projected from for each node pair.
               ## This inserts a real block csr matrix into state so is even more memory
               ## expensive than just storing the upwind elements and
               ## only saves a comparitively
               ## marginal amount of time (as actually searching the
               ## neighbouring elements is the
               ## slowest bit, finding the quadrature is relatively easy).
               element store_upwind_quadrature {
                  empty
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Projects the value of the advected variable from the downwind or donor node
         ## using the interpolated gradient at the donor node in the
         ## direction of the vector
         ## connecting the node pair straddling the face.
         ## This is available on all meshes (except if bounding the values).
         element project_upwind_value_from_gradient {
            (
               ## Select which node to project from:
               ## Project from the downwind node (Jasak et al., 1999) so that:
               ## upwind_value = downwind_value - 2*gradient.vector
               element project_from_downwind_value {
                  comment
               }|
               ## Select which node to project from:
               ## Project from the donor node so that:
               ## upwind_value = donor_value - gradient.vector
               element project_from_donor_value {
                  comment
               }
            ),
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which surround it.
            ## This is only available on simplex meshes as it involes a search around
            ## the donor node to find the upwind element.
            element bound_projected_value_locally {
               ## Store the locations of the elements closest to the project value.
               ## This inserts an integer csr matrix into state so is
               ## memory expensive but
               ## saves a significant amount of time (searching around
               ## the neighbouring elements).
               ## This is unsafe for moving meshes but should be ok for adaptive meshes.
               element store_upwind_elements {
                  comment
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the maximum or minimum of the neighbouring
         ## nodes depending on the local slope of the donor and downwind values.
         ## Otherwise known as isotropic limiting.
         ## This is available on all meshes.
         element locally_bound_upwind_value {
            empty
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the value at the node most directy
         ## upwind from the vector connecting the donor and downwind nodes.
         ## This is available on all meshes.
         element pseudo_structured_upwind_value {
            empty
         }
      )
   )

field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite difference definition of the CFL Number
         ## consistent with the 1D version of HyperC (Leonard, 1981).
         ## This is the default that reproduces old behaviour.
         ## All others are under testing or construction.
         element courant_number {
            attribute name { "FiniteDifferenceCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain  
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins 
         ## e.g. the values 0 1 2 3 will return 4 bins 
         ## and the fraction of the field in each bin with,
         ## 0<=field<1, 1<=field<2, 2<=field<3, 3<=field, 
         ## will be calculated. 
         element mixing_bin_bounds { 
            real_vector 
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file   
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )

velocity_equation_choice =
   (
      ## Select the equation used to solve for velocity.
      element equation {
         attribute name { "ShallowWater" }
      }
   )

scalar_equation_choice =
   (
      (
         ## Select the equation used to solve for this field.
         ## Advection Diffusion is the norm for scalar fields.
         ## Works for all discretisation types.
         element equation { 
            attribute name { "AdvectionDiffusion" }
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Conservation of Mass equation - requires the selection of a Density field.
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         element equation { 
            attribute name { "ConservationOfMass" },
            (
               ## Select density to use in the Conservation of Mass Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Conservation of Mass Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Conservation of Mass Equation
               element density {
                  attribute name { string }
               }
            )
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Reduced Conservation of Mass equation - requires the selection of a Density field.
         ##
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         ##
         ## This equation is very similar to a standard conservation of mass equation
         ## except that the time discretisation uses only a single time level of density.
         ## This enables consistency between the
         ## MaterialVolumeFraction (ReducedConservationOfMass) and
         ## MaterialDensity (Advection) equations in compressible multimaterial simulations.
         element equation { 
            attribute name { "ReducedConservationOfMass" },
            (
               ## Select density to use in the Reduced Conservation of Mass Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Reduced Conservation of Mass Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Reduced Conservation of Mass Equation
               element density {
                  attribute name { string }
               }
            )
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Internal Energy equation - requires the selection of a Density field.
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         ## Solve the internal energy equation for this field.
         ## Requires pressure and velocity fields to be present.
         ## Uses a nonconservative time discretisation.
         element equation {
            attribute name { "InternalEnergy" },
            (
               ## Select density to use in the Internal Energy Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               ## Whatever field is selected must be present.
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Internal Energy Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               ## Whatever field is selected must be present.
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Internal Energy Equation
               ## Whatever field is selected must be present.
               element density {
                  attribute name { string }
               }
            )
         }|
         ## Option to solve for electrical potential from
         ## electrokinetic, electrochemical or electrothermal sources 
         element equation { 
            attribute name { "ElectricalPotential" }
         }
      )
   )

inner_element_scalar = 
   (
      ## Inner element sub-grid scale model (Candy and Pain)
      ## Requires continuous galerkin selected above.
      element inner_element {
         ## Inner element solution of the scalar field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "InnerElement" },
            element prognostic {
               element mesh {
                  attribute name {  "InnerElementMesh" }
               },
               prognostic_scalar_output_options,
               prognostic_scalar_stat_options,
               prognostic_detector_options
            }
         }
      }
   )
      
inner_element_velocity =
   (
      ## Inner element sub-grid scale model (Candy and Pain)
      ## Requires continuous galerkin selected above.
      element inner_element {
         ## SGS velocity in an inner element SGS treatment of momentum
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         ##  - Requires inner element active for momentum
         element vector_field {
            attribute rank { "1" },
            attribute name { "InnerElement" },
            element prognostic {
               element mesh {
                  attribute name {  "InnerElementMesh" }
               },
               prognostic_vector_output_options,
               prognostic_vector_stat_options,
               vector_convergence_options
            }
         },
         ## A filter for the sub-grid scale equations
         ## Add diffusion to matrix D of the Inner Element model
         element use_filter {
            ## Strength of the diffusion term
            ## Suggested value: 0.01
            element strength {
               real
            },
            empty
         }?,
         element use_quadratic_pressure {
            empty
         }?,
         element apply_full_discontinuous_Galerkin {
            empty
         }?
      }?
   )
forcing =
  (
    ## Add forcing from ocean data
    ## If you enable this you MUST enable the /geometry/ocean_boundaries option too
    element ocean_forcing{
        ## The netCDF data file downloaded from ERA-40 reanalysis
        element input_file {
           attribute file_name {xsd:string} 
        },
        element mesh_choice {
            velocity_mesh_choice
        },
        element surface_stress {
            empty
        }?,
        element temperature_flux {
            empty
        }?,
        element salinity_flux {
            empty
        }?,
        element solar_radiation {
            empty
        }?
    }
  )

biology =
   (
      ## Model of biological processes in the ocean.
      element ocean_biology{
         ## A simple model of phytoplankton, zooplankton, general nutrient and detritus. 
         element pznd {
            (
               ## Python code specifying the source and sink relationships 
               ## between the biological tracers. This is usually achieved by 
               ## importing fluidity.ocean_biology and calling a scheme from there. 
               element source_and_sink_algorithm {
                  python_code
               }|
               ## Do not calculate sources and sinks. 
               ## This option is generally only useful for testing. 
               element disable_sources_and_sinks {
                  empty
               }
             ),
#            ## Phytoplankton
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Phytoplankton" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
#            ## Zooplankton
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Zooplankton" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
#            ## Nutrient
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Nutrient" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
#            ## Detritus
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Detritus" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
            ## Photosynthetically Active Radiation (PAR)
            element scalar_field {
               attribute rank { "0" },
               attribute name { "PhotosyntheticRadiation" },
               (
                  element prognostic {
                     velocity_mesh_choice,
                     prognostic_photosynthetic_radiation
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_scalar_field
                  }
               )
            }
         }
      }
   )


prognostic_photosynthetic_radiation =
   (
      ## PAR equation.
      element equation { 
         attribute name { "PhotosyntheticRadiation" }
      },
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Discontinuous galerkin formulation. You can also use this
            ## formulation with a continuous field in which case a simple
            ## galerkin formulation will result. 
            element discontinuous_galerkin {
               empty
            }
         )
      },
      (
         ## Solver
         element solver {
            linear_solver_options_asym
         }
      ),
      ## Coefficients of absorption of photosynthetically active
      ## radiation for water and phytoplankton.
      element absorption_coefficients {
         ## Photosynthetically active radiation absorption coefficient for water.
         element water {
            real
         },
         ## Photosynthetically active radiation absorption coefficient for water.
         element phytoplankton {
            real
         }
      },
      ## Boundary conditions
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               ## Apply the dirichlet bc weakly.  Only available with
               ## discontinuous_galerkin, control_volume and
               ## legacy_mixed_cv_cg spatial_discretisations.
               ##
               ## If not selected boundary conditions are applied strongly.
               element apply_weakly {
                 empty
               },
               input_choice_real
            }|
            element type {
               attribute name { "neumann" },
               input_choice_real
            }|
            element type {
               attribute name { "robin" },
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }
         )
      }+,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      ## Set the priority of this field
      ## This determines the order in which scalar_fields are solved for:
      ##  - higher numbers have the highest priority
      ##  - lower numbers (including negative) have the lowest priority
      ##  - default if not set is 0
      element priority {
         integer
      }?
   )

recalculation_options =
   (
      ## Prevent this field from being recalculated at every timestep.
      ## This is cheaper especially if you are enforcing discrete properties on the field.
      element do_not_recalculate {
        empty
      }
   )

discrete_properties_algorithm_scalar =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        ## Update this field using the lagrangian multiplier
        ## calculated in the solenoidal projection of a
        ## scalar field.
        ##
        ## Note this field must be specified as the update field
        ## underneath that vector field too.
        ##
        ## Note also this only really makes sense for coupled
        ## fields like velocity and pressure.
        element solenoidal_lagrange_update {
          empty
        }?
      }
   )

discrete_properties_algorithm_vector =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        solenoidal_options?
      }
   )

solenoidal_options =
    ## Constrained divergence-free projection.
    ## This adds an additional constraint that ensures that the field
    ## is solenoidal, i.e. divergence-free.
    ## This is equivalent in cost to a pressure solve.
    ## This is expensive, and thus best left until
    ## needed.
    ##
    ## Note well: this only makes sense for nondivergent
    ## vector fields, such as incompressible velocity!
    element solenoidal {
      ## Options for the mass matrix of the field being interpolated
      element interpolated_field {
        (
          element continuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            ##
            ## Required when using interpolating continuous fields
            element lump_mass_matrix {
              ## Lump on the submesh.
              ## This only works for simplex meshes and is only
              ## strictly valid on 2d meshes.
              element use_submesh {
                empty
              }?
            }
          }|
          element discontinuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            element lump_mass_matrix {
              empty
            }?
          }
        )
      },
      ## Options for the lagrange multiplier
      ##
      ## Must be on a continuous mesh!
      element lagrange_multiplier {
        pressure_mesh_choice,
        element spatial_discretisation {
          (
            element continuous_galerkin {
              ## Remove the stabilisation term from the projection operator.
              ##
              ## Automatic when not using P1P1.
              element remove_stabilisation_term {
                empty
              }?,
              ## Integrate the divergence operator by parts.
              ##
              ## Automatic when projecting a discontinuous field
              element integrate_divergence_by_parts {
                empty
              }?
            }|
            element control_volumes {
              empty
            }
          )
        },
        element reference_node {
          integer
        }?,
        (
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { "Pressure" },
            empty
          }|
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { string },
            empty
          }
        )?,
        ## Solver options for the linear solve.
        ## This method requires the inversion of a projection matrix.
        element solver {
          linear_solver_options_sym
        }
      }
    }

represcribe_before_interpolation =
    ## Represcribe the field before interpolation.
    ##
    ## This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!
    element represcribe_before_interpolation {
      empty
    }

