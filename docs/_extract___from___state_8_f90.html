<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICFERST: /home/mbahlali/Softwares/MultiFluids_Dev_master_ubuntu24_new/ICFERST/src/Extract_From_State.F90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="IC_FERST_Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ICFERST<span id="projectnumber">&#160;25-11</span>
   </div>
   <div id="projectbrief">Reservoir simulator based on DCVFEM, Dynamic Mesh optimisation and Surface-based modelling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_extract___from___state_8_f90.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle"><div class="title">Extract_From_State.F90 File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;fdebug.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Extract_From_State.F90:</div>
<div class="dyncontent">
<div class="center"><img src="_extract___from___state_8_f90__incl.png" border="0" usemap="#a_2home_2mbahlali_2_softwares_2_multi_fluids___dev__master__ubuntu24__new_2_i_c_f_e_r_s_t_2src_2_extract___from___state_8_f90" alt=""/></div>
<map name="a_2home_2mbahlali_2_softwares_2_multi_fluids___dev__master__ubuntu24__new_2_i_c_f_e_r_s_t_2src_2_extract___from___state_8_f90" id="a_2home_2mbahlali_2_softwares_2_multi_fluids___dev__master__ubuntu24__new_2_i_c_f_e_r_s_t_2src_2_extract___from___state_8_f90">
<area shape="rect" title=" " alt="" coords="5,5,211,75"/>
<area shape="rect" title=" " alt="" coords="69,123,147,148"/>
<area shape="poly" title=" " alt="" coords="111,75,111,109,105,109,105,75"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespacecopy__outof__state" id="r_namespacecopy__outof__state"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html">copy_outof_state</a></td></tr>
<tr class="memdesc:namespacecopy__outof__state"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module enables the multiphase prototype code to interact with state by copying everything required from state to ICFERST, adaptive time-stepping, outfluxes computation, tunneled BCs and Darcy velocity. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a60bda55d8fe3fd82eed3fbb6c17cd8be" id="r_a60bda55d8fe3fd82eed3fbb6c17cd8be"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a60bda55d8fe3fd82eed3fbb6c17cd8be">copy_outof_state::get_primary_scalars_new</a> (state, mdims)</td></tr>
<tr class="memdesc:a60bda55d8fe3fd82eed3fbb6c17cd8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine extracts all primary variables associated with the mesh from state, and associated them with the variables used in the MultiFluids model.  <br /></td></tr>
<tr class="separator:a60bda55d8fe3fd82eed3fbb6c17cd8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba0b467480d0b56c11d18f70e8c680e" id="r_abba0b467480d0b56c11d18f70e8c680e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#abba0b467480d0b56c11d18f70e8c680e">copy_outof_state::compute_node_global_numbers</a> (state, ndgln)</td></tr>
<tr class="memdesc:abba0b467480d0b56c11d18f70e8c680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine calculates the global node numbers requested to operates in ICFERST.  <br /></td></tr>
<tr class="separator:abba0b467480d0b56c11d18f70e8c680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e9236f15044530da105400e0e3e3f4" id="r_a25e9236f15044530da105400e0e3e3f4"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a25e9236f15044530da105400e0e3e3f4">copy_outof_state::get_ele_type</a> (x_nloc, cv_ele_type, p_ele_type, u_ele_type, mat_ele_type, u_sele_type, cv_sele_type)</td></tr>
<tr class="memdesc:a25e9236f15044530da105400e0e3e3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Obtain the type of element u_ele_type = cv_ele_type = p_ele_type will flag the dimension and type of element: = 1 or 2: 1D (linear and quadratic, respectively) -NOT SUPPORTED- = 3 or 4: triangle (linear or quadratic, respectively) = 5 or 6: quadrilateral (bi-linear or tri-linear, respectively)-NOT SUPPORTED- = 7 or 8: tetrahedron (linear or quadratic, respectively) = 9 or 10: hexahedron (bi-linear or tri-linear, respectively) -NOT SUPPORTED-  <br /></td></tr>
<tr class="separator:a25e9236f15044530da105400e0e3e3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8ae22869d79032fd250ea6cc0651c9" id="r_a8c8ae22869d79032fd250ea6cc0651c9"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a8c8ae22869d79032fd250ea6cc0651c9">copy_outof_state::get_ele_type_new</a> (mdims, mdisopt)</td></tr>
<tr class="memdesc:a8c8ae22869d79032fd250ea6cc0651c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Obtains the element type Mdisoptu_ele_type = Mdisoptcv_ele_type = Mdisoptp_ele_type will flag the dimension and type of element: = 1 or 2: 1D (linear and quadratic, respectively) -NOT SUPPORTED- = 3 or 4: triangle (linear or quadratic, respectively) = 5 or 6: quadrilateral (bi-linear or tri-linear, respectively) -NOT SUPPORTED- = 7 or 8: tetrahedron (linear or quadratic, respectively) = 9 or 10: hexahedron (bi-linear or tri-linear, respectively) -NOT SUPPORTED-  <br /></td></tr>
<tr class="separator:a8c8ae22869d79032fd250ea6cc0651c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c4aa970124056f8138a72ed4a1612" id="r_a977c4aa970124056f8138a72ed4a1612"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a977c4aa970124056f8138a72ed4a1612">copy_outof_state::get_discretisation_options</a> (state, mdims, mdisopt)</td></tr>
<tr class="memdesc:a977c4aa970124056f8138a72ed4a1612"><td class="mdescLeft">&#160;</td><td class="mdescRight">: This subroutine extract all discretisation options from the schema DISOPT Options: =0 1st order in space Theta=specified UNIVERSAL =1 1st order in space Theta=non-linear UNIVERSAL =2 Trapezoidal rule in space Theta=specified UNIVERSAL =2 if isotropic limiter then FEM-quadratic &amp; stratification adjust. Theta=non-linear =3 Trapezoidal rule in space Theta=non-linear UNIVERSAL =4 Finite elements in space Theta=specified UNIVERSAL =5 Finite elements in space Theta=non-linear UNIVERSAL =6 Finite elements in space Theta=specified NONE =7 Finite elements in space Theta=non-linear NONE =8 Finite elements in space Theta=specified DOWNWIND+INTERFACE TRACKING =9 Finite elements in space Theta=non-linear DOWNWIND+INTERFACE TRACKING  <br /></td></tr>
<tr class="separator:a977c4aa970124056f8138a72ed4a1612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca89971343f6586b89f1cddda00b2c8" id="r_afca89971343f6586b89f1cddda00b2c8"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#afca89971343f6586b89f1cddda00b2c8">copy_outof_state::pack_multistate</a> (npres, state, packed_state, multiphase_state, multicomponent_state, pmulti_state)</td></tr>
<tr class="memdesc:afca89971343f6586b89f1cddda00b2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">: This subroutine creates packed_state from state(:) and links the appropiate memory so it is acessible from both states. This subroutine also introduces fields not used by fludity but required by IC-FERST  <br /></td></tr>
<tr class="separator:afca89971343f6586b89f1cddda00b2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b23a7607a135aaa7f055b36d531f41" id="r_a52b23a7607a135aaa7f055b36d531f41"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a52b23a7607a135aaa7f055b36d531f41">copy_outof_state::prepare_absorptions</a> (state, mdims, multi_absorp)</td></tr>
<tr class="memdesc:a52b23a7607a135aaa7f055b36d531f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Prepares the memory to compute absorption fields  <br /></td></tr>
<tr class="separator:a52b23a7607a135aaa7f055b36d531f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa3817b7e0890e5009c4905376a5688" id="r_abfa3817b7e0890e5009c4905376a5688"><td class="memItemLeft" align="right" valign="top">type(vector_field) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#abfa3817b7e0890e5009c4905376a5688">copy_outof_state::as_vector</a> (tfield, dim, slice)</td></tr>
<tr class="memdesc:abfa3817b7e0890e5009c4905376a5688"><td class="mdescLeft">&#160;</td><td class="mdescRight">: This function points a tensor field as a vector field type This is necessary when solving for tensor fields that are actually multiphase vector fields.  <br /></td></tr>
<tr class="separator:abfa3817b7e0890e5009c4905376a5688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc946977b60a10ae77f86013eb499e7" id="r_a6bc946977b60a10ae77f86013eb499e7"><td class="memItemLeft" align="right" valign="top">type(vector_field) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a6bc946977b60a10ae77f86013eb499e7">copy_outof_state::as_packed_vector</a> (tfield)</td></tr>
<tr class="memdesc:a6bc946977b60a10ae77f86013eb499e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">: This function points a tensor field as a vector field type This is necessary when solving for tensor fields that are actually multiphase vector fields.  <br /></td></tr>
<tr class="separator:a6bc946977b60a10ae77f86013eb499e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec84623fb582762f2139794470ba13" id="r_a60ec84623fb582762f2139794470ba13"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a60ec84623fb582762f2139794470ba13">copy_outof_state::finalise_multistate</a> (packed_state, multiphase_state, multicomponent_state)</td></tr>
<tr class="memdesc:a60ec84623fb582762f2139794470ba13"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Destrys packed_state and the passed down states  <br /></td></tr>
<tr class="separator:a60ec84623fb582762f2139794470ba13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b2882fb5f551e74ea186c313d5419d" id="r_a25b2882fb5f551e74ea186c313d5419d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a25b2882fb5f551e74ea186c313d5419d">copy_outof_state::adaptive_nonlinear</a> (mdims, packed_state, reference_field, its, itime, repeat_time_step, exitnonlinearloop, nonlinearadaptts, old_acctim, order, calculate_mass_delta, adapt_mesh_in_fpi, accum_courant, courant_tol, current_courant, first_time_step)</td></tr>
<tr class="memdesc:a25b2882fb5f551e74ea186c313d5419d"><td class="mdescLeft">&#160;</td><td class="mdescRight">: This subroutine either store variables before the nonlinear timeloop starts, or checks how the nonlinear iterations are going and depending on that increase the timestep or decreases the timestep and repeats that timestep  <br /></td></tr>
<tr class="separator:a25b2882fb5f551e74ea186c313d5419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad775c010bade229fba0416002e6928a6" id="r_ad775c010bade229fba0416002e6928a6"><td class="memItemLeft" align="right" valign="top">real function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ad775c010bade229fba0416002e6928a6">copy_outof_state::inf_norm_scalar_normalised</a> (tracer, reference_tracer, dumping, totally_min_max)</td></tr>
<tr class="memdesc:ad775c010bade229fba0416002e6928a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inf norm of the normalised field, so the field goes from 0 to 1 It requires as inputs the tracer to be used and the reference tracer to normallise, the dumping to be set to 1.0 and totally_min_max which includes the min max values of the field across all processors also for normalisation.  <br /></td></tr>
<tr class="separator:ad775c010bade229fba0416002e6928a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6957a54cc1cc0a38a4a7a90bca1f89" id="r_a7d6957a54cc1cc0a38a4a7a90bca1f89"><td class="memItemLeft" align="right" valign="top">real function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a7d6957a54cc1cc0a38a4a7a90bca1f89">copy_outof_state::get_convergence_functional</a> (phasevolumefraction, reference_sat, dumping, its)</td></tr>
<tr class="memdesc:a7d6957a54cc1cc0a38a4a7a90bca1f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">: We create a potential to optimize F = sum (f**2), so the solution is when this potential reaches a minimum. Typically the value to consider convergence is the sqrt(epsilon of the machine), i.e. 10^-8 f = (NewSat-OldSat)/Number of nodes; this is the typical approach for algebraic non linear systems  <br /></td></tr>
<tr class="separator:a7d6957a54cc1cc0a38a4a7a90bca1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e108d42b18611e2908d988a6155b70" id="r_ad4e108d42b18611e2908d988a6155b70"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ad4e108d42b18611e2908d988a6155b70">copy_outof_state::get_var_from_packed_state</a> (packed_state, fedensity, oldfedensity, iteratedfedensity, density, olddensity, iterateddensity, phasevolumefraction, oldphasevolumefraction, iteratedphasevolumefraction, velocity, oldvelocity, iteratedvelocity, fephasevolumefraction, oldfephasevolumefraction, iteratedfephasevolumefraction, nonlinearvelocity, oldnonlinearvelocity, iteratednonlinearvelocity, componentdensity, oldcomponentdensity, iteratedcomponentdensity, componentmassfraction, oldcomponentmassfraction, temperature, oldtemperature, iteratedtemperature, fetemperature, oldfetemperature, iteratedfetemperature, iteratedcomponentmassfraction, fecomponentdensity, oldfecomponentdensity, iteratedfecomponentdensity, fecomponentmassfraction, oldfecomponentmassfraction, iteratedfecomponentmassfraction, pressure, fepressure, oldfepressure, cvpressure, oldcvpressure, cv_immobile_fraction, coordinate, velocitycoordinate, pressurecoordinate, materialcoordinate, cappressure, immobile_fraction, endpointrelperm, relpermexponent, cap_entry_pressure, cap_exponent, imbibition_term, concentration, oldconcentration, iteratedconcentration, feconcentration, oldfeconcentration, iteratedfeconcentration, enthalpy, oldenthalpy, iteratedenthalpy, feenthalpy, oldfeenthalpy, iteratedfeenthalpy)</td></tr>
<tr class="memdesc:ad4e108d42b18611e2908d988a6155b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">@DEPRECATED: Gets memory from packed state This subroutine returns a pointer to the desired values of a variable stored in packed state All the input variables (but packed_stated) are pointers following the structure of the *_ALL variables and also all of them are optional, hence you can obtaine whichever you want  <br /></td></tr>
<tr class="separator:ad4e108d42b18611e2908d988a6155b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c28692d04b581272d173fcc445b3c7" id="r_ac6c28692d04b581272d173fcc445b3c7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ac6c28692d04b581272d173fcc445b3c7">copy_outof_state::printcsrmatrix</a> (matrix, find, col, dim_same_row)</td></tr>
<tr class="memdesc:ac6c28692d04b581272d173fcc445b3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Subroutine to print CSR matrix by (row, column) Dimensions and phases are printed in different rows So for example Matrix(2,2,10) with two rows would be presented as a matrix ( 8 x 10)  <br /></td></tr>
<tr class="separator:ac6c28692d04b581272d173fcc445b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c981b328d9950b1c375aaacaa3cda0" id="r_ab7c981b328d9950b1c375aaacaa3cda0"><td class="memItemLeft" align="right" valign="top">logical function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ab7c981b328d9950b1c375aaacaa3cda0">copy_outof_state::is_constant</a> (tfield)</td></tr>
<tr class="memdesc:ab7c981b328d9950b1c375aaacaa3cda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Checks whether a field is constant or not  <br /></td></tr>
<tr class="separator:ab7c981b328d9950b1c375aaacaa3cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc850cced2fb9b525f015e758e4b45da" id="r_abc850cced2fb9b525f015e758e4b45da"><td class="memItemLeft" align="right" valign="top">character(len=field_name_len) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#abc850cced2fb9b525f015e758e4b45da">copy_outof_state::getoldname</a> (tfield)</td></tr>
<tr class="memdesc:abc850cced2fb9b525f015e758e4b45da"><td class="mdescLeft">&#160;</td><td class="mdescRight">: For a given field, retrieve the associated old field name  <br /></td></tr>
<tr class="separator:abc850cced2fb9b525f015e758e4b45da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1305d6f3dc1c1ec92a4135ea55947b9" id="r_ac1305d6f3dc1c1ec92a4135ea55947b9"><td class="memItemLeft" align="right" valign="top">character(len=field_name_len) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ac1305d6f3dc1c1ec92a4135ea55947b9">copy_outof_state::getfemname</a> (tfield)</td></tr>
<tr class="memdesc:ac1305d6f3dc1c1ec92a4135ea55947b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">: For a given field, retrieve the associated finite element field name  <br /></td></tr>
<tr class="separator:ac1305d6f3dc1c1ec92a4135ea55947b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14ee9b4425c63a84854359e22ea1007" id="r_ab14ee9b4425c63a84854359e22ea1007"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ab14ee9b4425c63a84854359e22ea1007">copy_outof_state::calculate_internal_volume</a> (packed_state, mdims, mass_ele, calculate_mass, cv_ndgln, den_all, eles_with_pipe)</td></tr>
<tr class="memdesc:ab14ee9b4425c63a84854359e22ea1007"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Subroutine to calculate the integrated mass inside the domain  <br /></td></tr>
<tr class="separator:ab14ee9b4425c63a84854359e22ea1007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea2acdccf9091776be013ade24bcd97" id="r_acea2acdccf9091776be013ade24bcd97"><td class="memItemLeft" align="right" valign="top">logical function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#acea2acdccf9091776be013ade24bcd97">copy_outof_state::have_option_for_any_phase</a> (path, nphase)</td></tr>
<tr class="memdesc:acea2acdccf9091776be013ade24bcd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Subroutine to check whether an option is true for any phase in diamond, if any is true it returns true. The path must be the part of the path inside the phase, i.e. /multiphase_properties/capillary_pressure  <br /></td></tr>
<tr class="separator:acea2acdccf9091776be013ade24bcd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e2450672b43ae176fc5a459424126" id="r_aec4e2450672b43ae176fc5a459424126"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#aec4e2450672b43ae176fc5a459424126">copy_outof_state::get_darcyvelocity</a> (mdims, ndgln, state, packed_state, upwnd)</td></tr>
<tr class="memdesc:aec4e2450672b43ae176fc5a459424126"><td class="mdescLeft">&#160;</td><td class="mdescRight">: This subroutine calculates the actual Darcy velocity, but with P0DG precision only!  <br /></td></tr>
<tr class="separator:aec4e2450672b43ae176fc5a459424126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe914b0d919d92535a188ab7c0e384" id="r_adbfe914b0d919d92535a188ab7c0e384"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#adbfe914b0d919d92535a188ab7c0e384">copy_outof_state::dump_outflux</a> (current_time, itime, outfluxes)</td></tr>
<tr class="memdesc:adbfe914b0d919d92535a188ab7c0e384"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Subroutine that dumps the total flux at a given timestep across all specified boundaries to a file called 'simulation_name_outfluxes.csv'. In addition, the time integrated flux up to the current timestep is also outputted to this file. Integration boundaries are specified in diamond via surface_ids. (In diamond this option can be found under "/io/dump_boundaryflux/surface_ids" and the user should specify an integer array containing the IDs of every boundary they wish to integrate over).  <br /></td></tr>
<tr class="separator:adbfe914b0d919d92535a188ab7c0e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0358bf9293883d5a332167bc0558b985" id="r_a0358bf9293883d5a332167bc0558b985"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a0358bf9293883d5a332167bc0558b985">copy_outof_state::update_outfluxes</a> (bcs_outfluxes, outfluxes, sele, cv_nodi, suf_area, vol_flux, mass_flux, tracer, outfluxes_fields, start_phase, end_phase)</td></tr>
<tr class="memdesc:a0358bf9293883d5a332167bc0558b985"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Updates the outfluxes information based on NDOTQNEW, shape functions and transported fields for a given GI point in a certain element This subroutine should only be called if SELE is on the BOUNDARY Example of Mass_flux: ndotq(iphase) * SdevFunsDETWEI(gi) * LIMT(iphase) Example of Vol_flux: ndotq(iphase) * SdevFunsDETWEI(gi) * LIMDT(iphase)  <br /></td></tr>
<tr class="separator:a0358bf9293883d5a332167bc0558b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3a3dde8f1e1a2af432f5475d43482e" id="r_adc3a3dde8f1e1a2af432f5475d43482e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#adc3a3dde8f1e1a2af432f5475d43482e">copy_outof_state::enterforcebalanceequation</a> (entersolve, its, itime, acctim, t_adapt_threshold, after_adapt, after_adapt_itime, pvf_cfl)</td></tr>
<tr class="memdesc:adc3a3dde8f1e1a2af432f5475d43482e"><td class="mdescLeft">&#160;</td><td class="mdescRight">:&ndash;A Subroutine that returns a Logical, either to Enter the Force Balance Eqs or Not = given a requested_cfl_pressure it will skip the ForceBalanceEquation that many times = while if I have adaptive mesh it will solve the ForceBalanceEquation after each adapt_time_steps = The Subroutive also account for delaying adaptivity and swich between cfl_pressure and after_adapt=  <br /></td></tr>
<tr class="separator:adc3a3dde8f1e1a2af432f5475d43482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8739357084387e6b6fce7d59602dfd7" id="r_ab8739357084387e6b6fce7d59602dfd7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#ab8739357084387e6b6fce7d59602dfd7">copy_outof_state::impose_connected_bcs</a> (outfluxes, packed_state, mdims, acctime)</td></tr>
<tr class="memdesc:ab8739357084387e6b6fce7d59602dfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Using the outfluxes values, it imposes as BC the averaged value of another BC(from within the domain) It is a basic method to get this functionality but it will work in parallel. However, it does not guarantee mass conservation as it uses the value from the previous time-step although it can still be used for many cases such as ATES, or ventilation. Overwrites the dirichlet BC values. Currently it uses the information from outfluxes so it is MANDATORY to use and request outfluxes for those BCs  <br /></td></tr>
<tr class="separator:ab8739357084387e6b6fce7d59602dfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d23340ebea84c65fde71abdf1444071" id="r_a4d23340ebea84c65fde71abdf1444071"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a4d23340ebea84c65fde71abdf1444071">copy_outof_state::getoutputconverter</a> (fieldname, factor, shft)</td></tr>
<tr class="memdesc:a4d23340ebea84c65fde71abdf1444071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the factor to convert from internal (SI) to the output system For temperature it returns the shift term not the factor.  <br /></td></tr>
<tr class="separator:a4d23340ebea84c65fde71abdf1444071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc8d031030fe04b455bd92ca32e4d08" id="r_a6fc8d031030fe04b455bd92ca32e4d08"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecopy__outof__state.html#a6fc8d031030fe04b455bd92ca32e4d08">copy_outof_state::converttooutunits</a> (state, mdims, convertback)</td></tr>
<tr class="memdesc:a6fc8d031030fe04b455bd92ca32e4d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Convert fields to out units. Also has a backwards options as we need to undo this after dumping the VTK files  <br /></td></tr>
<tr class="separator:a6fc8d031030fe04b455bd92ca32e4d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_extract___from___state_8_f90.html">Extract_From_State.F90</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
