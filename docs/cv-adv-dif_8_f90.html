<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICFERST: /home/mbahlali/Softwares/multifluids_icferst/ICFERST/src/cv-adv-dif.F90 File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="IC_FERST_Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ICFERST<span id="projectnumber">&#160;25-11</span>
   </div>
   <div id="projectbrief">Reservoir simulator based on DCVFEM, Dynamic Mesh optimisation and Surface-based modelling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('cv-adv-dif_8_f90.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#namespaces">Modules</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">cv-adv-dif.F90 File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;fdebug.h&quot;</code><br />
<code>#include &quot;petsc_legacy.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cv-adv-dif.F90:</div>
<div class="dyncontent">
<div class="center"><img src="cv-adv-dif_8_f90__incl.png" border="0" usemap="#a_2home_2mbahlali_2_softwares_2multifluids__icferst_2_i_c_f_e_r_s_t_2src_2cv-adv-dif_8_f90" alt=""/></div>
<map name="a_2home_2mbahlali_2_softwares_2multifluids__icferst_2_i_c_f_e_r_s_t_2src_2cv-adv-dif_8_f90" id="a_2home_2mbahlali_2_softwares_2multifluids__icferst_2_i_c_f_e_r_s_t_2src_2cv-adv-dif_8_f90">
<area shape="rect" title=" " alt="" coords="5,5,207,60"/>
<area shape="rect" title=" " alt="" coords="5,108,84,133"/>
<area shape="poly" title=" " alt="" coords="89,62,63,98,59,95,85,59"/>
<area shape="rect" title=" " alt="" coords="109,108,226,133"/>
<area shape="poly" title=" " alt="" coords="127,59,153,95,149,98,123,62"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecv__advection_1_1dg__derivs__all.html">cv_advection::dg_derivs_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates derivatives of vector fields  <a href="interfacecv__advection_1_1dg__derivs__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacecv__advection_1_1pack__loc__all.html">cv_advection::pack_loc_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs field together to be later on used for high order computations.  <a href="interfacecv__advection_1_1pack__loc__all.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Modules</h2></td></tr>
<tr class="memitem:namespacecv__advection" id="r_namespacecv__advection"><td class="memItemLeft" align="right" valign="top">module &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html">cv_advection</a></td></tr>
<tr class="memdesc:namespacecv__advection"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module contains all the tools to assemble and solve the equations and fields associated with the CV mesh, i.e. transport equation, continuity equation, DCVFE gradient matrix and the Laplacian system for the zeta-potential. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a3bd456f4f3d098a36288e7ed4a6dbf6b" id="r_a3bd456f4f3d098a36288e7ed4a6dbf6b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a3bd456f4f3d098a36288e7ed4a6dbf6b">cv_advection::cv_assemb</a> (state, packed_state, final_phase, mdims, cv_gidims, cv_funs, mspars, ndgln, mdisopt, mmat, upwnd, tracer, velocity, density, multi_absorp, diag_scale_pres, diag_scale_pres_coup, inv_b, den_all, denold_all, cv_disopt, cv_dg_vel_int_opt, dt, cv_theta, cv_beta, suf_sig_diagten_bc, deriv, cv_p, sourct_all, absorbt_all, volfra_pore, volfra_pore_total, getcv_disc, getct, igot_t2, igot_theta_flux, get_theta_flux, use_theta_flux, theta_flux, one_m_theta_flux, theta_flux_j, one_m_theta_flux_j, theta_gdiff, mean_pore_cv, mean_pore_cv_total, mass_mn_pres, thermal, got_free_surf, mass_suf, mass_ele_transp, tdiffusion, saturation, vad_parameter, phase_with_pc, courant_number, permeability_tensor_field, calculate_mass_delta, eles_with_pipe, pipes_aux, porous_heat_coef, porous_heat_coef_old, outfluxes, solving_compositional, nonlinear_iteration, assemble_collapsed_to_one_phase)</td></tr>
<tr class="memdesc:a3bd456f4f3d098a36288e7ed4a6dbf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutines generates the transport equation for a cv field. It also can generate the Continuity equation if GETCT = .true. and also generate the gradient matrix of the momentum equation for the DCVFE method if the option is activated.  <br /></td></tr>
<tr class="separator:a3bd456f4f3d098a36288e7ed4a6dbf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb08147b461c9b4e619c6a4afd37a68" id="r_aeeb08147b461c9b4e619c6a4afd37a68"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#aeeb08147b461c9b4e619c6a4afd37a68">cv_advection::onvdlim_ano_many</a> (nfield, tdlim, tdcen, income, etdnew_pele, etdnew_peleot, xi_limit, tupwin, tupwi2, denoin, ctilin, denoou, ctilou, ftilin, ftilou)</td></tr>
<tr class="memdesc:aeeb08147b461c9b4e619c6a4afd37a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sub calculates the limited face values TDADJ(1...SNGI) from the central difference face values TDCEN(1...SNGI) using a NVD shceme. INCOME(1...SNGI)=1 for incomming to element ELE else =0. LIBETA is the flux limiting parameter. TDMAX(PELE)=maximum of the surrounding 6 element values of element PELE. TDMIN(PELE)=minimum of the surrounding 6 element values of element PELE. PELEOT=element at other side of current face. ELEOT2=element at other side of the element ELEOTH. ELESID=element next to oposing current face. DENOIN, CTILIN, DENOOU, CTILOU, FTILIN, FTILOU =&gt; memory The elements are arranged in this order: ELEOT2,ELE, PELEOT, ELESID.  <br /></td></tr>
<tr class="separator:aeeb08147b461c9b4e619c6a4afd37a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0beda955985765258aade53af3d1fb" id="r_a6e0beda955985765258aade53af3d1fb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a6e0beda955985765258aade53af3d1fb">cv_advection::is_field_constant</a> (igot_t_const, igot_t_const_value, t_all, cv_nonods)</td></tr>
<tr class="memdesc:a6e0beda955985765258aade53af3d1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a field is constant or not. Although I think this check is terrible, no alternatives have provided the same functionality so far.  <br /></td></tr>
<tr class="separator:a6e0beda955985765258aade53af3d1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad3a63555367e6c0022730a76bb7df5" id="r_a6ad3a63555367e6c0022730a76bb7df5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a6ad3a63555367e6c0022730a76bb7df5">cv_advection::pack_loc</a> (loc_f, t_all, nphase, ipt, igot_t_pack)</td></tr>
<tr class="memdesc:a6ad3a63555367e6c0022730a76bb7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies memory into the same large array to then perform a projection from CV to FE.  <br /></td></tr>
<tr class="separator:a6ad3a63555367e6c0022730a76bb7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e58766834b93ab43ae7a753e699a9da" id="r_a9e58766834b93ab43ae7a753e699a9da"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a9e58766834b93ab43ae7a753e699a9da">cv_advection::unpack_loc</a> (loc_f, t_all, nphase, ipt, igot_t_pack, igot_t_const, igot_t_const_value)</td></tr>
<tr class="memdesc:a9e58766834b93ab43ae7a753e699a9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">If PACK then UNpack loc_f into T_ALL as long at IGOT_T==1 and STORE and not already in storage.  <br /></td></tr>
<tr class="separator:a9e58766834b93ab43ae7a753e699a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ccfb76c0376157c7a4446fbe4f7362" id="r_ae1ccfb76c0376157c7a4446fbe4f7362"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#ae1ccfb76c0376157c7a4446fbe4f7362">cv_advection::pack_or_unpack_loc</a> (loc_f, t_all, nphase, nfield, ipt, pack, store, igot_t)</td></tr>
<tr class="memdesc:ae1ccfb76c0376157c7a4446fbe4f7362"><td class="mdescLeft">&#160;</td><td class="mdescRight">If PACK then pack T_ALL into LOC_F as long at IGOT_T==1 and STORE and not already in storage.  <br /></td></tr>
<tr class="separator:ae1ccfb76c0376157c7a4446fbe4f7362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1d3d050b9d6e3a460a5e33481a2317" id="r_a5c1d3d050b9d6e3a460a5e33481a2317"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a5c1d3d050b9d6e3a460a5e33481a2317">cv_advection::pack_loc_all1</a> (loc_f, field1, oldfield1, field2, oldfield2, field3, oldfield3, igot_t_pack, use_volume_frac_t2, nfield)</td></tr>
<tr class="memdesc:a5c1d3d050b9d6e3a460a5e33481a2317"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine is for fields that have already size final_phase - 1 Checks if the fields are constant or not, stored in IGOT_T_PACK, based on that introduces the field into LOC_F to later on apply the limiters on all the fields at once.  <br /></td></tr>
<tr class="separator:a5c1d3d050b9d6e3a460a5e33481a2317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683fbf63598344fcda6fd591c09f5133" id="r_a683fbf63598344fcda6fd591c09f5133"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a683fbf63598344fcda6fd591c09f5133">cv_advection::pack_loc_all2</a> (loc_f, field1, oldfield1, field2, oldfield2, field3, oldfield3, igot_t_pack, use_volume_frac_t2, start_phase, final_phase, nodi)</td></tr>
<tr class="memdesc:a683fbf63598344fcda6fd591c09f5133"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subrotuine is for fields that are bigger than final_phase - start_phase Checks if the fields are constant or not, stored in IGOT_T_PACK, based on that introduces the field into LOC_F to later on apply the limiters on all the fields at once.  <br /></td></tr>
<tr class="separator:a683fbf63598344fcda6fd591c09f5133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdd2647306a5d499b80ba8edc89bb93" id="r_aebdd2647306a5d499b80ba8edc89bb93"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#aebdd2647306a5d499b80ba8edc89bb93">cv_advection::pack_loc_all3</a> (loc_f, field1, oldfield1, field2, oldfield2, field3, oldfield3, igot_t_pack, use_volume_frac_t2, start_phase, final_phase, nodi)</td></tr>
<tr class="memdesc:aebdd2647306a5d499b80ba8edc89bb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subrotuine is for fields that are bigger than final_phase - start_phase Checks if the fields are constant or not, stored in IGOT_T_PACK, based on that introduces the field into LOC_F to later on apply the limiters on all the fields at once. This one is for integer fields.  <br /></td></tr>
<tr class="separator:aebdd2647306a5d499b80ba8edc89bb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d87f487367930256a65aba57352cba8" id="r_a4d87f487367930256a65aba57352cba8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a4d87f487367930256a65aba57352cba8">cv_advection::i_pack_loc</a> (loc_f, t_all, nphase, ipt, igot_t_pack)</td></tr>
<tr class="memdesc:a4d87f487367930256a65aba57352cba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If PACK then pack T_ALL into LOC_F as long at IGOT_T==1 and STORE and not already in storage.  <br /></td></tr>
<tr class="separator:a4d87f487367930256a65aba57352cba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203f402aedd9fec9cade1641c093c169" id="r_a203f402aedd9fec9cade1641c093c169"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a203f402aedd9fec9cade1641c093c169">cv_advection::unpack_loc_all</a> (loc_f, field1, oldfield1, field2, oldfield2, field3, oldfield3, igot_t_pack, igot_t_const, igot_t_const_value, use_volume_frac_t2, nfield)</td></tr>
<tr class="memdesc:a203f402aedd9fec9cade1641c093c169"><td class="mdescLeft">&#160;</td><td class="mdescRight">If PACK then UNpack loc_f into T_ALL as long at IGOT_T==1 and STORE and not already in storage. Checks if the fields are constant or not, stored in IGOT_T_PACK, based on that introduces the LOC_F into the field or use a constant value. This is after the limiters have been applied.  <br /></td></tr>
<tr class="separator:a203f402aedd9fec9cade1641c093c169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaca115c05985fed5f9376ecce181d7" id="r_a6eaca115c05985fed5f9376ecce181d7"><td class="memItemLeft" align="right" valign="top">integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a6eaca115c05985fed5f9376ecce181d7">cv_advection::cv_count_faces</a> (mdims, cv_ele_type, cv_gidims)</td></tr>
<tr class="memdesc:a6eaca115c05985fed5f9376ecce181d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine counts then number of faces in the control volume space.  <br /></td></tr>
<tr class="separator:a6eaca115c05985fed5f9376ecce181d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b98e24eaf8dd45300f3c4b1c86fce" id="r_aa75b98e24eaf8dd45300f3c4b1c86fce"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#aa75b98e24eaf8dd45300f3c4b1c86fce">cv_advection::find_other_side_fast</a> (cv_other_loc, cv_nloc, integrat_at_gi, x_nloc, x_ndgln, cv_snloc, cvfem_on_face, x_share, ele, ele2, finele, colele, distcontinuous_method)</td></tr>
<tr class="memdesc:aa75b98e24eaf8dd45300f3c4b1c86fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are on the boundary or next to another element. Determine CV_OTHER_LOC CVFEM_ON_FACE(CV_KLOC,GI)=.TRUE. if CV_KLOC is on the face that GI is centred on. Look for these nodes on the other elements. ELE2=0 also when we are between elements but are trying to integrate across the middle of a CV.  <br /></td></tr>
<tr class="separator:aa75b98e24eaf8dd45300f3c4b1c86fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72902394525a29d241353d21af94ec81" id="r_a72902394525a29d241353d21af94ec81"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a72902394525a29d241353d21af94ec81">cv_advection::find_other_side</a> (cv_other_loc, cv_nloc, u_other_loc, u_nloc, mat_other_loc, integrat_at_gi, x_nloc, xu_nloc, x_ndgln, xu_ndgln, cv_snloc, cvfem_on_face, x_share, ele, ele2, finele, colele, distcontinuous_method)</td></tr>
<tr class="memdesc:a72902394525a29d241353d21af94ec81"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are on the boundary or next to another element. Determine CV_OTHER_LOC, U_OTHER_LOC. CVFEM_ON_FACE(CV_KLOC,GI)=.TRUE. if CV_KLOC is on the face that GI is centred on. Look for these nodes on the other elements. ELE2=0 also when we are between elements but are trying to integrate across the middle of a CV.  <br /></td></tr>
<tr class="separator:a72902394525a29d241353d21af94ec81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae53b6e2d75f63d1a426e6f3534d1d7" id="r_a1ae53b6e2d75f63d1a426e6f3534d1d7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a1ae53b6e2d75f63d1a426e6f3534d1d7">cv_advection::proj_cv_to_fem</a> (packed_state, fempsi, psi, mdims, cv_gidims, cv_funs, mspars, ndgln, igetct, x, mass_ele, mass_mn_pres, tracer, psi_ave, psi_int, activate_limiters)</td></tr>
<tr class="memdesc:a1ae53b6e2d75f63d1a426e6f3534d1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls to generate the transport equation for the saturation. Embeded an FPI with backtracking method is uncluded Subroutine description: (1) determine FEMT (finite element wise) etc from T (control volume wise) (2) (optional) calculate psi_int (area) and psi_ave (barycentre) over each CV.  <br /></td></tr>
<tr class="separator:a1ae53b6e2d75f63d1a426e6f3534d1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ad0b9f86ac7e85559962a298a834b" id="r_a548ad0b9f86ac7e85559962a298a834b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a548ad0b9f86ac7e85559962a298a834b">cv_advection::dg_derivs_all1</a> (femt, femtold, dtx_ele, dtoldx_ele, ndim, nphase, ncomp, totele, cv_ndgln, xcv_ndgln, x_nloc, x_ndgln, cv_ngi, cv_nloc, cvweight, n, nlx, nly, nlz, x_n, x_nlx, x_nly, x_nlz, x_nonods, x, y, z, nface, face_ele, cv_sloclist, x_sloclist, cv_snloc, x_snloc, wic_t_bc, suf_t_bc, sbcvngi, sbcvfen, sbweigh, x_sbcvfen, x_sbcvfenslx, x_sbcvfensly, get_gradu, state, p0mesh)</td></tr>
<tr class="memdesc:a548ad0b9f86ac7e85559962a298a834b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates derivatives of vector fields  <br /></td></tr>
<tr class="separator:a548ad0b9f86ac7e85559962a298a834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de8526f025c7830c8e53ac5060b540e" id="r_a1de8526f025c7830c8e53ac5060b540e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a1de8526f025c7830c8e53ac5060b540e">cv_advection::dg_derivs_all2</a> (femt, femtold, dtx_ele, dtoldx_ele, ndim, nphase, totele, cv_ndgln, xcv_ndgln, x_nloc, x_ndgln, cv_ngi, cv_nloc, cvweight, n, nlx, nly, nlz, x_n, x_nlx, x_nly, x_nlz, x_nonods, x, y, z, nface, face_ele, cv_sloclist, x_sloclist, cv_snloc, x_snloc, wic_t_bc, suf_t_bc, sbcvngi, sbcvfen, sbweigh, x_sbcvfen, x_sbcvfenslx, x_sbcvfensly, p0mesh)</td></tr>
<tr class="memdesc:a1de8526f025c7830c8e53ac5060b540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivatives of vector fields.  <br /></td></tr>
<tr class="separator:a1de8526f025c7830c8e53ac5060b540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c099f85979288a8bda06b0dbf65ce4b" id="r_a6c099f85979288a8bda06b0dbf65ce4b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a6c099f85979288a8bda06b0dbf65ce4b">cv_advection::diffus_cal_coeff</a> (diff_coef_divdx, diff_coefold_divdx, cv_nloc, mat_nloc, nphase, mat_ndgln, smatfen, scvfen, gi, ndim, tdiffusion, hdc, t_cv_nodj, t_cv_nodi, told_cv_nodj, told_cv_nodi, ele, ele2, cvnormx_all, loc_dtx_ele_all, loc_dtoldx_ele_all, loc2_dtx_ele_all, loc2_dtoldx_ele_all, loc_wic_t_bc, cv_other_loc, mat_other_loc, cv_snloc, cv_sloc2loc, on_domain_boundary, between_elements, has_anisotropic_diffusivity)</td></tr>
<tr class="memdesc:a6c099f85979288a8bda06b0dbf65ce4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sub calculates the effective diffusion coefficientd DIFF_COEF_DIVDX, DIFF_COEFOLD_DIVDX based on a non-linear method and a non-oscillating scheme. It requires the derivatives of the field obtained using DG_DERIVS_ALL DG_DERIVS_ALL.  <br /></td></tr>
<tr class="separator:a6c099f85979288a8bda06b0dbf65ce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef6c88c50d350a8f4a9be0191a1f0c0" id="r_abef6c88c50d350a8f4a9be0191a1f0c0"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#abef6c88c50d350a8f4a9be0191a1f0c0">cv_advection::linear_high_diffus_cal_coeff_stress_or_tensor</a> (stress_ij_ele_ext, s_inv_nnx_mat12, stress_form, stress_form_stab, zero_or_two_thirds, u_snloc, u_nloc, cv_snloc, nphase, sbufen_reversed, sbcvfen_reversed, sdetwei, sbcvngi, ndim, sloc_udiffusion, sloc_udiffusion_vol, sloc2_udiffusion, sloc2_udiffusion_vol, diff_gi_added, on_boundary, snormxn_all)</td></tr>
<tr class="memdesc:abef6c88c50d350a8f4a9be0191a1f0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sub calculates the effective diffusion coefficientd STRESS_IJ_ELE_EXT it only works for between element contributions. based on a high order scheme. The matrix S_INV_NNX_MAT12 is used to calculate the rows of the matrix with STRESS_IJ_ELE_EXT. This implements the stress and tensor form of diffusion and calculates a jump conidition. which is in DIFF_COEF_DIVDX, DIFF_COEFOLD_DIVDX The coefficient are in N_DOT_DKDU, N_DOT_DKDUOLD. look at the manual DG treatment of viscocity.  <br /></td></tr>
<tr class="separator:abef6c88c50d350a8f4a9be0191a1f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ba4bc947f32d4cea21ddc4cef46033" id="r_ae7ba4bc947f32d4cea21ddc4cef46033"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#ae7ba4bc947f32d4cea21ddc4cef46033">cv_advection::calc_stress_ten</a> (stress_ij, zero_or_two_thirds, ndim, ufenx_iloc, ufenx_jloc, ten_xx, ten_vol)</td></tr>
<tr class="memdesc:ae7ba4bc947f32d4cea21ddc4cef46033"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine stress form of viscocity...  <br /></td></tr>
<tr class="separator:ae7ba4bc947f32d4cea21ddc4cef46033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ebab4afe58323322b98d8539e18ff8" id="r_a84ebab4afe58323322b98d8539e18ff8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a84ebab4afe58323322b98d8539e18ff8">cv_advection::calc_stress_ten_reduce</a> (stress_ij, zero_or_two_thirds, ndim, fen_ten_xx, fen_ten_vol, ufenx_jloc)</td></tr>
<tr class="memdesc:a84ebab4afe58323322b98d8539e18ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine stress form of viscocity...  <br /></td></tr>
<tr class="separator:a84ebab4afe58323322b98d8539e18ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413ef4bcb969bf21f6beb7aba061e8e" id="r_a7413ef4bcb969bf21f6beb7aba061e8e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a7413ef4bcb969bf21f6beb7aba061e8e">cv_advection::cal_lim_vol_adjust</a> (tmin_store, tmin, t, tmin_nod, reset_store, mass_cv, cv_nodi_ipha, cv_nodj_ipha, iphase, cv_nonods, income)</td></tr>
<tr class="memdesc:a7413ef4bcb969bf21f6beb7aba061e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust TMIN to take into account different sized CV's. if RESET_STORE then reset TMIN to orginal values.  <br /></td></tr>
<tr class="separator:a7413ef4bcb969bf21f6beb7aba061e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24da0795bb0073e26720f411ded816b6" id="r_a24da0795bb0073e26720f411ded816b6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a24da0795bb0073e26720f411ded816b6">cv_advection::dgsimplnorm_all</a> (nloc, snloc, ndim, xl_all, xsl_all, normx_all)</td></tr>
<tr class="memdesc:a24da0795bb0073e26720f411ded816b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form approximate surface normal (NORMX_ALL(1),NORMX_ALL(2),NORMX_ALL(3))  <br /></td></tr>
<tr class="separator:a24da0795bb0073e26720f411ded816b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4f6cf3db5049a9a7f73a113bea3921" id="r_adf4f6cf3db5049a9a7f73a113bea3921"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#adf4f6cf3db5049a9a7f73a113bea3921">cv_advection::dgsimplnorm</a> (ele, siloc2iloc, nloc, snloc, xondgl, x, y, z, normx, normy, normz)</td></tr>
<tr class="memdesc:adf4f6cf3db5049a9a7f73a113bea3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form approximate surface normal (NORMX,NORMY,NORMZ)  <br /></td></tr>
<tr class="separator:adf4f6cf3db5049a9a7f73a113bea3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af4784ad37e42f3ede076507c5704bb" id="r_a3af4784ad37e42f3ede076507c5704bb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a3af4784ad37e42f3ede076507c5704bb">cv_advection::isotropic_limiter_all</a> (t_all, told_all, t2_all, t2old_all, den_all, denold_all, igot_t2, nphase, cv_nonods, nsmall_colm, small_centrm, small_findrm, small_colm, stotel, cv_snloc, cv_sndgln, suf_t_bc_all, suf_t2_bc_all, suf_d_bc_all, wic_t_bc_all, wic_t2_bc_all, wic_d_bc_all, mass_cv, toldupwind_mat_all, denoldupwind_mat_all, t2oldupwind_mat_all, tupwind_mat_all, denupwind_mat_all, t2upwind_mat_all)</td></tr>
<tr class="memdesc:a3af4784ad37e42f3ede076507c5704bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the limited values at the interface, not as generic as the anisotropic one and never used actually...  <br /></td></tr>
<tr class="separator:a3af4784ad37e42f3ede076507c5704bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb89cd41fa936c21d77e9277c24ff38" id="r_a8eb89cd41fa936c21d77e9277c24ff38"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a8eb89cd41fa936c21d77e9277c24ff38">cv_advection::calc_sele</a> (ele, ele3, sele, cv_siloc, cv_iloc, u_sloc2loc, cv_sloc2loc, face_ele, gi, cv_funs, mdims, cv_gidims, cv_ndgln, u_ndgln, cv_sndgln, u_sndgln)</td></tr>
<tr class="memdesc:a8eb89cd41fa936c21d77e9277c24ff38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate surface element, surface control volume: SELE, CV_SILOC, U_SLOC2LOC, CV_SLOC2LOC for a face on the boundary of the domain.  <br /></td></tr>
<tr class="separator:a8eb89cd41fa936c21d77e9277c24ff38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca35d740c637f0177d867e8a10cec8ef" id="r_aca35d740c637f0177d867e8a10cec8ef"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#aca35d740c637f0177d867e8a10cec8ef">cv_advection::put_in_ct_rhs</a> (get_c_in_cv_advdif_and_calc_c_cv, ct_rhs_phase_cv_nodi, ct_rhs_phase_cv_nodj, final_phase, mdims, cv_funs, ndgln, mmat, gi, between_elements, on_domain_boundary, ele, ele2, sele, hdc, mass_ele, jcount_kloc, jcount_kloc2, icount_kloc, icount_kloc2, c_jcount_kloc, c_jcount_kloc2, c_icount_kloc, c_icount_kloc2, u_other_loc, u_sloc2loc, cv_sloc2loc, scvdetwei, cvnormx_all, den_all, cv_nodi, cv_nodj, wic_u_bc_all, wic_p_bc_all, suf_p_bc_all, ugi_coef_ele_all, ugi_coef_ele2_all, ndotq, ndotqold, limt, limdt, limdtold, limt_hat, ndotq_hat, ftheta_t2, one_m_ftheta_t2old, ftheta_t2_j, one_m_ftheta_t2old_j, integrate_other_side_and_not_boundary, loc_u, theta_vel, udgi_imp_all, rcon, rcon_j, ndotq_imp, x_all, suf_d_bc_all, gravty)</td></tr>
<tr class="memdesc:aca35d740c637f0177d867e8a10cec8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine caculates the discretised cty eqn acting on the velocities i.e. MmatCT, MmatCT_RHS It also computes the gradient matrix using the DCVFE method.  <br /></td></tr>
<tr class="separator:aca35d740c637f0177d867e8a10cec8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9fcfd8bbef480150a7ebc72fccacff" id="r_a9b9fcfd8bbef480150a7ebc72fccacff"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a9b9fcfd8bbef480150a7ebc72fccacff">cv_advection::calc_anisotrop_lim</a> (mmat, t_all, told_all, den_all, denold_all, t2_all, t2old_all, femt_all, femtold_all, femden_all, femdenold_all, femt2_all, femt2old_all, use_femt, tupwind_mat_all, toldupwind_mat_all, denupwind_mat_all, denoldupwind_mat_all, t2upwind_mat_all, t2oldupwind_mat_all, igot_t2, nphase, cv_nonods, cv_nloc, totele, cv_ndgln, small_findrm, small_centrm, small_colm, nsmall_colm, x_ndgln, x_nonods, ndim, x_all, xc_cv_all, use_reflect)</td></tr>
<tr class="memdesc:a9b9fcfd8bbef480150a7ebc72fccacff"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the anisotropic limiting scheme we find the upwind values by interpolation using the subroutine FINPTS or IFINPTS; the upwind value for each node pair is stored in the matrices TUPWIND AND.  <br /></td></tr>
<tr class="separator:a9b9fcfd8bbef480150a7ebc72fccacff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796bc5ddad90b88fcb185a3fc5da03ba" id="r_a796bc5ddad90b88fcb185a3fc5da03ba"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a796bc5ddad90b88fcb185a3fc5da03ba">cv_advection::triloccords</a> (xp, yp, zp, n1, n2, n3, n4, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)</td></tr>
<tr class="separator:a796bc5ddad90b88fcb185a3fc5da03ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bc7cfcb7c297d93ce7edd0658eeb22" id="r_a19bc7cfcb7c297d93ce7edd0658eeb22"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a19bc7cfcb7c297d93ce7edd0658eeb22">cv_advection::triloccords2d</a> (xp, yp, n1, n2, n3, x1, y1, x2, y2, x3, y3)</td></tr>
<tr class="separator:a19bc7cfcb7c297d93ce7edd0658eeb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc50adcb66253565fe9c7a83244430a7" id="r_afc50adcb66253565fe9c7a83244430a7"><td class="memItemLeft" align="right" valign="top">logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#afc50adcb66253565fe9c7a83244430a7">cv_advection::shock_front_in_ele</a> (ele, mdims, sat, ndgln, imble_frac)</td></tr>
<tr class="memdesc:afc50adcb66253565fe9c7a83244430a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the element has a shockfront or not.  <br /></td></tr>
<tr class="separator:afc50adcb66253565fe9c7a83244430a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e92f04a2ef0257a47a96daebf15cbb5" id="r_a8e92f04a2ef0257a47a96daebf15cbb5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a8e92f04a2ef0257a47a96daebf15cbb5">cv_advection::generate_laplacian_system</a> (mdims, packed_state, ndgln, mmat, mspars, cv_funs, cv_gidims, sigma_field, solution, k_fields, f_fields, intface_val_type)</td></tr>
<tr class="memdesc:a8e92f04a2ef0257a47a96daebf15cbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">: In this method we assemble and solve the Laplacian system using at least P1 elements The equation solved is the following: Div sigma Grad X = - SUM (Div K Grad F) with Neuman BCs = 0 where K and F are passed down as a vector. Therefore for n entries the SUM will be performed over n fields Example: F = (3, nphase, cv_nonods) would include three terms in the RHS and the same for K If harmonic average then we perform the harmonic average of sigma and K IMPORTANT: This subroutine requires the PHsparsity to be generated Note that this method solves considering FE fields. If using CV you may incur in an small error.  <br /></td></tr>
<tr class="separator:a8e92f04a2ef0257a47a96daebf15cbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543dc448a797694ce8751b3a8cfdde3" id="r_aa543dc448a797694ce8751b3a8cfdde3"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#aa543dc448a797694ce8751b3a8cfdde3">cv_advection::scvdetnx</a> (mdims, ndgln, x_all, cv_funs, cv_gidims, on_domain_boundary, between_elements, ele, gi, scvdetwei, cvnormx_all, xc_all, x_nod, x_nodj)</td></tr>
<tr class="separator:aa543dc448a797694ce8751b3a8cfdde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32f5ce0d6f82490258e5b7e6a49380e" id="r_ae32f5ce0d6f82490258e5b7e6a49380e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#ae32f5ce0d6f82490258e5b7e6a49380e">cv_advection::saturation_assemb</a> (petsc_acv, state, packed_state, final_phase, mdims, cv_gidims, cv_funs, mspars, ndgln, mdisopt, mmat, upwnd, saturation, sat_prev, velocity, density, den_all, denold_all, dt, suf_sig_diagten_bc, cv_p, sourct_all, volfra_pore, vad_parameter, phase_with_pc, eles_with_pipe, pipes_aux, assemble_collapsed_to_one_phase, getresidual)</td></tr>
<tr class="separator:ae32f5ce0d6f82490258e5b7e6a49380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a939c43361c098c807280c739e30b5370" id="r_a939c43361c098c807280c739e30b5370"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a939c43361c098c807280c739e30b5370">cv_advection::wic_t_bc_dirichlet</a> = 1</td></tr>
<tr class="separator:a939c43361c098c807280c739e30b5370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f50cabe5b0bcd1018205e2d6f15f3ff" id="r_a8f50cabe5b0bcd1018205e2d6f15f3ff"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a8f50cabe5b0bcd1018205e2d6f15f3ff">cv_advection::wic_t_bc_robin</a> = 2</td></tr>
<tr class="separator:a8f50cabe5b0bcd1018205e2d6f15f3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29adecab6c33872a56cf4775b4e1c3e3" id="r_a29adecab6c33872a56cf4775b4e1c3e3"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a29adecab6c33872a56cf4775b4e1c3e3">cv_advection::wic_t_bc_diri_adv_and_robin</a> = 3</td></tr>
<tr class="separator:a29adecab6c33872a56cf4775b4e1c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa646dbddd6308ea78c1c05d5b51c4d22" id="r_aa646dbddd6308ea78c1c05d5b51c4d22"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#aa646dbddd6308ea78c1c05d5b51c4d22">cv_advection::wic_d_bc_dirichlet</a> = 1</td></tr>
<tr class="separator:aa646dbddd6308ea78c1c05d5b51c4d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb6fac2898be0cae2d603d5226f631" id="r_a7ceb6fac2898be0cae2d603d5226f631"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a7ceb6fac2898be0cae2d603d5226f631">cv_advection::wic_u_bc_dirichlet</a> = 1</td></tr>
<tr class="separator:a7ceb6fac2898be0cae2d603d5226f631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6309cc2d2e0e51146784619230b6e70a" id="r_a6309cc2d2e0e51146784619230b6e70a"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a6309cc2d2e0e51146784619230b6e70a">cv_advection::wic_u_bc_robin</a> = 2</td></tr>
<tr class="separator:a6309cc2d2e0e51146784619230b6e70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87709ec60fd78f0870ce18b9bbf7eb8" id="r_ab87709ec60fd78f0870ce18b9bbf7eb8"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#ab87709ec60fd78f0870ce18b9bbf7eb8">cv_advection::wic_u_bc_diri_adv_and_robin</a> = 3</td></tr>
<tr class="separator:ab87709ec60fd78f0870ce18b9bbf7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03129ee41533b2c78d1ec116019892fa" id="r_a03129ee41533b2c78d1ec116019892fa"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a03129ee41533b2c78d1ec116019892fa">cv_advection::wic_u_bc_dirichlet_inout</a> = 2</td></tr>
<tr class="separator:a03129ee41533b2c78d1ec116019892fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03647ce996f35f7512f2206c2a4bc8d4" id="r_a03647ce996f35f7512f2206c2a4bc8d4"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a03647ce996f35f7512f2206c2a4bc8d4">cv_advection::wic_p_bc_dirichlet</a> = 1</td></tr>
<tr class="separator:a03647ce996f35f7512f2206c2a4bc8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d139b0bd7722182c16855e683657878" id="r_a6d139b0bd7722182c16855e683657878"><td class="memItemLeft" align="right" valign="top">integer, parameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecv__advection.html#a6d139b0bd7722182c16855e683657878">cv_advection::wic_p_bc_free</a> = 2</td></tr>
<tr class="separator:a6d139b0bd7722182c16855e683657878"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="cv-adv-dif_8_f90.html">cv-adv-dif.F90</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
