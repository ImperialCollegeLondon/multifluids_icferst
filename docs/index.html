<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICFERST: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="IC_FERST_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICFERST
   &#160;<span id="projectnumber">22-07</span>
   </div>
   <div id="projectbrief">Reservoir simulator based on DCVFEM, Dynamic Mesh optimisation and Surface-based modelling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ReadMe"></a>
ReadMe</h1>
<p>(This text is in <a class="el" href="_multiphase___prototype___wrapper_8_f90.html">Multiphase_Prototype_Wrapper.F90</a>)</p>
<p>All the contributions to ICFERST in this repository are under AGPL 3.0 license, otherwise refrain from commiting your code to this repository. Each library keeps their original license.</p>
<p>The executable is named icferst</p>
<p>The schema for the ICFERST diamond interface is in ICFERST/schemas/multiphase.rmg</p>
<p>For compilation run the command from the root folder:  
 <CODE>
 <PRE>
./configure --enable-2d-adaptivity && make mp!> </PRE>
 </CODE>
 </p>
<p>ICFERST is property of the NORMS group. See the file COPYRIGHT for a description of the copyright.</p>
<p>For more details please see: <a href="http://multifluids.github.io/">http://multifluids.github.io/</a> or <a href="http://www.imperial.ac.uk/earth-science/research/research-groups/norms/">http://www.imperial.ac.uk/earth-science/research/research-groups/norms/</a></p>
<h1><a class="anchor" id="install_sec"></a>
Installation</h1>
<p>1) Download it from github with the following one-line command  
 <CODE>
 <PRE>
 mkdir ICFERST && cd ICFERST && git init && git remote add -t  main  -f origin git@github.com:Multifluids/icferst.git && git checkout main
 </PRE>
 </CODE>
 </p>
<p>2) Install dependencies  
 <CODE>
 <PRE>
 sudo apt-add-repository ppa:fluidity-core/ppa
 sudo apt-get update
 sudo apt-get install fluidity-dev
 </PRE>
 </CODE>
 </p>
<p>3a) Ubuntu 18.04, modify the .bashrc file in home to include  
 <CODE>
 <PRE>
 export PETSC_DIR=/usr/lib/petscdir/3.8.3
 </PRE>
 </CODE>
 </p>
<p>3b) Ubuntu 20.04, modify the .bashrc file in home to include  
 <CODE>
 <PRE>
 export FCFLAGS="-I/usr/include"
 </PRE>
 </CODE>
 </p>
<p>3b) You may need to explicitly include the python dependencies  
 <CODE>
 <PRE>
 export PYTHONPATH=/usr/lib/python3
 </PRE>
 </CODE>
 </p>
<p>4) Navigate to the root directory of your ICFERST folder  
 <CODE>
 <PRE>
 cd IC-FERST-FOLDER/
 sudo ./configure --enable-2d-adaptivity && make install
 </PRE>
 </CODE>
 </p>
<h2><a class="anchor" id="Scripts"></a>
Useful scripts</h2>
<p>Within the folder ICFERST/tools you can find some useful scripts:</p>
<p>1) If detectors are used you can use detectors_and_stat2csv.py to convert the detectors file in the more readable format .csv</p>
<p>2) To convert from Cubit (exodusII) to a mesh type that ICFERST can open (GMSHv2 format) the scripts exodus2gmsh.py (3D) and 2Dexodus2gmsh.py (2D can be used. exodus2gmsh.py can convert directly into binary format</p>
<p>3) Within scripts_to_make_life_easier there are two scripts to be modified and copied (manually) into /usr/bin to make the use of Diamond and ICFERST much easier.</p>
<h1><a class="anchor" id="Formulation"></a>
Formulation</h1>
<p>The formulation of the IC-FERST code is split in:</p>
<p>1) The manual in ICFERST/doc which is outdated but contains a very detailed description of the mathematical formulation</p>
<p>2) Papers published containing the formulation used in IC-FERST:</p>
<ul>
<li>Jackson et al 2015. doi: 10.2118/163633-PA: Overall concept of ICFERST.</li>
<li>Gomes et al 2016. doi: 10.1002/fld.4275: Old discretisation, boundary conditions and high order flux calculation.</li>
<li>Salinas et al 2017a. doi: 10.1002/fld.4357: Non-linear solver with acceleration.</li>
<li>Salinas et al 2017b. doi: 10.1002/fld.4381: New discretisation, the Double Control Volume Finite Element method.</li>
<li>Jacquemyn et al 2018. doi: 10.1007/s11004-018-9764-8: Surface-based modelling (generating models for ICFERST)</li>
<li>Salinas et al 2018a. doi: 10.1016/j.jcp.2017.09.058: Discontinuous formulation.</li>
<li>Salinas et al 2018b. doi: 10.1007/s10596-018-9759-z: Adapt within FPI and problems associated with large Courant numbers and DMO.</li>
<li>Salinas et al 2019. doi: 10.1016/j.cma.2019.07.004: Vanishing artificial diffusion (VAD option in diamond).</li>
<li>Salinas et al 2021. doi: 10.1016/j.geothermics.2021.102089: Well modelling and thermal transport.</li>
<li>Silva et al. 2022. doi: 10.1016/j.cma.2021.113989: Non-linear solver acceleration with Machine Learning.</li>
<li>Regnier et al 2022. doi: 10.1007/s10040-022-02481-w: Aquifer thermal energy storage and well modelling.</li>
<li>Hamzeloo et al 2022. doi: 10.1016/j.advwatres.2022.104189: Tracer modelling and parallel performance.</li>
</ul>
<p>The Fluidity manual contains information about the parts done by Fluidity, such as mesh adaptivity, mesh to mesh interpolation, etc. </p>
<h1><a class="anchor" id="Code_structure"></a>
Structure of the ICFERST code</h1>
<p>All the ICFERST code is within the folder ICFERST where the test cases, code, tools and schemas for diamond are stored. Some parts of Fluidity have been slightly modified but in general the Fluidity code is untouched. ICFERST is composed of two main loops. First, it is the time loop and secondly the non-linear loop, which is a Picard method to deal with non-linearities. The time-loop is defined in the multi_timeloop file. From this subroutine we initialise all the necessary fields and start the non-linear loop, within which all the equations to be solved are being called as blocks. In this way, first the momentum equation and velocity are obtained, next the saturation is transported (which also contains within it another non-linear loop) and then all the other transport equations are being solved.</p>
<p>ICFERST solves the system of equations using a DCVFE formulation, which means that we use two different meshes, a CV mesh and a FE mesh. The CV mesh and associated equations are dealt with in CV_ASSEMB, which for porous media is around 70% of the overall cost. Everything related with the FE mesh is solved for in multi_dyncore However multi_dyncore contains the calls to solve for the different transport equations. So effectively the process is normally time_loop (initialise memory and stuff, including EOS, source terms...) =&gt; multi_dyncore (assemble and solve) =&gt; cv_assemb (assembles the transport equation).</p>
<p>To simplify and standardize the naming of the variables the structures defined in <a class="el" href="namespacemulti__data__types.html" title="This module contains all the ICFERST structures and associated subroutines (allocate/deallocate) Use ...">multi_data_types</a> are used through the code. Normally one or two of those types are created once and used throughout the code, so it is recommended to check in that section what is each variable and use those types either expanding them or creating more.</p>
<h2><a class="anchor" id="code_Diagram"></a>
Code Diagram</h2>
<p> 
 <CODE>
 <PRE>
     ┌─────────────┐     ┌────────────┐    ┌───────────────┐
     │Adapt_state  ├─────┤Adaptivity  ├────┤ Mesh2Mesh int │
     └─────────────┘     │ (assemble) │    └───────────────┘
                         └─────┬──────┘
                               │          ┌────────┐
                               │   ┌──────┤  PETSc │
                               │   │      └────────┘
       ┌─────────────┐   ┌─────┴───┴─┐    ┌───────────────────┐
       │ Read input  ├───┤ Fluidity  ├────┤ Generate vtu files│
       └─────────────┘   │ (femtools)│    │  detectors, stats │
                         └──────┬────┘    └───────────────────┘
        ┌──────────────┐        │                        ┌────────────────────────────────────────────────────┐
        │Populate_state├────────┤                        │multi_phreeqc──────────►Initialise PHREEQCRM        │
        └──────────────┘        │                        │Shape functions────────►CV and FE shape functions   │
                         ┌──────┴─────┐                  │                                                    │
                         │  ICFERST   │ Initialisation   │Multi_data_types ──────►Initialise types and memory │
    ┌───────────────────►│  Timeloop  ├─────────────────►│                                                    │
    │                    │            │  of after adapt  │multi_eos  ───────────► Update EOS and petrophysical│
    │                    └──────┬─────┘                  │                        properties                  │
    │                           │Start non-linear        │Extract from state ────►Read from diamond and       │
    │        ┌─────────────────►│ loop                   │                        adaptive-time-stepping      │
    │        │                  │                        └────────────────────────────────────────────────────┘
    │        │           ┌──────┴───────────┐
    │        │           │Assemble and solve│      ┌───────────────────┐  ┌───────────┐ ┌───────────────────┐
    │        │           │momentum equation ├─────►│  multi_dyncore    ├─►│ cv_assemb ├─► Assemble C and Ct │
    │        │           └──────┬───────────┘      └─┬─────────────────┘  └───────────┘ └───────────────────┘
    │        │                  │                    │    ┌───────────┐
    │        │                  │                    ├───►│Assemble M │
    │        │                  │                    │    ├───────────┴────────────┐     ┌────────────┐
    │        │                  │                    │    │ Solve  (M  C) (u) = (f)├────►│multi_solver│
┌───┴─────┐  │      ┌──────────►│                    └───►│        (Ct Mp)(p)   (g)│     └────────────┘
│ Advance │  │      │           │                         │ Mp/=0 for compressible │
│  time   │  │      │   ┌───────┴────────────┐            └────────────────────────┘
└───┬─────┘  │      │   │If multiphase solve │     ┌─────────────┐        ┌─────────┐   ┌───────────┐
    │        │      │   │transport saturation├────►│multi_dyncore├───────►│cv_assemb│──►│multi_pipes│
    │        │      │   └────────┬───────────┘     └─────┬───────┤        └─────────┘   └───────────┘
    │        │      │ Loop until │                       │  ┌─────────────────────────────┐
    │        │      │ converge   │                       └──┤ solve and backtrack solution│
    │        │      └────────────┤                          └─────────────────────────────┘
    │   ┌────┴───────────┐       │                 ┌─────────────┐
    │   │ Adapt time-step│       │                 │Temperature  ├───────┐
    │   │   size         │       │                 ├─────────────┤       │  ┌─────────────┐  ┌─────────┐   ┌───────────┐
    │   └────┬───────────┘       │                 │Concentration├───────┼─►│multi_dyncore├──►cv_assemb│──►│multi_pipes│
    │        │                   │───────────────► ├─────────────┴───────┤  └────┬────────┘  └─────────┘   └───────────┘
    │        │                   │                 │ActiveTracers/Species├──┐    │   ┌────────────┐
    │        │ Loop until        │                 ├─────────────┬───────┤  │    └──►│solve system│
    │        │ convergence       │                 │Compositional├───────┴──┤        └────────────┘ ┌─────────────────────────┐
    │        └───────────────────┤                 └─────────────┘          └──────────────────────►│PHREEQC Update Species   │
    │                            │                                                                  └─────────────────────────┘ 
    │                            │       ┌──────────────┐       ┌──────────────┐   ┌─────────┐   ┌───────────┐
    │                            ├──────►│PassiveTracers├───────►multi_dyncore ├──►│cv_assemb│──►│multi_pipes│
    │                            │       └──────────────┘       └┬─────────────┘   └─────────┘   └───────────┘
    │                            ├─────────────┐                 │  ┌────────────┐
    │                    ┌───────┴──────────┐  │                 └─►│solve system│
    │                    │  Output vtu      │  │                    └────────────┘
    │                    │         outfluxes│  │
    │                    └───────┬──────────┘  │   ┌──────────────┐
    │                            │             └──►│SelfPotential │
    │                     ┌──────┴────┐            └──────────────┘
    │                     │ Adapt mesh│
    │                     └──────┬────┘
    └────────────────────────────│
                              ┌──┴──┐
                              │ END │
                              └─────┘
 </PRE>
 </CODE>
 </p>
<h2><a class="anchor" id="state_var"></a>
Type of fields and accessing them through state and packed_state</h2>
<p>ICFERST uses two types of structures which are effectively linked lists pointing to either scalar_fields, vector_fields or tensor_fields. The first field is state, which is an array containing as many entries as phases. Within each entry one has all the fields defined in diamond. These fields are the ones that Fluidity "see" and therefore will perform its operations on it, such as computation of statitstics of the field in the .stat file, output it into the .vtu file, perform mesh to mesh interpolation, etc. To access these fields one has to do as follows to extract a scalar field:</p>
<p> 
 <CODE>
 <PRE>
 sfield=>extract_scalar_field(state(iphase),"Density")
 </PRE>
 </CODE>
 </p>
<p>it can be seen that we use the command extract_scalar_field (substitute scalar by vector or tensor depending on the field), then we use its name and we use a type(scalar_field), pointer to point to the memory provided by the function extract_scalar_field. #For more information about scalar_fields, etc. please see the Fluidity manual. As summary, these fields contain its value as sfieldval with as many entries as the ones on the mesh in which the field was initialised. Common fields are: Pressure, Velocity, PhaseVolumeFraction, Temperature and Concentration.</p>
<p>The second field is packed_state. Packed_state contains the same fields as state (at least the prognostic ones) and the memory is actually shared. packed_state however contains the fields as (normally) tensor_fields so all the phases can be accessed naturally. For example for PhaseVolumeFraction we would do as follows:</p>
<p> 
 <CODE>
 <PRE>
 tfield=>extract_tensor_field(packed_state,"PackedPhaseVolumeFraction")
 </PRE>
 </CODE>
 </p>
<p>note that now we are using a tensor_field, we used Packed before the name of the field and packed_state is not an array. The obtained field would have the following entries: tfieldval(ncomp,nphase,CV_nonods), normally ncomp == 1. For velocity it would be: tfieldval(ndim,nphase,CV_nonods). </p>
<h1><a class="anchor" id="how_to_use"></a>
How to use ICFERST</h1>
<p>ICFERST is a dimension agnostic code and therefore it is FUNDAMENTAL that the units used, unless otherwise specified, are the S.I. units to ensure consistency on the results obtained.</p>
<p>The procedure to use IC-FERST is the following:</p>
<p>Generate a model and a mesh =&gt; Set up the physics of the model with diamond =&gt; Run ICFERST =&gt; Examine outputs with Paraview </p><div class="image">
<img src="icferst_workflow.png" alt=""/>
</div>
 <h2><a class="anchor" id="modelgeneration"></a>
Generation of a model</h2>
<p>IC-FERST can currently only read .msh files following the format described by GMSHv2 or GMSHv4. For a model to work with IC-FERST it must be meshed with either triangles in 2D or tetrahedra in 3D. Boundaries must be specified with surface ids and the different material properties must be defined with region IDs following the Surface Based modeling paradigm. Although only the GMSH files can be read, normally Cubit is used to generate the models as it is more powerful and the files exported in ExodusII can easily be converted to GMSHv2 format using the scripts described in <a class="el" href="index.html#Scripts">Useful scripts</a> </p>
<h2><a class="anchor" id="wellmodelling"></a>
Wells in ICFERST</h2>
<p>To model wells, it is necessary to define a line that describe the well path. As ICFERST cannot respect 1D lines when adapting the mesh, normally this is achieved by generating a well-sleeve composed of three regions whose central connection represents the well path. In this way we ensure that mesh adaptivity will respect the well path and also ensures a minimum precision around the well. To provide the well path to ICFERST there are two alternatives:</p>
<p>1) Generate a nastran (.bdf) file per well describing the well path with nodes and edges.</p>
<p>2) If the well is a straight line then only by defining the top and bottom coordinates are enough. </p>
<h3><a class="anchor" id="well_prop"></a>
Well properties in Diamond</h3>
<p>Under the section /porous_media/wells_and_pipes the user can find all the required fields that can be modified to set up a simulation with wells. The wells consider a modified Darcy equation to model flow within the pipes, meaning that we are solving the flow within the pipe. To set up a well the user must define:</p><ul>
<li>Gamma: Defines which parts of the well are open. This can be used to close some sections dynamically with python.</li>
<li>Sigma: Specifies the friction factor. it is recommended to use /porous_media/wells_and_pipes/well_options/calculate_sigma_pipe and specify the roughness of the material there.</li>
<li>DiameterPipe: Specifies the diameter of the well.</li>
<li>Thermal properties: The user can specify if the wells may lose heat by specifying the thickness of the pipe and its conductivity value.</li>
<li>Well colume ids: The user must specify the region ids of the sleeves defining the wells.</li>
<li>Well from file or from coordinates to specify as said in <a class="el" href="index.html#wellmodelling">Wells in ICFERST</a> the well paths. </li>
</ul>
<h3><a class="anchor" id="Wells"></a>
Well modelling as multiphases</h3>
<p>Currently, ICFERST model wells by considering that two different domains co-exist and are connected through the nodes of the wells. To define this through diamond One has to duplicate the number of phases to the ones required to model the system without wells and consider that they are equivalent, for example for two phase phase 1 and 3 are the same. Therefore, the EOS and different properties must be defined equivalently. Another important requirement is that now two Pressure needs to be solved for, in this case phase 1 and 3 will have a defined pressure and phase 2 and 4 will be aliased with 1 and 3 respectively. Once this is done the boundary conditions need to be set accordingly </p>
<h2><a class="anchor" id="xgboost"></a>
Coupling with XGBoost for machine learning acceleration</h2>
<p>ICFERST can use XGBoost to accelerate the non-linear solver using a pre-trained model based on dimensionless parameters (Silva et al. 2022). In order to activate this option XGBoost needs to be installed and liked with ICFERST, this latter can be done with the following command:  
 <CODE>
 <PRE>
 ./configure --with-xgboost && make mp
 </PRE>
 </CODE>
  and then specify the model path in /solver_options/Non_Linear_Solver/Fixed_Point_Iteration/ML_model_path</p>
<p>Since currently the model is very heavy, it takes 2GBs, the model is not stored online so currently it needs to be requested to ICFERST developers.</p>
<h2><a class="anchor" id="diamond"></a>
Diamond interface</h2>
<p>Using the diamond GUI to configure test cases The input files are “EXAMPLE.mpml”. This files can be either manipulated using diamond a GUI, or a text file. To open the diamond GUI for ICFERST this is an example, found in the examples folder in IC-FERST-FOLDER/legacy_reservoir_prototype/tests/3D_BL  
 <CODE>
 <PRE>
 diamond -s IC-FERST-FOLDER/legacy_reservoir_prototype/schemas/multiphase.rng 3D_test.mpml
 </PRE>
 </CODE>
  </p>
<h3><a class="anchor" id="modifying_diamond"></a>
Extending and modifying the diamond interface</h3>
<p>The current settings for diamond are stored in the folder ICFERST/schemas being multiphase.rnc the main file which calls the other ones. To add/remove or modify the schema the .rnc files need to be modified as required and afterwards recompiled using spud-preprocess:  
 <CODE>
 <PRE>
 spud-preprocess multiphase.rnc
 </PRE>
 </CODE>
  this will generate new .rng files which are the ones read by diamond. spud-preprocess should have been installed in your system as part of the make install process. </p>
<h3><a class="anchor" id="Diamond_manual"></a>
Diamond graphical document</h3>
<p>You can find a tutorial detailing the use of diamond and the different sections in ICFERST/doc/ICFERST_tutorial.pdf (Like the figure below) </p><div class="image">
<img src="diamond_overview.png" alt=""/>
</div>
<p> Here we will provide a short summary of each section but the graphical document is still highly recommended, also more information of each field is already in place in the Diamond interface itself in the description box.</p>
<h3><a class="anchor" id="geometry"></a>
Geometry</h3>
<p>In this section the user must define the dimensions of the mode, the input file and the simulation quality. Currently only Fast and Balance are operative the other settings are just for research purposes and its use is not recommended. The option create_binary_mesh is used to convert the given mesh into a binary format to be used by fldecomp, if this option is one the recommended usage is to use it and kill the simulation once the conversion has been done (printed on the terminal). </p>
<h3><a class="anchor" id="solv_options"></a>
Solver Options</h3>
<p>This zone is devoted to modify the linear and non-linear solvers. It is recommended not to modify the linear solver settings unless a model with undefined pressure is used, in which case the pressure solver needs to be defined with the option remove null space. Even for this cases it is recommended to use the default settings of GMRES(30)+Hypre and relative residual reduction of 1e-10</p>
<p>Regarding the non-linear solver settings, it is also recommended not to modify it unless the adaptive time-stepping method with PID is used in which case the user is encouraged to introduce the defaults settings for all the requested fields and specify the PID adaptive time-stepping. </p>
<h3><a class="anchor" id="PID"></a>
PID adaptive time-stepping</h3>
<p>The recommended method to adjust the time-step size in ICFERST is to do it based on the stability of the non-linear solver with the addition of the PID controler (Proportional Integrator Derivator). Adaptive time-stepping methods based on the stability of the non-linear solver normally suffer from the fact that they keep raising the time-step size until they fail, which forces them to repeat a time-level, halve the time-step size and repeat the process. This is suboptimal, in ICFERST we use a PID type method based on a requested number of non-linear iterations, where the controller adjusts the time-step size to try to always have the same number of non-linear iterations, avoiding that problem and being overall more efficient. </p>
<h3><a class="anchor" id="VAD"></a>
Vanishing artificial diffusion</h3>
<p>The Vanishing Artificial Diffusion (VAD) is devoted to stabilise the system when solving for multiphase flow. It can also be used for transport however we have seen that in certain scenarios it may not be beneficial, this could be solved adjusting the parameter but xthis work needs to be done. However, for multiphase it has shown to greatly accelerate the non-linear solver and specially when having capillary pressure in the system. Unless explicitly imposed, when capillary pressure is active VAD is also active. Moreover, VAD is active if no settings of the non-linear solver are set. The momentum_matrix settings are only for stokes and therefore out of the scope of this manual. </p>
<h3><a class="anchor" id="io"></a>
IO(Input/output)</h3>
<p>In this section the user can specify what to output from ICFERST. The outputs of vtu files can either be based on timesteps or time in seconds. The user can select to print convergence information and the current courant number, also the user can select from here to generate the outfluxes file and checkpointing. </p>
<h3><a class="anchor" id="timestepping"></a>
Timestepping</h3>
<p>The initial time, final time and initial time-step size is selected here. Also a time-stepping method based on a CFL limit can be specified here. Note that if the time-step is to be adjusted on both the CFL and the non-linear solver, the most limiting one will be used. </p>
<h3><a class="anchor" id="physical_par"></a>
Physical parameters</h3>
<p>The user can select the magnitude and direction of the gravity forces as well as select from two options to help with hydrostatic modelling hydrostatic pressure solver, which requries an extra solver and does not work with Wells or remove hydrostatic contribution, only for single phase. </p>
<h3><a class="anchor" id="material_phase"></a>
Material phase</h3>
<p>You can add as many phases as desired in theory, however ICFERST can only do up to three phases (gas, liquid, aqua), doubling to 6 if having wells. It is important to note that pressure is only solved for the first phase and the other phases are aliased with this phase. Within each phase the user has to defined its viscosity and different properties based on the modelling requested. PhaseVolumeFraction has to be always defined even though a single phase model is done.</p>
<p>A phase must have a pressure field defined, a Velocity field and a PahseVolumeFraction defined. Also, temperature, concentration and Passive/ActiveTracers can be defined as well as species. To define a Passive/ActiveTracer the fiel must start with that name, for example ActiveTracer_Humidity. In this way, n-fields can be solved for. There are some more restricted fields or diagnostic fields that are used by Fluidity that the user can take advantage of, we recommend the reader to check the Fluidity manual for those.</p>
<p>For multiphase, the section multiphase_properties must be defined. There the relative permeability, immobile fraction and capillary pressure can be defined. </p>
<h3><a class="anchor" id="BCs"></a>
Boundary conditions</h3>
<p>ICFERST accepts three types of BCs all of them weakly enforced (excepting pressure dirichlet for wells): Dirichlet, zero_flux and Robin. If Neumann are required the recommendation is to use Robin without the dirichlet contribution. </p>
<h3><a class="anchor" id="minmax"></a>
MinMax principle</h3>
<p>For tracer fields, it is HIGHLY recommended to specify the min_max condition since it helps ensure a physical solution as well as accelerate the simulation. </p>
<h3><a class="anchor" id="madapt_opt"></a>
Adaptivity options</h3>
<p>Specify this option to adapt the mesh to this field with the requested precision </p>
<h3><a class="anchor" id="Mesh2mesh"></a>
Mesh to Mesh interpolator</h3>
<p>It is recommended to use Consistent interpolation for wells and pressure, and Galerkin for scalar fields and velocity. </p>
<h3><a class="anchor" id="sourceterm"></a>
Source and Absorption terms</h3>
<p>A source term can be added to every field. The absorption term however is inactive. Only defining a tensor field named UAbsorB on the first phase this can be used. UAbsorB can be used to modify the momentum equation through the diamond interface. </p>
<h3><a class="anchor" id="mesh_adaptivity"></a>
Mesh Adaptivity</h3>
<p>To activate mesh adaptivity there are two different parts. The user first needs to select the type of interpolation and specify the precision requested for the fields of interest using <a class="el" href="index.html#madapt_opt">Adaptivity options</a> and <a class="el" href="index.html#Mesh2mesh">Mesh to Mesh interpolator</a> and secondly activate the settings in mesh_adaptivity/hr_adaptivity</p>
<p>Within this section the user can select</p><ul>
<li>how often adapt the mesh based on the number of iterations or an accumulated courant number if adapting within the non-linear solver.</li>
<li>Maximum and minimum number of nodes to be used. It is recommended to give a minimum number of nodes per core of at least 1000 to ensure that parallel simulations can perform well.</li>
<li>Gradation: this parameters specifies how bigger an element can be compared to its neighbour.</li>
<li>Minimum and maximum edge lenghts: it is recommended to ignore the off-diagonal values and consider in the diagonals the precision in metres required. normally spanning 3 or 4 orders of magnitude is stable.</li>
</ul>
<p>Other settings to take into account are adapt at the first time step, which can be used to generate a mesh from a given one or if there is an interface at the beginning. The fail safe is on by default and it is not recommended to modify it, similar to the other settings. </p>
<h3><a class="anchor" id="porousmedia"></a>
Porous media settings</h3>
<p>In this part the user must specify the petrophysical properties under porosity, permeability, and if needed, Dispersion and rock properties such as density, heat capacity and coductivity of the porous media under porous properties. </p>
<h3><a class="anchor" id="phreqqc"></a>
PHREEQC coupling</h3>
<p>IC-FERST can run reaction modelling where the reaction part is performed using PHREEQC. To do this first the user must install PHREEQCRM on the system and compile IC-FERST to support this with the following command:  
 <CODE>
 <PRE>
 ./configure --with-phreeqc && make mp
 </PRE>
 </CODE>
  Next, a PHREEQC file needs to be generated as normal and provided it through the command /porous_media/Phreeqc_coupling/simulation_name. </p>
<h3><a class="anchor" id="selfP"></a>
Self Potential</h3>
<p>By activating /porous_media/SelfPotential that computation will be performed. Some extra parameters are required, which can either use the default ones or use the python interface from python to introduce different models.</p>
<p>It is very important to define a reference coordinate where the Voltage will be set to zero, and everything in reference to that. Moreover, if not temperature field is solved for, a reservoir temperature needs to be provided. For more information of the default models read Mutlaq et al. 2020. </p>
<h3><a class="anchor" id="dissolution"></a>
Gas dissolution</h3>
<p>IC-FERST can model instantaneous gas dissolution into a fluid using this option and as a flash calculation that occurs after the non-linear solver. </p>
<h3><a class="anchor" id="pythonscripting"></a>
Input using python</h3>
<p>Diamond enables the user to introduce Boundary Conditions and diagnostic fields, as well as other fields such as SelfPotential parameters using python code. It is important to note that using a python field is considerably slower than using a field based on region ids, this extra cost is not unberable but it is neither negligible. Therefore, the use of python fields is only recommended only if strictly necessary.</p>
<p>For boundary conditions and simple fields, the python code looks as follow to set up Velocity Boundary Conditions based on time:  
 <CODE>
 <PRE>
  # Function code
  def val(X, t):
   import numpy as np
   alpha = 2.5 #m/s - max velocity
   f     = 20./60. #20 breath/min
   angle = np.radians(30.)
   v_ejecta = alpha*np.sin(2.*np.pi*f*t)
   
   if v_ejecta < 0.:
     u = 0.0
   else:
     u = v_ejecta  * np.cos(angle)  
   
   return u # Return value
 </PRE>
 </CODE>
 </p>
<p>it can be seen that it can load modules. This code will be called and evaluated for every single node in the boundary and the only inputs are Coordinates (X) and time (t).</p>
<p>Using diagnostic fields the user can have access to all the fields stored in state (or packed_state, check the description) which enables the user to perform more complex operations such as alter fields. In this way the python call is performed only once per non-linear loop. It is important to note that the python code is parallel safe as long as everything is keep in memory, i.e. not trying to read a file. In this case the example of the code would be as follows:  
 <CODE>
 <PRE>
 import numpy as np
 
 C = state.scalar_fields['PassiveTracer_H2O']
 P = 1.01325e+5
 
 T  = state.scalar_fields['Temperature']
 UV = 0.0
 Ref_temp = 20.615+273.15
 
 for nodeID in range(field.node_count):
   #Convert to relative humidity
   RH=0.263*P*C.node_val(nodeID)*1./(np.exp((17.67*(T.node_val(nodeID)-273.15))/(T.node_val(nodeID)-29.65)))
   k_inf = (0.16030+0.04018*((T.node_val(nodeID)-Ref_temp)/10.585)+0.02176*((RH-45.235)/28.665)+0.14369*((UV-0.95)/0.95)+0.02636*((T.node_val(nodeID)-Ref_temp)/10.585)*((UV-0.95)/0.95))/60.0
   field.set(nodeID, k_inf)
 </PRE>
 </CODE>
  it can be seen how fields can be extracted from state and then looped over them. Compared to the previous script here we need to use commands such as set to impose the value of the field. This approach is very powerful. To include new fields in diamond that can use this it is recommended to link it using multi_compute_python_field following the procedure done for the SelfPotential fields. For more details of available commands check Fluidity's manual. </p>
<h3><a class="anchor" id="int_conv"></a>
Simplified diamond interface</h3>
<p>The current version of the multiphase schema found within ICFERST/schemas is a simplified version which gets populated internally so it is compatible with Fluidity. This extra population affects when generating checkpointing files that will not be exactly like the original and may need to amended before re-running from a checkpoint (which can be done by opening them and saving). It is important to understand that this conversion exists since it may affect some sections of the code. However, this has been tried to be kept to a minimum and developers can expect a direct connection between diamond and where the option can be found when extracting it.</p>
<p>The simplification mainly focuses on not having to describe the discretisation type, use of defaults for solvers and other settings , density not being defined as a scalar field explicitly, simplified interpolation settings, etc. These can be found in multiphase_prototype_wrapper and are generated using the spud options as defined in the Fluidity manual in the manual folder </p>
<h2><a class="anchor" id="applications"></a>
Applications and tests</h2>
<p>ICFERST can currently be used to model inertia dominated flows (Navier-Stokes), Stokes flow or Darcy flow. This latter is the most commonly used and the main application of ICFERST and therefore this documentation will focus on it. ICFERST can model single (aquifer thermal energy storage) and multiphase flow with or without wells, compositional with reaction provided by PHREEQC (needs to be installed separately).</p>
<p>The recommended action when generating a new simulation is to build from an input file that has the initial settings that you want. There are examples in ICFERST/test/:</p><ul>
<li>Single and multiphase flow (3D_template_porous_case)</li>
<li>using wells (Thermal_wells_analytical/multiphase_wells)</li>
<li>gravity (BL_with_gravity)</li>
<li>capillary pressure (Grav_cap_competing_fast)</li>
<li>ATES (Thermal_boussinesq)</li>
<li>tunneled BCs (tunneled_BCs)</li>
<li>use of Active (Active_tracers) and Passive Tracers (Passive_tracers)</li>
<li>drainage (Drainage_test)</li>
<li>dissolution (Dissolution_test)</li>
<li>use of different region ids to specify petrophysical properties using diamond (3D_template_porous_case) or a input file (Porous_media_general_test)</li>
<li>generation of the outfluxes file (BL_fast_fluxes)</li>
<li>compositional (Porous_compositional)</li>
<li>compressible flow (porous_density_compressible)</li>
<li>Robin BCs(Thermal_robin_BCs)</li>
<li>three phases with the stone model (Three_phases)</li>
<li>adaptive time-stepping using the CFL condition (Adaptive_times_Courant) or based on the stability of the non-linear solver (BL_fast_adapt_ts)</li>
<li>anisotropic permeability (Anisotropic_permeability)</li>
<li>adapt the mesh within the non-linear solver (Adapt_within_FPI)</li>
<li>checkpointing (BL_Checkpointing)</li>
<li>Boussinesq approximation (Boussinesq_eos_with_tracers)</li>
<li>run in parallel (Parallel_Buckley_Leverett)</li>
<li>self potential (SP_ElectroDiffusive_test, SP_ElectroKinetic_test, SP_ThermoElectric_test)</li>
<li>thermal modelling (Thermal_analytical_validation) and concentration with dispersion (2D_Dispersive_Saline_Intrusion)</li>
</ul>
<h3><a class="anchor" id="test_case"></a>
Automatic Testing</h3>
<p>All the test cases are run using Github actions every time a commit is done to master or one of the designated branches defined in the file .github/workflows/ubuntu.yml</p>
<p>There are two type of test cases. Ones based on a python script comparing against an analytical solution, or the ones based on checking against data obtained from the .stat file (i.e. min/max of fields, integral etc). In all the cases the test is triggered through the xml file and can be tested locally by running the python script in ICFERST/tools testharness_ICFERST.py The most common flags are -n &lt;#CPUs&gt; and -t &lt;TAG_of_test_cases&gt;. An example of running locally the quick test cases would be:  
 <CODE>
 <PRE>
 python3 testharness_ICFERST.py -n 2 -t tbc </PRE>
 </CODE>
 </p>
<p>For every functionality there MUST be a test case checking that functionality, uniquely if possible. </p>
<h2><a class="anchor" id="Parallel"></a>
Using ICFERST in parallel</h2>
<p>ICFERST uses openMPI to run in parallel. The mesh needs to be decomposed initially using the command  
 <CODE>
 <PRE>
 fldecomp -n #CPUs INPUT_MESH
 </PRE>
 </CODE>
  where #CPUs is the number of CPUs and INPUT_MESH is a binary msh file using the gmshv2 format. This can be obtained using ICFERST from an option in diamond/geometry or from an exodusII file using the python conversor from ICFERST/tools Once the mesh is decomposed you can run in parallel using mpirun:  
 <CODE>
 <PRE>
 mpirun -n #CPUs icferst INPUT_mpml
 </PRE>
 </CODE>
 </p>
<p>where INPUT is INPUT_mpml is the mpml file as normally done. As a rule of thumb one wants to have around 15k elements per CPU to have optimal performance. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
