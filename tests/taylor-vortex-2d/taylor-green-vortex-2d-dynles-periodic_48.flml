<?xml version='1.0' encoding='utf-8'?>
<fluidity_options>
  <simulation_name>
    <string_value lines="1">taylor-green-vortex-2d-dynles-periodic_48</string_value>
  </simulation_name>
  <problem_type>
    <string_value lines="1">fluids</string_value>
  </problem_type>
  <geometry>
    <dimension>
      <integer_value rank="0">2</integer_value>
    </dimension>
    <mesh name="CoordinateMesh">
      <from_file file_name="square-periodic-48">
        <format name="gmsh"/>
        <stat>
          <include_in_stat/>
        </stat>
      </from_file>
    </mesh>
    <mesh name="VelocityMesh">
      <from_mesh>
        <mesh name="PeriodicMesh"/>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <mesh name="PressureMesh">
      <from_mesh>
        <mesh name="PeriodicMesh"/>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <mesh name="PeriodicMesh">
      <from_mesh>
        <mesh name="CoordinateMesh"/>
        <periodic_boundary_conditions name="updown">
          <physical_boundary_ids>
            <integer_value shape="1" rank="1">2</integer_value>
          </physical_boundary_ids>
          <aliased_boundary_ids>
            <integer_value shape="1" rank="1">1</integer_value>
          </aliased_boundary_ids>
          <coordinate_map>
            <string_value lines="20" type="code" language="python">def val(X,t):
  from math import pi
  return (X[0],X[1]+2.*pi)</string_value>
          </coordinate_map>
        </periodic_boundary_conditions>
        <periodic_boundary_conditions name="leftright">
          <physical_boundary_ids>
            <integer_value shape="1" rank="1">3</integer_value>
          </physical_boundary_ids>
          <aliased_boundary_ids>
            <integer_value shape="1" rank="1">4</integer_value>
          </aliased_boundary_ids>
          <coordinate_map>
            <string_value lines="20" type="code" language="python">def val(X,t):
  from math import pi
  return (X[0]-2.*pi,X[1])</string_value>
          </coordinate_map>
        </periodic_boundary_conditions>
        <stat>
          <exclude_from_stat/>
        </stat>
      </from_mesh>
    </mesh>
    <quadrature>
      <degree>
        <integer_value rank="0">4</integer_value>
      </degree>
    </quadrature>
  </geometry>
  <io>
    <dump_format>
      <string_value>vtk</string_value>
    </dump_format>
    <dump_period>
      <constant>
        <real_value rank="0">1</real_value>
      </constant>
    </dump_period>
    <output_mesh name="CoordinateMesh"/>
    <stat/>
  </io>
  <timestepping>
    <current_time>
      <real_value rank="0">0.</real_value>
    </current_time>
    <timestep>
      <real_value rank="0">0.1</real_value>
    </timestep>
    <finish_time>
      <real_value rank="0">1000</real_value>
    </finish_time>
  </timestepping>
  <material_phase name="fluid">
    <equation_of_state>
      <fluids>
        <linear>
          <reference_density>
            <real_value rank="0">1</real_value>
          </reference_density>
        </linear>
      </fluids>
    </equation_of_state>
    <scalar_field name="Pressure" rank="0">
      <prognostic>
        <mesh name="PressureMesh"/>
        <spatial_discretisation>
          <continuous_galerkin/>
        </spatial_discretisation>
        <reference_node>
          <integer_value rank="0">1</integer_value>
        </reference_node>
        <scheme>
          <poisson_pressure_solution>
            <string_value lines="1">only first timestep</string_value>
          </poisson_pressure_solution>
          <use_projection_method/>
        </scheme>
        <solver>
          <iterative_method name="cg"/>
          <preconditioner name="mg"/>
          <relative_error>
            <real_value rank="0">1.e-7</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <no_interpolation/>
      </prognostic>
    </scalar_field>
    <scalar_field name="Density" rank="0">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <vector_field name="Velocity" rank="1">
      <prognostic>
        <mesh name="VelocityMesh"/>
        <equation name="LinearMomentum"/>
        <spatial_discretisation>
          <continuous_galerkin>
            <stabilisation>
              <no_stabilisation/>
            </stabilisation>
            <mass_terms>
              <lump_mass_matrix/>
            </mass_terms>
            <advection_terms/>
            <stress_terms>
              <tensor_form/>
            </stress_terms>
            <les_model>
              <dynamic_les>
                <alpha>
                  <real_value rank="0">2.</real_value>
                </alpha>
                <gamma>
                  <real_value rank="0">2.</real_value>
                </gamma>
                <limit_coefficient>
                  <real_value rank="0">0.1</real_value>
                </limit_coefficient>
                <solver>
                  <iterative_method name="cg"/>
                  <preconditioner name="sor"/>
                  <relative_error>
                    <real_value rank="0">1.e-5</real_value>
                  </relative_error>
                  <max_iterations>
                    <integer_value rank="0">100</integer_value>
                  </max_iterations>
                  <never_ignore_solver_failures/>
                  <diagnostics>
                    <monitors/>
                  </diagnostics>
                </solver>
                <scalar_field name="SmagorinskyCoefficient" rank="1">
                  <diagnostic>
                    <algorithm name="Internal" material_phase_support="multiple"/>
                    <mesh name="VelocityMesh"/>
                    <output/>
                    <stat/>
                    <convergence>
                      <include_in_convergence/>
                    </convergence>
                    <detectors>
                      <include_in_detectors/>
                    </detectors>
                    <steady_state>
                      <include_in_steady_state/>
                    </steady_state>
                  </diagnostic>
                </scalar_field>
                <scalar_field name="ScalarFirstFilterWidth" rank="1">
                  <diagnostic>
                    <algorithm name="Internal" material_phase_support="multiple"/>
                    <mesh name="VelocityMesh"/>
                    <output/>
                    <stat/>
                    <convergence>
                      <include_in_convergence/>
                    </convergence>
                    <detectors>
                      <include_in_detectors/>
                    </detectors>
                    <steady_state>
                      <include_in_steady_state/>
                    </steady_state>
                  </diagnostic>
                </scalar_field>
                <scalar_field name="ScalarSecondFilterWidth" rank="1">
                  <diagnostic>
                    <algorithm name="Internal" material_phase_support="multiple"/>
                    <mesh name="VelocityMesh"/>
                    <output/>
                    <stat/>
                    <convergence>
                      <include_in_convergence/>
                    </convergence>
                    <detectors>
                      <include_in_detectors/>
                    </detectors>
                    <steady_state>
                      <include_in_steady_state/>
                    </steady_state>
                  </diagnostic>
                </scalar_field>
                <vector_field name="FirstFilteredVelocity" rank="2">
                  <diagnostic>
                    <algorithm name="Internal" material_phase_support="multiple"/>
                    <mesh name="VelocityMesh"/>
                    <output/>
                    <stat>
                      <include_in_stat/>
                    </stat>
                    <convergence>
                      <include_in_convergence/>
                    </convergence>
                    <detectors>
                      <include_in_detectors/>
                    </detectors>
                    <steady_state>
                      <include_in_steady_state/>
                    </steady_state>
                  </diagnostic>
                </vector_field>
                <vector_field name="SecondFilteredVelocity" rank="2">
                  <diagnostic>
                    <algorithm name="Internal" material_phase_support="multiple"/>
                    <mesh name="VelocityMesh"/>
                    <output/>
                    <stat>
                      <include_in_stat/>
                    </stat>
                    <convergence>
                      <include_in_convergence/>
                    </convergence>
                    <detectors>
                      <include_in_detectors/>
                    </detectors>
                    <steady_state>
                      <include_in_steady_state/>
                    </steady_state>
                  </diagnostic>
                </vector_field>
                <tensor_field name="EddyViscosity" rank="2">
                  <diagnostic>
                    <algorithm name="Internal" material_phase_support="multiple"/>
                    <mesh name="VelocityMesh"/>
                    <output/>
                    <stat>
                      <include_in_stat/>
                    </stat>
                  </diagnostic>
                </tensor_field>
              </dynamic_les>
            </les_model>
          </continuous_galerkin>
          <conservative_advection>
            <real_value rank="0">0.</real_value>
          </conservative_advection>
        </spatial_discretisation>
        <temporal_discretisation>
          <theta>
            <real_value rank="0">.5</real_value>
          </theta>
          <relaxation>
            <real_value rank="0">.5</real_value>
          </relaxation>
        </temporal_discretisation>
        <solver>
          <iterative_method name="gmres">
            <restart>
              <integer_value rank="0">30</integer_value>
            </restart>
          </iterative_method>
          <preconditioner name="sor"/>
          <relative_error>
            <real_value rank="0">1.e-7</real_value>
          </relative_error>
          <max_iterations>
            <integer_value rank="0">1000</integer_value>
          </max_iterations>
          <never_ignore_solver_failures/>
          <diagnostics>
            <monitors/>
          </diagnostics>
        </solver>
        <initial_condition name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  import vortex_tools as vt
  return vt.initial_cond(X)</string_value>
          </python>
        </initial_condition>
        <tensor_field name="Viscosity" rank="2">
          <prescribed>
            <value name="WholeMesh">
              <isotropic>
                <constant>
                  <real_value rank="0">0.01</real_value>
                </constant>
              </isotropic>
            </value>
            <output/>
          </prescribed>
        </tensor_field>
        <output/>
        <stat>
          <include_in_stat/>
          <previous_time_step>
            <exclude_from_stat/>
          </previous_time_step>
          <nonlinear_field>
            <exclude_from_stat/>
          </nonlinear_field>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
        <consistent_interpolation/>
      </prognostic>
    </vector_field>
    <scalar_field name="ExactPressure" rank="0">
      <prescribed>
        <mesh name="PressureMesh"/>
        <value name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  import vortex_tools as vt
  return vt.pressure(X,t)</string_value>
          </python>
        </value>
        <output/>
        <stat/>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
      </prescribed>
    </scalar_field>
    <scalar_field name="PressureDiff" rank="0">
      <diagnostic>
        <algorithm source_field_2_type="scalar" name="scalar_difference" source_field_1_name="ExactPressure" source_field_2_name="Pressure" material_phase_support="single" source_field_1_type="scalar"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CFLNumber" rank="0">
      <diagnostic>
        <algorithm name="Internal" material_phase_support="multiple"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="TKE" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from math import sqrt, pi
u = state.vector_fields["Velocity"]
assert(u.node_count == field.node_count)
for i in range(field.node_count):
  tke = 0.5*sum(u.node_val(i)**2.)
  field.set(i, tke)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="ExactTKE" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from math import sqrt, pi
u = state.vector_fields["ExactVelocity"]
assert(u.node_count == field.node_count)
for i in range(field.node_count):
  tke = 0.5*sum(u.node_val(i)**2.)
  field.set(i, tke)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="TKEDiff" rank="0">
      <diagnostic>
        <algorithm source_field_2_type="scalar" name="scalar_difference" source_field_1_name="ExactTKE" source_field_2_name="TKE" material_phase_support="single" source_field_1_type="scalar"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="StrainMag" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from math import sqrt, pi
g = state.tensor_fields["GradFFV"]
assert(g.node_count == field.node_count)
for i in range(field.node_count):
  g11=g.node_val(i)[0][0]
  g12=g.node_val(i)[0][1]
  g21=g.node_val(i)[1][0]
  g22=g.node_val(i)[1][1]
  s11=g11**2
  s12=0.25*(g12**2+2.*g12*g21+g21**2)
  s21=s12
  s22=g22**2
  s = sqrt(2.*(s11+s12+s21+s22))
  field.set(i, s)</string_value>
          <comment>Horrid expression for strain rate magnitude of first filtered velocity</comment>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="ExactStrainMag" rank="0">
      <prescribed>
        <mesh name="VelocityMesh"/>
        <value name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  import vortex_tools as vt
  return vt.strainmagnitude(X,t)</string_value>
            <comment>Taylor expansion of filtered variable to 4th order</comment>
          </python>
        </value>
        <output/>
        <stat/>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
      </prescribed>
    </scalar_field>
    <scalar_field name="StrainMagDiff" rank="0">
      <diagnostic>
        <algorithm source_field_2_type="scalar" name="scalar_difference" source_field_1_name="ExactStrainMag" source_field_2_name="StrainMag" material_phase_support="single" source_field_1_type="scalar"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="ExactCoeff" rank="0">
      <diagnostic>
        <algorithm name="scalar_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from math import sqrt, pi
ffv = state.vector_fields["ExactFirstFilteredVelocity"]
sfv = state.vector_fields["ExactSecondFilteredVelocity"]
st = state.tensor_fields["ExactStrain"]
stm = state.scalar_fields["ExactStrainMag"]
assert(ffv.node_count == field.node_count)
assert(sfv.node_count == field.node_count)
assert(st.node_count == field.node_count)
assert(stm.node_count == field.node_count)
# filter widths
w1=2.*(pi/24.)**2.
w2=8.*(pi/24.)**2.
for i in range(field.node_count):
  fu = ffv.node_val(i)[0]
  fv = ffv.node_val(i)[1]
  su = sfv.node_val(i)[0]
  sv = sfv.node_val(i)[1]
  # filtered strain
  st1 = st.node_val(i)[:]
  st1 = st1*stm.node_val(i)*(1.-w2/24.+w2/576.)
  st2 = st1*(1.-w2/24.+w2/576.)
  #print 'st1, st2 ', st1, st2
  # Leonard tensor L_ij
  fuiuj = [[fu**2., fu*fv],[fu*fv, fv**2.]]
  suiuj = [[su**2., su*sv],[su*sv, sv**2.]]
  #print 'fuiuj, suiuj ', fuiuj, suiuj
  L=[[0,0],[0,0]]
  L[0][0] = fuiuj[0][0]*(1.-w2/24.+w2/576.) - suiuj[0][0]
  L[0][1] = fuiuj[0][1]*(1.-w2/24.+w2/576.) - suiuj[0][1]
  L[1][0] = fuiuj[1][0]*(1.-w2/24.+w2/576.) - suiuj[1][0]
  L[1][1] = fuiuj[1][1]*(1.-w2/24.+w2/576.) - suiuj[1][1]
  #print 'Lij ', L
  # M_ij
  M = w2*st2 - w1*st1
  #print 'Mij ', M
  print 'L*M ', L*M, sum(sum(L*M))
  print 'M*M ', M*M, sum(sum(M*M))
  C = -0.5*sum(sum(L*M))/sum(sum(M*M))
  print 'C ', C
  C=max(min(C,0.1),0.0)
  print 'C ', C
  field.set(i, C)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="CoeffDiff" rank="0">
      <diagnostic>
        <algorithm source_field_2_type="scalar" name="scalar_difference" source_field_1_name="ExactCoeff" source_field_2_name="C" material_phase_support="single" source_field_1_type="scalar"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat/>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </scalar_field>
    <scalar_field name="C" rank="0">
      <aliased material_phase_name="fluid" field_name="SmagorinskyCoefficient"/>
    </scalar_field>
    <vector_field name="ExactVelocity" rank="1">
      <prescribed>
        <mesh name="VelocityMesh"/>
        <value name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  import vortex_tools as vt
  return vt.velocity(X,t)</string_value>
          </python>
        </value>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
      </prescribed>
    </vector_field>
    <vector_field name="VelocityDiff" rank="1">
      <diagnostic>
        <algorithm source_field_2_type="vector" name="vector_difference" source_field_1_name="ExactVelocity" source_field_2_name="Velocity" material_phase_support="single" source_field_1_type="vector"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </vector_field>
    <vector_field name="ExactFirstFilteredVelocity" rank="1">
      <prescribed>
        <mesh name="VelocityMesh"/>
        <value name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  import vortex_tools as vt
  from math import pi
  # first filter width
  w=2.*(pi/24.)**2.
  vel = vt.velocity(X,t)
  #vel = vt.exactfilter(vel,w)
  #vel[0]=vel[0]*(1.-w/24.+w/576.)
  #vel[1]=vel[1]*(1.-w/24.+w/576.)
  return vel</string_value>
          </python>
        </value>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
      </prescribed>
    </vector_field>
    <vector_field name="ExactSecondFilteredVelocity" rank="1">
      <prescribed>
        <mesh name="VelocityMesh"/>
        <value name="WholeMesh">
          <python>
            <string_value lines="20" type="code" language="python">def val(X,t):
  import vortex_tools as vt
  from math import pi
  # first filter width
  w1=2.*(pi/24.)**2.
  # second filter width
  w2=8.*(pi/24.)**2.
  vel = vt.velocity(X,t)
  #ffvel = vt.exactfilter(vel,w1)
  #sfvel = vt.exactfilter(ffvel,w2)
  vel[0]=vel[0]*(1.-w2/24.+w2/576.)
  vel[1]=vel[1]*(1.-w2/24.+w2/576.)
  return vel</string_value>
          </python>
        </value>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <detectors>
          <exclude_from_detectors/>
        </detectors>
      </prescribed>
    </vector_field>
    <vector_field name="FirstFilteredVelocityDiff" rank="1">
      <diagnostic>
        <algorithm source_field_2_type="vector" name="vector_difference" source_field_1_name="ExactFirstFilteredVelocity" source_field_2_name="FFV" material_phase_support="single" source_field_1_type="vector"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </vector_field>
    <vector_field name="SecondFilteredVelocityDiff" rank="1">
      <diagnostic>
        <algorithm source_field_2_type="vector" name="vector_difference" source_field_1_name="ExactSecondFilteredVelocity" source_field_2_name="SFV" material_phase_support="single" source_field_1_type="vector"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
        <convergence>
          <include_in_convergence/>
        </convergence>
        <detectors>
          <include_in_detectors/>
        </detectors>
        <steady_state>
          <include_in_steady_state/>
        </steady_state>
      </diagnostic>
    </vector_field>
    <vector_field name="FFV" rank="1">
      <aliased material_phase_name="fluid" field_name="FirstFilteredVelocity"/>
    </vector_field>
    <vector_field name="SFV" rank="1">
      <aliased material_phase_name="fluid" field_name="SecondFilteredVelocity"/>
    </vector_field>
    <tensor_field name="GradFFV" rank="2">
      <diagnostic>
        <algorithm source_field_type="vector" material_phase_support="single " name="grad_vector" source_field_name="FFV"/>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
      </diagnostic>
    </tensor_field>
    <tensor_field name="ExactEddyViscosity" rank="2">
      <diagnostic>
        <algorithm name="tensor_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">from math import sqrt, pi
s = state.scalar_fields["ExactStrainMag"]
C = state.scalar_fields["ExactCoeff"]
assert(s.node_count == field.node_count)
for i in range(field.node_count):
  #filter width is constant on structured mesh
  w=2.*(pi/24.)**2.
  ev=[[0, 0],[0, 0]]
  ev[0][0]=w*C.node_val(i)*s.node_val(i)
  ev[0][1]=w*C.node_val(i)*s.node_val(i)
  ev[1][0]=w*C.node_val(i)*s.node_val(i)
  ev[1][1]=w*C.node_val(i)*s.node_val(i)
  field.set(i, ev)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
      </diagnostic>
    </tensor_field>
    <tensor_field name="EddyViscosityDiff" rank="2">
      <diagnostic>
        <algorithm name="tensor_python_diagnostic" material_phase_support="single">
          <string_value lines="20" type="code" language="python">ev = state.tensor_fields["EddyViscosity"]
eve = state.tensor_fields["ExactEddyViscosity"]
assert(ev.node_count == field.node_count)
for i in range(field.node_count):
  evd=eve.node_val(i)-ev.node_val(i)
  field.set(i, evd)</string_value>
        </algorithm>
        <mesh name="VelocityMesh"/>
        <output/>
        <stat>
          <include_in_stat/>
        </stat>
      </diagnostic>
    </tensor_field>
    <tensor_field name="ExactStrain" rank="2">
      <prescribed>
        <mesh name="VelocityMesh"/>
        <value name="WholeMesh">
          <anisotropic_asymmetric>
            <python>
              <string_value lines="20" type="code" language="python">def val(X,t):
    import vortex_tools as vt
    st = vt.exactstrain(X,t)
    return st</string_value>
            </python>
          </anisotropic_asymmetric>
        </value>
        <output/>
      </prescribed>
    </tensor_field>
  </material_phase>
</fluidity_options>
