\chapter{Meshing for \fluidity}\label{chap:meshes}
\index{mesh!generation}
\index{grid|see{mesh}}

In each run of \fluidity\ an input computational mesh needs to 
be provided. Even in adaptive mesh runs an initial mesh is needed
to define the initial condition of the fields on. This initial mesh
can be adapted by \fluidity at the start of the simulation, 
in order to optimize the accurate representation of the initial 
condition. The input mesh is then used as a starting point for the
mesh adaptivity algorithm.

\fluidity supports two mesh file formats:
\begin{enumerate}
\item Gmsh .msh files. Gmsh is a mesh generator freely available on the
web at \url{http://geuz.org/gmsh/}, and is included in Linux distributions 
such as Ubuntu. This is the recommended file format. Instructions on how 
to generate a mesh using gmsh can be found ...
\item Triangle format. This is stored as a set of 3 files: a .node file,
a .ele file and a .face (3D) or .edge (2D) or .bound (1D) file. This file format
is mainly supported for special purposes, like 1D meshes, and some offline 
tools.
\end{enumerate}

Both simplicial meshes (triangles in 2D and tetrahedrals in 3D) and cubical
meshes (quadrilaterals in 2D and hexagons in 3D) are supported. Note however
that the choice between these two types of meshes also has an influence
on the choice of the polynomial space that is used in the 
finite element discretisation. Choosing for instance a polynomial degree 
of 1 (see ...) means that for simplicial meshes linear polynomials are used
(the \Pone discretisation) whereas on cubical meshes this leads to bilinear
polynomials (known as a \Qone discretisation). Therefore to use the well known
\Poo discretisation or the \PoDGPt discretisation (recommended for large scale
ocean applications) a simplicial input mesh is needed. Structured meshes in two
or three dimensions can be generated by stacking two triangles in a rectangle,
or six tetrahedrals in a cube respectively. Such meshes are easily obtained
using gmsh.

\subsection{Surface and regions ids}
\index{surface ID}
\index{region ID}
Surface ids are used in \fluidity\ to mark different parts of the boundary of the
computational domain so that different boundary conditions can be associated
with them. Regions ids are used to mark different parts of the domain itself.
Both ids can be defined in gmsh by assigning physical ids to different
geometrical objects. In two dimensions surface ids can be defined by assigning a
physical id to each group of lines that make up a part of the boundary that
needs to be considered seperately. Region ids can be defined by dividing the
domain up in different (groups of) surfaces and assigning different 
physical ids to them. Similarly, in three dimensions surface ids are defined by
assigining physical surface ids in gmsh, and regions ids by assigning physical
volume ids.

It is recommended, and required in parallel, that all parts of the domain
boundary are marked with a surface id. Region ids are optional. They can be used
to instruct the adaptivity library to strictly maintain the interface between 
different regions of the domain. They also come very handy to set different constant 
field values in the regions.

\section{Mesh types}
\subsection{Extruded meshes}
\label{sect:extruded_meshes}
\index{mesh!extruded}

Given a 1D or 2D input mesh, \fluidity\ can extrude this
mesh to create a layered 2D or 3D mesh, on which simulations can be
performed. The extrusion is always downwards (in the direction of gravity), 
and the top of the domain is always flat, corresponding to the $y=0$-level 
in 2 dimension, the $z=0$ level in 3 dimensions, or the equilibrium 
free surface geoid when running on the sphere.

The advantage of this approach is that the user can provide a horizontal mesh,
that has been created in the normal way (usually gmsh), and all the
configuration related to bathymetry, number of layers and layer depths can be
done in the .flml (see \ref{Sect:extruded} for all options available). It also
enables the application of mesh adaptivity in the horizontal and vertical
independently. This means we can choose to apply adaptivity in the horizontal
only and keep a fixed number of layers, or we can choose to keep the horizontal
mesh fixed and dynamically adjust the vertical grid spacing (vertical
adaptivity). The combination of both horizontal and vertical adaptivity is
referred to as ``2+1'' adaptivity, which is described further in ...

\subsection{Periodic meshes}
\index{mesh!periodic} 
\index{periodic domain} 
\label{mesh!mesh types!periodic} 
Periodic meshes are those that are ``virtually'' connected in one or more directions. To make a periodic
mesh you must first create a triangle file where the edges that are periodic
can be mapped exactly by a simple transformation. For example, if the mesh
is periodic in the $x$-direction, the two edges must have nodes at exactly the
same height on each side. This can be easily accomplished using the
\lstinline[language=Bash]+create_aligned_mesh+ script in the scripts folder.

Alternatively, if you require a more complex periodic mesh with some structure between the periodic 
boundaries you can create one using \lstinline[language=Bash]{gmsh}. This can be achieved by 
setting up the periodic boundaries by using extrude and then deleting the 'internal' mesh.

The use of periodic domains requires additional configuration options. See
section \ref{Sect:periodic}.

\section{Meshing tools}
\index{mesh!meshing tools}

There are a number of meshing tools in both the scripts and tools directories.

\subsection{interval}
\index{mesh!meshing tools!interval}
This is a 1D mesh generator and is in the scripts directory. To use simply type:


\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/scripts/interval [options] left right name 
\end{lstlisting}

where left and right define the range of the line. It has a number of user defined input options:


\begin{center}
  \begin{tabular}{lp{.6\textwidth}}
    \hline
    \lstinline+--dx+ & constant interval spacing\\
    \lstinline+--variable_dx+ & interval spacing defined with a python function\\
    \lstinline+--region_ids+ & python function defining the region ID at each point\\
    \lstinline+--reverse+ & reverse order of mesh\\
    \hline
  \end{tabular}
\end{center}



\subsection{gmsh2triangle}
\index{mesh!meshing tools!gmsh2triangle}

This script converts ASCII Gmsh mesh files into triangle format. Whilst Fluidity
can read in Gmsh files directly as noted in section \ref{sect:using_gmsh}, in
cases where native Gmsh support does not work you should use 
\lstinline[language = Bash]+gmsh2triangle+ instead.

% Its use is now
% deprecated in favour of directly reading Gmsh files into \fluidity. See
% section \ref{sect:gmsh_format}.

\lstinline[language=Bash]{gmsh2triangle} stores the entire gmsh mesh in memory before writing it out to
triangle file. For very large meshes this is likely to be impractical,
and instead the \lstinline[language=Bash]{gmsh2triangle_large} script
should be used. This stores a minimal amount of data in memory at 
any one time, but is slower for small files as it requires the 
input .msh file to be read multiple times.

\lstinline[language=Bash]{gmsh2triangle[_large]} is used via:

\begin{lstlisting}[language = Bash]
gmsh2triangle[_large] input
\end{lstlisting}

where \lstinline[language = Bash]*input* is the input .msh file.

The \lstinline[language = Bash]+--2d+ flag can be used to instruct \lstinline+gmsh2triangle[_large]+
to process a 2D input .msh file. Otherwise, 3D input is assumed.

\subsection{triangle2vtu}
\index{mesh!meshing tools!triangle2vtu}
This converts triangle format files in to vtu format. It is in the fluidity tools directory and is used with:

\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/tools/triangle2vtu foo
\end{lstlisting}

Where \lstinline+foo+ is the triangle file base name (\lstinline+foo.node+ etc.)

\section{Decomposing meshes for parallel}
\label{decomp_meshes_parallel}
\index{parallel!mesh decomposition}

The first step in running a \fluidity\ set-up in parallel is to create the software
used to decompose the initial mesh into multiple parts. This can be made using:
\begin{lstlisting}[language=bash]
make fltools
\end{lstlisting}
inside your \fluidity\ folder. The following binaries will then be created in the \lstinline+bin/+ directory (see section \ref{sect:fltools}).
%You can then decompose the initial mesh the following command
%\begin{lstlisting}[language=bash]
%fluidity path /bin/fldecomp -n [PARTS] [BASENAME]
%\end{lstlisting}



\subsection{fldecomp}
\index{mesh!meshing tools!fldecomp}
\label{mesh!meshing tools!fldecomp}
This program is used to decompose a mesh into multiple regions, one per
process. In order to run fldecomp, if your mesh files have the base name
\lstinline{foo}\ and you want to decompose into four parts, type:
\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/bin/fldecomp -n 4 -m mesh_format mesh_file
\end{lstlisting}

Where:
\begin{center}
  \begin{tabular}{lp{.8\textwidth}}
    \lstinline+mesh_file+ & is the base name of your mesh file(s). For
    example, \lstinline+foo+ for \lstinline+foo.msh+ with Gmsh format, or
    \lstinline+foo.face/node/ele+ with triangle format.\\
    \lstinline+mesh_format+ & is the format of the mesh file you wish to
    decompose. It can take two values: \lstinline+gmsh+ or
    \lstinline+triangle+. If you omit the \lstinline+-m+ option,
    \lstinline+fldecomp+ will default to \lstinline+triangle+.
  \end{tabular}
\end{center}

For performance reasons, \lstinline[language=Bash]{fldecomp} supports only
binary Gmsh files. These are generated by passing the \lstinline{-bin}\
argument to Gmsh, for example:

\begin{lstlisting}[language=bash]
gmsh -3 -bin project.geo -o project.msh
\end{lstlisting}

This creates a 3D binary Gmsh mesh called \lstinline{project.msh} from the geometry file.



\subsection{flredecomp}
\index{mesh!meshing tools!flredecomp}
\label{mesh!meshing tools!flredecomp}
This is similar to fldecomp but runs in parallel. It is invoked as follows:
\begin{lstlisting}[language=bash]
mpiexec -n [target number of processors] \
   `\fluiditysourcepath'/bin/flredecomp \
        -i [input number of processors] \
        -o [target number of processors] [input flml] [output flml]
\end{lstlisting}

For example, to decompose the serial file \lstinline+foo.flml+
into four parts, type:

\begin{lstlisting}[language=bash]
mpiexec -n 4 `\fluiditysourcepath'/bin/flredecomp \
    -i 1 -o 4 foo foo_flredecomp
\end{lstlisting}

The output of running flredecomp is a series of mesh and vtu files as well
as the new flml; in this case \lstinline+foo_flredecomp.flml+.

%\subsubsection{Decomposing a periodic mesh}
\subsection{periodise}
\index{mesh!meshing tools!periodise}
\label{sect:decomposing_meshes_periodise}

To be able to run \fluidity\ on a periodic mesh in parallel you have to use
two tools (these tools are built as part of the fltools build target (see
section \ref{sect:fltools})):

\begin{itemize}
\item periodise
\item flredecomp (\ref{mesh!meshing tools!flredecomp})
\end{itemize}

The input to periodise is your flml (in this case
\lstinline{foo.flml}). This flml file should already contain the mapping for
the periodic boundary as described in section
\ref{Sect:periodic}. Periodise is run with the command:

\begin{lstlisting}[language=bash]
`\fluiditysourcepath'/bin/periodise foo.flml
\end{lstlisting}

The output is a new flml called \lstinline+foo_periodised.flml+ and the
periodic meshes. Next run flredecomp (section \ref{mesh!meshing
  tools!flredecomp}) to decompose the mesh for the number of processors
required. The flml output by flredecomp is then used to execute the actual simulation:

\begin{lstlisting}[language=bash]
mpiexec -n [number of processors] \
   `\fluiditysourcepath'/bin/fluidity [options] \
   foo_periodised_flredecomp.flml
\end{lstlisting}

\section{Pseudo-meshing}

The tool pseudo\_mesh enables the generation of a mesh of equal local resolution
to some prescribed input mesh. This is sometimes useful for the purposes of
interpolation comparison. pseudo\_mesh achieves this by computing an adaptivity
metric (see section \ref{sec:meshes_and_metrics}) derived from the input mesh
via a polar decomposition of the
elemental Jacobian \citep{micheletti2006}, and supplying this to the mesh adaptivity libraries
(see section \ref{sec:adaptive_remeshing_technology}).

pseudo\_mesh is not built by default as part of the \fluidity\ tools package. To
build the tool type:

\begin{lstlisting}[language = Bash]
cd tools
make ../bin/pseudo_mesh
\end{lstlisting}

pseudo\_mesh is invoked as:

\begin{lstlisting}[language = Bash]
pseudo_mesh [-thv] input_basename
\end{lstlisting}

where \lstinline[language = Bash]*input_basename* is the base name of an input
triangle file. If the \lstinline[language = Bash]*-t* flag is supplied then
then the metric used to form the output mesh is limited to target the element
count of the input mesh.

psuedo\_mesh is parallelised, and accepts the following options:

\begin{center}
  \begin{tabular}{lp{.6\textwidth}}
    \hline
 %   Flag & Function \\
 %   \hline
    \lstinline+-h+   & Display help \\
    \lstinline+-t+   & Limit the metric used to form the output mesh to
    target the element count of the input mesh \\
    \lstinline+-v+   & Verbose mode \\
    \hline
  \end{tabular}
\end{center}

\section{Mesh verification}
\index{mesh!verification}

The tool checkmesh can be used to form a number of verification tests on a mesh
in triangle mesh format. This tool is build as part of the fltools build target
(see section \ref{sect:fltools}), and is invoked as:

\begin{lstlisting}[language = Bash]
checkmesh input_basename
\end{lstlisting}

where \lstinline[language = Bash]*input_basename* is the base name of an input
triangle file. checkmesh tests for:

\begin{enumerate}
  \item Degenerate volume elements;
  \item Inverted tetrahedra;
  \item Degenerate surface elements;
  \item\label{item:mesh_tangling} Mesh tangling.
\end{enumerate}

% Test \ref{item:mesh_tangling} is performed by testing for any mesh self-intersections
% via mesh intersection (see section \ref{sec:supermeshing}).

checkmesh is parallelised. If running in parallel, it should be launched on
a number of processes equal to that in the mesh decomposition. In parallel
checkmesh output is written to \onlypdf\linebreak \lstinline+checkmesh.log-[process]+
and \lstinline+checkmesh.err-[process]+ log files.

\begin{example}
\begin{lstlisting}[language = Bash,keywordstyle=]
Checking volume elements for tangling ...
 In intersection_finder
 In advancing_front_intersection_finder
 Exiting advancing_front_intersection_finder
 Exiting intersection_finder
Tangled volume element found: 
Element: 1
Coordinates:
  0.10000000000000000E+001  0.00000000000000000E+000
  0.11666666666700001E+001  0.00000000000000000E+000
  0.83867056794499995E+000  0.54463903501499999E+000
Numbering:
           1
          14
           2
\end{lstlisting}
\caption{checkmesh reporting a mesh tangling error.}
\end{example}

\section{Non-\fluidity\ tools}

In addition to the tools and capabilities of \fluidity, there are numerous
tools and software packages available for mesh generation. Here, we describe 
two of the tools commonly used.

\subsection{Terreno}
\index{mesh!meshing tools!Terreno}
\index{Terreno}

Terreno uses a 2D anisotropic mesh optimisation algorithm to explicitly optimise for 
element quality and bathymetric approximation while minimising the number of mesh
elements created. The shoreline used in the mesh generation process is the result 
of a polyline approximation algorithm that where the minimum length of the resulting 
edges is considered as well as the distance an edge is from a vertex on the original 
shoreline segment being approximated. The underlying philosophy is that meshing and 
approximation should be error driven and should minimise user intervention. The 
latter point is two pronged: usability is paramount and the user should not need 
to be an expert in mesh generation to generate high quality meshes for their ocean 
model; fundamentally there must be clearly defined objectives to the mesh generation 
process to ensure reproducibility of results. The result is an unstructured mesh, 
which may be anisotropic, which focuses resolution where it is required to optimally 
approximate the bathymetry of the domain. The criterion to judge the quality of the 
mesh is defined in terms of clearly defined objectives. An important feature of the 
approach is that it facilitates multi-objective mesh optimisation. This allows one to 
simultaneously optimise the approximation to other variables in addition to the 
bathymetry on the same mesh, such as back-scatter data from soundings, material 
properties or climatology data. 

See the \href{http://amcg.ese.ic.ac.uk/terreno}{Terreno website}\ for more information.

\subsection{Gmsh}
\index{mesh!meshing tools!gmsh}
\index{gmsh}
\label{sect:meshing_tools_non_fluidity_gmsh}

Gmsh is a 3D finite element mesh generator with a build-in CAD engine and post-processor.
Its design goal is to provide a fast, light and user-friendly meshing tool with parametric
input and advanced visualisation capabilities. Gmsh is built around four modules: geometry, 
mesh, solver and post-processing. The specification of any input to these modules is done
either interactively using the graphical user interface or in ASCII text files using Gmsh's
own scripting language. 

For more information see the \href{http://geuz.org/gmsh/}{Gmsh website}\ or the \href{http://amcg.ese.ic.ac.uk}{AMCG
website}. An online manual is available at \href{http://geuz.org/gmsh/doc/texinfo/gmsh.html}{geuz.org/gmsh/doc/texinfo/gmsh.html}.

\subsection{Importing contours from bathymetric data into Gmsh}
\index{mesh!generation!gmsh!entering! bathymetry! data! into! fluidity! using! Gmsh}
\index{Entering bathymetry data into fluidity using Gmsh}

Gmsh can be used to create a mesh of a `real' ocean domain for use with \fluidity. An online guide to using Gmsh's built in
GSHHS plug-in is available at \href{http://perso.uclouvain.be/jonathan.lambrechts/gmsh_ocean/}{gmsh\_ocean}.
It is also possible to import contours from arbitrary bathymetry data sources into Gmsh. A guide and sample code detailing this process will
in the future be available on the \href{http://amcg.ese.ic.ac.uk}{AMCG website}.
